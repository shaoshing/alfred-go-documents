#=================== generated by update.rb
apis = [
  ["tar", "import \"archive/tar\""],
  ["tar.TypeBlock", "archive/tar: const TypeBlock ideal-char"],
  ["tar.TypeChar", "archive/tar: const TypeChar ideal-char"],
  ["tar.TypeCont", "archive/tar: const TypeCont ideal-char"],
  ["tar.TypeDir", "archive/tar: const TypeDir ideal-char"],
  ["tar.TypeFifo", "archive/tar: const TypeFifo ideal-char"],
  ["tar.TypeLink", "archive/tar: const TypeLink ideal-char"],
  ["tar.TypeReg", "archive/tar: const TypeReg ideal-char"],
  ["tar.TypeRegA", "archive/tar: const TypeRegA ideal-char"],
  ["tar.TypeSymlink", "archive/tar: const TypeSymlink ideal-char"],
  ["tar.TypeXGlobalHeader", "archive/tar: const TypeXGlobalHeader ideal-char"],
  ["tar.TypeXHeader", "archive/tar: const TypeXHeader ideal-char"],
  ["tar.NewReader", "archive/tar: func NewReader(io.Reader) *Reader"],
  ["tar.NewWriter", "archive/tar: func NewWriter(io.Writer) *Writer"],
  ["tar.Reader.Next", "archive/tar: method (*Reader) Next() (*Header: error)"],
  ["tar.Reader.Read", "archive/tar: method (*Reader) Read([]byte) (int: error)"],
  ["tar.Writer.Close", "archive/tar: method (*Writer) Close() error"],
  ["tar.Writer.Flush", "archive/tar: method (*Writer) Flush() error"],
  ["tar.Writer.Write", "archive/tar: method (*Writer) Write([]byte) (int: error)"],
  ["tar.Writer.WriteHeader", "archive/tar: method (*Writer) WriteHeader(*Header) error"],
  ["tar.Header", "archive/tar: type Header struct"],
  ["tar.Reader", "archive/tar: type Reader struct"],
  ["tar.Writer", "archive/tar: type Writer struct"],
  ["zip", "import \"archive/zip\""],
  ["zip.Deflate", "archive/zip: const Deflate uint16"],
  ["zip.Store", "archive/zip: const Store uint16"],
  ["zip.FileInfoHeader", "archive/zip: func FileInfoHeader(os.FileInfo) (*FileHeader: error)"],
  ["zip.NewReader", "archive/zip: func NewReader(io.ReaderAt: int64) (*Reader: error)"],
  ["zip.NewWriter", "archive/zip: func NewWriter(io.Writer) *Writer"],
  ["zip.OpenReader", "archive/zip: func OpenReader(string) (*ReadCloser: error)"],
  ["zip.File.FileInfo", "archive/zip: method (*File) FileInfo() os.FileInfo"],
  ["zip.File.ModTime", "archive/zip: method (*File) ModTime() time.Time"],
  ["zip.File.Mode", "archive/zip: method (*File) Mode() os.FileMode"],
  ["zip.File.Open", "archive/zip: method (*File) Open() (io.ReadCloser: error)"],
  ["zip.File.SetModTime", "archive/zip: method (*File) SetModTime(time.Time)"],
  ["zip.File.SetMode", "archive/zip: method (*File) SetMode(os.FileMode)"],
  ["zip.FileHeader.FileInfo", "archive/zip: method (*FileHeader) FileInfo() os.FileInfo"],
  ["zip.FileHeader.ModTime", "archive/zip: method (*FileHeader) ModTime() time.Time"],
  ["zip.FileHeader.Mode", "archive/zip: method (*FileHeader) Mode() os.FileMode"],
  ["zip.FileHeader.SetModTime", "archive/zip: method (*FileHeader) SetModTime(time.Time)"],
  ["zip.FileHeader.SetMode", "archive/zip: method (*FileHeader) SetMode(os.FileMode)"],
  ["zip.ReadCloser.Close", "archive/zip: method (*ReadCloser) Close() error"],
  ["zip.Writer.Close", "archive/zip: method (*Writer) Close() error"],
  ["zip.Writer.Create", "archive/zip: method (*Writer) Create(string) (io.Writer: error)"],
  ["zip.Writer.CreateHeader", "archive/zip: method (*Writer) CreateHeader(*FileHeader) (io.Writer: error)"],
  ["zip.File", "archive/zip: type File struct"],
  ["zip.FileHeader", "archive/zip: type FileHeader struct"],
  ["zip.ReadCloser", "archive/zip: type ReadCloser struct"],
  ["zip.Reader", "archive/zip: type Reader struct"],
  ["zip.Writer", "archive/zip: type Writer struct"],
  ["bufio", "import \"bufio\""],
  ["bufio.NewReadWriter", "bufio: func NewReadWriter(*Reader: *Writer) *ReadWriter"],
  ["bufio.NewReader", "bufio: func NewReader(io.Reader) *Reader"],
  ["bufio.NewReaderSize", "bufio: func NewReaderSize(io.Reader: int) *Reader"],
  ["bufio.NewWriter", "bufio: func NewWriter(io.Writer) *Writer"],
  ["bufio.NewWriterSize", "bufio: func NewWriterSize(io.Writer: int) *Writer"],
  ["bufio.Reader.Buffered", "bufio: method (*Reader) Buffered() int"],
  ["bufio.Reader.Peek", "bufio: method (*Reader) Peek(int) ([]byte: error)"],
  ["bufio.Reader.Read", "bufio: method (*Reader) Read([]byte) (int: error)"],
  ["bufio.Reader.ReadByte", "bufio: method (*Reader) ReadByte() (byte: error)"],
  ["bufio.Reader.ReadBytes", "bufio: method (*Reader) ReadBytes(byte) ([]byte: error)"],
  ["bufio.Reader.ReadLine", "bufio: method (*Reader) ReadLine() ([]byte: bool: error)"],
  ["bufio.Reader.ReadRune", "bufio: method (*Reader) ReadRune() (rune: int: error)"],
  ["bufio.Reader.ReadSlice", "bufio: method (*Reader) ReadSlice(byte) ([]byte: error)"],
  ["bufio.Reader.ReadString", "bufio: method (*Reader) ReadString(byte) (string: error)"],
  ["bufio.Reader.UnreadByte", "bufio: method (*Reader) UnreadByte() error"],
  ["bufio.Reader.UnreadRune", "bufio: method (*Reader) UnreadRune() error"],
  ["bufio.Writer.Available", "bufio: method (*Writer) Available() int"],
  ["bufio.Writer.Buffered", "bufio: method (*Writer) Buffered() int"],
  ["bufio.Writer.Flush", "bufio: method (*Writer) Flush() error"],
  ["bufio.Writer.Write", "bufio: method (*Writer) Write([]byte) (int: error)"],
  ["bufio.Writer.WriteByte", "bufio: method (*Writer) WriteByte(byte) error"],
  ["bufio.Writer.WriteRune", "bufio: method (*Writer) WriteRune(rune) (int: error)"],
  ["bufio.Writer.WriteString", "bufio: method (*Writer) WriteString(string) (int: error)"],
  ["bufio.ReadWriter.Available", "bufio: method (ReadWriter) Available() int"],
  ["bufio.ReadWriter.Flush", "bufio: method (ReadWriter) Flush() error"],
  ["bufio.ReadWriter.Peek", "bufio: method (ReadWriter) Peek(int) ([]byte: error)"],
  ["bufio.ReadWriter.Read", "bufio: method (ReadWriter) Read([]byte) (int: error)"],
  ["bufio.ReadWriter.ReadByte", "bufio: method (ReadWriter) ReadByte() (byte: error)"],
  ["bufio.ReadWriter.ReadBytes", "bufio: method (ReadWriter) ReadBytes(byte) ([]byte: error)"],
  ["bufio.ReadWriter.ReadLine", "bufio: method (ReadWriter) ReadLine() ([]byte: bool: error)"],
  ["bufio.ReadWriter.ReadRune", "bufio: method (ReadWriter) ReadRune() (rune: int: error)"],
  ["bufio.ReadWriter.ReadSlice", "bufio: method (ReadWriter) ReadSlice(byte) ([]byte: error)"],
  ["bufio.ReadWriter.ReadString", "bufio: method (ReadWriter) ReadString(byte) (string: error)"],
  ["bufio.ReadWriter.UnreadByte", "bufio: method (ReadWriter) UnreadByte() error"],
  ["bufio.ReadWriter.UnreadRune", "bufio: method (ReadWriter) UnreadRune() error"],
  ["bufio.ReadWriter.Write", "bufio: method (ReadWriter) Write([]byte) (int: error)"],
  ["bufio.ReadWriter.WriteByte", "bufio: method (ReadWriter) WriteByte(byte) error"],
  ["bufio.ReadWriter.WriteRune", "bufio: method (ReadWriter) WriteRune(rune) (int: error)"],
  ["bufio.ReadWriter.WriteString", "bufio: method (ReadWriter) WriteString(string) (int: error)"],
  ["bufio.ReadWriter", "bufio: type ReadWriter struct"],
  ["bufio.Reader", "bufio: type Reader struct"],
  ["bufio.Writer", "bufio: type Writer struct"],
  ["bytes", "import \"bytes\""],
  ["bytes.MinRead", "bytes: const MinRead ideal-int"],
  ["bytes.Compare", "bytes: func Compare([]byte) int"],
  ["bytes.Contains", "bytes: func Contains([]byte) bool"],
  ["bytes.Count", "bytes: func Count([]byte) int"],
  ["bytes.Equal", "bytes: func Equal([]byte) bool"],
  ["bytes.EqualFold", "bytes: func EqualFold([]byte) bool"],
  ["bytes.Fields", "bytes: func Fields([]byte) [][]byte"],
  ["bytes.FieldsFunc", "bytes: func FieldsFunc([]byte: func(rune) bool) [][]byte"],
  ["bytes.HasPrefix", "bytes: func HasPrefix([]byte) bool"],
  ["bytes.HasSuffix", "bytes: func HasSuffix([]byte) bool"],
  ["bytes.Index", "bytes: func Index([]byte) int"],
  ["bytes.IndexAny", "bytes: func IndexAny([]byte: string) int"],
  ["bytes.IndexByte", "bytes: func IndexByte([]byte: byte) int"],
  ["bytes.IndexFunc", "bytes: func IndexFunc([]byte: func(rune) bool) int"],
  ["bytes.IndexRune", "bytes: func IndexRune([]byte: rune) int"],
  ["bytes.Join", "bytes: func Join([][]byte: []byte) []byte"],
  ["bytes.LastIndex", "bytes: func LastIndex([]byte) int"],
  ["bytes.LastIndexAny", "bytes: func LastIndexAny([]byte: string) int"],
  ["bytes.LastIndexFunc", "bytes: func LastIndexFunc([]byte: func(rune) bool) int"],
  ["bytes.Map", "bytes: func Map(func(rune) rune: []byte) []byte"],
  ["bytes.NewBuffer", "bytes: func NewBuffer([]byte) *Buffer"],
  ["bytes.NewBufferString", "bytes: func NewBufferString(string) *Buffer"],
  ["bytes.NewReader", "bytes: func NewReader([]byte) *Reader"],
  ["bytes.Repeat", "bytes: func Repeat([]byte: int) []byte"],
  ["bytes.Replace", "bytes: func Replace([]byte: int) []byte"],
  ["bytes.Runes", "bytes: func Runes([]byte) []rune"],
  ["bytes.Split", "bytes: func Split([]byte) [][]byte"],
  ["bytes.SplitAfter", "bytes: func SplitAfter([]byte) [][]byte"],
  ["bytes.SplitAfterN", "bytes: func SplitAfterN([]byte: int) [][]byte"],
  ["bytes.SplitN", "bytes: func SplitN([]byte: int) [][]byte"],
  ["bytes.Title", "bytes: func Title([]byte) []byte"],
  ["bytes.ToLower", "bytes: func ToLower([]byte) []byte"],
  ["bytes.ToLowerSpecial", "bytes: func ToLowerSpecial(unicode.SpecialCase: []byte) []byte"],
  ["bytes.ToTitle", "bytes: func ToTitle([]byte) []byte"],
  ["bytes.ToTitleSpecial", "bytes: func ToTitleSpecial(unicode.SpecialCase: []byte) []byte"],
  ["bytes.ToUpper", "bytes: func ToUpper([]byte) []byte"],
  ["bytes.ToUpperSpecial", "bytes: func ToUpperSpecial(unicode.SpecialCase: []byte) []byte"],
  ["bytes.Trim", "bytes: func Trim([]byte: string) []byte"],
  ["bytes.TrimFunc", "bytes: func TrimFunc([]byte: func(rune) bool) []byte"],
  ["bytes.TrimLeft", "bytes: func TrimLeft([]byte: string) []byte"],
  ["bytes.TrimLeftFunc", "bytes: func TrimLeftFunc([]byte: func(rune) bool) []byte"],
  ["bytes.TrimRight", "bytes: func TrimRight([]byte: string) []byte"],
  ["bytes.TrimRightFunc", "bytes: func TrimRightFunc([]byte: func(rune) bool) []byte"],
  ["bytes.TrimSpace", "bytes: func TrimSpace([]byte) []byte"],
  ["bytes.Buffer.Bytes", "bytes: method (*Buffer) Bytes() []byte"],
  ["bytes.Buffer.Len", "bytes: method (*Buffer) Len() int"],
  ["bytes.Buffer.Next", "bytes: method (*Buffer) Next(int) []byte"],
  ["bytes.Buffer.Read", "bytes: method (*Buffer) Read([]byte) (int: error)"],
  ["bytes.Buffer.ReadByte", "bytes: method (*Buffer) ReadByte() (byte: error)"],
  ["bytes.Buffer.ReadBytes", "bytes: method (*Buffer) ReadBytes(byte) ([]byte: error)"],
  ["bytes.Buffer.ReadFrom", "bytes: method (*Buffer) ReadFrom(io.Reader) (int64: error)"],
  ["bytes.Buffer.ReadRune", "bytes: method (*Buffer) ReadRune() (rune: int: error)"],
  ["bytes.Buffer.ReadString", "bytes: method (*Buffer) ReadString(byte) (string: error)"],
  ["bytes.Buffer.Reset", "bytes: method (*Buffer) Reset()"],
  ["bytes.Buffer.String", "bytes: method (*Buffer) String() string"],
  ["bytes.Buffer.Truncate", "bytes: method (*Buffer) Truncate(int)"],
  ["bytes.Buffer.UnreadByte", "bytes: method (*Buffer) UnreadByte() error"],
  ["bytes.Buffer.UnreadRune", "bytes: method (*Buffer) UnreadRune() error"],
  ["bytes.Buffer.Write", "bytes: method (*Buffer) Write([]byte) (int: error)"],
  ["bytes.Buffer.WriteByte", "bytes: method (*Buffer) WriteByte(byte) error"],
  ["bytes.Buffer.WriteRune", "bytes: method (*Buffer) WriteRune(rune) (int: error)"],
  ["bytes.Buffer.WriteString", "bytes: method (*Buffer) WriteString(string) (int: error)"],
  ["bytes.Buffer.WriteTo", "bytes: method (*Buffer) WriteTo(io.Writer) (int64: error)"],
  ["bytes.Reader.Len", "bytes: method (*Reader) Len() int"],
  ["bytes.Reader.Read", "bytes: method (*Reader) Read([]byte) (int: error)"],
  ["bytes.Reader.ReadAt", "bytes: method (*Reader) ReadAt([]byte: int64) (int: error)"],
  ["bytes.Reader.ReadByte", "bytes: method (*Reader) ReadByte() (byte: error)"],
  ["bytes.Reader.ReadRune", "bytes: method (*Reader) ReadRune() (rune: int: error)"],
  ["bytes.Reader.Seek", "bytes: method (*Reader) Seek(int64: int) (int64: error)"],
  ["bytes.Reader.UnreadByte", "bytes: method (*Reader) UnreadByte() error"],
  ["bytes.Reader.UnreadRune", "bytes: method (*Reader) UnreadRune() error"],
  ["bytes.Buffer", "bytes: type Buffer struct"],
  ["bytes.Reader", "bytes: type Reader struct"],
  ["bzip2", "import \"compress/bzip2\""],
  ["bzip2.NewReader", "compress/bzip2: func NewReader(io.Reader) io.Reader"],
  ["bzip2.StructuralError.Error", "compress/bzip2: method (StructuralError) Error() string"],
  ["bzip2.StructuralError", "compress/bzip2: type StructuralError string"],
  ["flate", "import \"compress/flate\""],
  ["flate.BestCompression", "compress/flate: const BestCompression ideal-int"],
  ["flate.BestSpeed", "compress/flate: const BestSpeed ideal-int"],
  ["flate.DefaultCompression", "compress/flate: const DefaultCompression ideal-int"],
  ["flate.NoCompression", "compress/flate: const NoCompression ideal-int"],
  ["flate.NewReader", "compress/flate: func NewReader(io.Reader) io.ReadCloser"],
  ["flate.NewReaderDict", "compress/flate: func NewReaderDict(io.Reader: []byte) io.ReadCloser"],
  ["flate.NewWriter", "compress/flate: func NewWriter(io.Writer: int) (*Writer: error)"],
  ["flate.NewWriterDict", "compress/flate: func NewWriterDict(io.Writer: int: []byte) (*Writer: error)"],
  ["flate.ReadError.Error", "compress/flate: method (*ReadError) Error() string"],
  ["flate.WriteError.Error", "compress/flate: method (*WriteError) Error() string"],
  ["flate.Writer.Close", "compress/flate: method (*Writer) Close() error"],
  ["flate.Writer.Flush", "compress/flate: method (*Writer) Flush() error"],
  ["flate.Writer.Write", "compress/flate: method (*Writer) Write([]byte) (int: error)"],
  ["flate.CorruptInputError.Error", "compress/flate: method (CorruptInputError) Error() string"],
  ["flate.InternalError.Error", "compress/flate: method (InternalError) Error() string"],
  ["flate.CorruptInputError", "compress/flate: type CorruptInputError int64"],
  ["flate.InternalError", "compress/flate: type InternalError string"],
  ["flate.ReadError", "compress/flate: type ReadError struct"],
  ["flate.Reader", "compress/flate: type Reader interface { Read: ReadByte }"],
  ["flate.WriteError", "compress/flate: type WriteError struct"],
  ["flate.Writer", "compress/flate: type Writer struct"],
  ["gzip", "import \"compress/gzip\""],
  ["gzip.BestCompression", "compress/gzip: const BestCompression ideal-int"],
  ["gzip.BestSpeed", "compress/gzip: const BestSpeed ideal-int"],
  ["gzip.DefaultCompression", "compress/gzip: const DefaultCompression ideal-int"],
  ["gzip.NoCompression", "compress/gzip: const NoCompression ideal-int"],
  ["gzip.NewReader", "compress/gzip: func NewReader(io.Reader) (*Reader: error)"],
  ["gzip.NewWriter", "compress/gzip: func NewWriter(io.Writer) *Writer"],
  ["gzip.NewWriterLevel", "compress/gzip: func NewWriterLevel(io.Writer: int) (*Writer: error)"],
  ["gzip.Reader.Close", "compress/gzip: method (*Reader) Close() error"],
  ["gzip.Reader.Read", "compress/gzip: method (*Reader) Read([]byte) (int: error)"],
  ["gzip.Writer.Close", "compress/gzip: method (*Writer) Close() error"],
  ["gzip.Writer.Write", "compress/gzip: method (*Writer) Write([]byte) (int: error)"],
  ["gzip.Header", "compress/gzip: type Header struct"],
  ["gzip.Reader", "compress/gzip: type Reader struct"],
  ["gzip.Writer", "compress/gzip: type Writer struct"],
  ["lzw", "import \"compress/lzw\""],
  ["lzw.LSB", "compress/lzw: const LSB Order"],
  ["lzw.MSB", "compress/lzw: const MSB Order"],
  ["lzw.NewReader", "compress/lzw: func NewReader(io.Reader: Order: int) io.ReadCloser"],
  ["lzw.NewWriter", "compress/lzw: func NewWriter(io.Writer: Order: int) io.WriteCloser"],
  ["lzw.Order", "compress/lzw: type Order int"],
  ["zlib", "import \"compress/zlib\""],
  ["zlib.BestCompression", "compress/zlib: const BestCompression ideal-int"],
  ["zlib.BestSpeed", "compress/zlib: const BestSpeed ideal-int"],
  ["zlib.DefaultCompression", "compress/zlib: const DefaultCompression ideal-int"],
  ["zlib.NoCompression", "compress/zlib: const NoCompression ideal-int"],
  ["zlib.NewReader", "compress/zlib: func NewReader(io.Reader) (io.ReadCloser: error)"],
  ["zlib.NewReaderDict", "compress/zlib: func NewReaderDict(io.Reader: []byte) (io.ReadCloser: error)"],
  ["zlib.NewWriter", "compress/zlib: func NewWriter(io.Writer) *Writer"],
  ["zlib.NewWriterLevel", "compress/zlib: func NewWriterLevel(io.Writer: int) (*Writer: error)"],
  ["zlib.NewWriterLevelDict", "compress/zlib: func NewWriterLevelDict(io.Writer: int: []byte) (*Writer: error)"],
  ["zlib.Writer.Close", "compress/zlib: method (*Writer) Close() error"],
  ["zlib.Writer.Flush", "compress/zlib: method (*Writer) Flush() error"],
  ["zlib.Writer.Write", "compress/zlib: method (*Writer) Write([]byte) (int: error)"],
  ["zlib.Writer", "compress/zlib: type Writer struct"],
  ["heap", "import \"container/heap\""],
  ["heap.Init", "container/heap: func Init(Interface)"],
  ["heap.Pop", "container/heap: func Pop(Interface) interface{}"],
  ["heap.Push", "container/heap: func Push(Interface: interface{})"],
  ["heap.Remove", "container/heap: func Remove(Interface: int) interface{}"],
  ["heap.Interface", "container/heap: type Interface interface { Len: Less: Pop: Push: Swap }"],
  ["list", "import \"container/list\""],
  ["list.New", "container/list: func New() *List"],
  ["list.Element.Next", "container/list: method (*Element) Next() *Element"],
  ["list.Element.Prev", "container/list: method (*Element) Prev() *Element"],
  ["list.List.Back", "container/list: method (*List) Back() *Element"],
  ["list.List.Front", "container/list: method (*List) Front() *Element"],
  ["list.List.Init", "container/list: method (*List) Init() *List"],
  ["list.List.InsertAfter", "container/list: method (*List) InsertAfter(interface{}: *Element) *Element"],
  ["list.List.InsertBefore", "container/list: method (*List) InsertBefore(interface{}: *Element) *Element"],
  ["list.List.Len", "container/list: method (*List) Len() int"],
  ["list.List.MoveToBack", "container/list: method (*List) MoveToBack(*Element)"],
  ["list.List.MoveToFront", "container/list: method (*List) MoveToFront(*Element)"],
  ["list.List.PushBack", "container/list: method (*List) PushBack(interface{}) *Element"],
  ["list.List.PushBackList", "container/list: method (*List) PushBackList(*List)"],
  ["list.List.PushFront", "container/list: method (*List) PushFront(interface{}) *Element"],
  ["list.List.PushFrontList", "container/list: method (*List) PushFrontList(*List)"],
  ["list.List.Remove", "container/list: method (*List) Remove(*Element) interface{}"],
  ["list.Element", "container/list: type Element struct"],
  ["list.List", "container/list: type List struct"],
  ["ring", "import \"container/ring\""],
  ["ring.New", "container/ring: func New(int) *Ring"],
  ["ring.Ring.Do", "container/ring: method (*Ring) Do(func(interface{}))"],
  ["ring.Ring.Len", "container/ring: method (*Ring) Len() int"],
  ["ring.Ring.Link", "container/ring: method (*Ring) Link(*Ring) *Ring"],
  ["ring.Ring.Move", "container/ring: method (*Ring) Move(int) *Ring"],
  ["ring.Ring.Next", "container/ring: method (*Ring) Next() *Ring"],
  ["ring.Ring.Prev", "container/ring: method (*Ring) Prev() *Ring"],
  ["ring.Ring.Unlink", "container/ring: method (*Ring) Unlink(int) *Ring"],
  ["ring.Ring", "container/ring: type Ring struct"],
  ["crypto", "import \"crypto\""],
  ["crypto.MD4", "crypto: const MD4 Hash"],
  ["crypto.MD5", "crypto: const MD5 Hash"],
  ["crypto.MD5SHA1", "crypto: const MD5SHA1 Hash"],
  ["crypto.RIPEMD160", "crypto: const RIPEMD160 Hash"],
  ["crypto.SHA1", "crypto: const SHA1 Hash"],
  ["crypto.SHA224", "crypto: const SHA224 Hash"],
  ["crypto.SHA256", "crypto: const SHA256 Hash"],
  ["crypto.SHA384", "crypto: const SHA384 Hash"],
  ["crypto.SHA512", "crypto: const SHA512 Hash"],
  ["crypto.RegisterHash", "crypto: func RegisterHash(Hash: func() hash.Hash)"],
  ["crypto.Hash.Available", "crypto: method (Hash) Available() bool"],
  ["crypto.Hash.New", "crypto: method (Hash) New() hash.Hash"],
  ["crypto.Hash.Size", "crypto: method (Hash) Size() int"],
  ["crypto.Hash", "crypto: type Hash uint"],
  ["crypto.PrivateKey", "crypto: type PrivateKey interface {}"],
  ["aes", "import \"crypto/aes\""],
  ["aes.BlockSize", "crypto/aes: const BlockSize ideal-int"],
  ["aes.NewCipher", "crypto/aes: func NewCipher([]byte) (cipher.Block: error)"],
  ["aes.KeySizeError.Error", "crypto/aes: method (KeySizeError) Error() string"],
  ["aes.KeySizeError", "crypto/aes: type KeySizeError int"],
  ["cipher", "import \"crypto/cipher\""],
  ["cipher.NewCBCDecrypter", "crypto/cipher: func NewCBCDecrypter(Block: []byte) BlockMode"],
  ["cipher.NewCBCEncrypter", "crypto/cipher: func NewCBCEncrypter(Block: []byte) BlockMode"],
  ["cipher.NewCFBDecrypter", "crypto/cipher: func NewCFBDecrypter(Block: []byte) Stream"],
  ["cipher.NewCFBEncrypter", "crypto/cipher: func NewCFBEncrypter(Block: []byte) Stream"],
  ["cipher.NewCTR", "crypto/cipher: func NewCTR(Block: []byte) Stream"],
  ["cipher.NewOFB", "crypto/cipher: func NewOFB(Block: []byte) Stream"],
  ["cipher.StreamReader.Read", "crypto/cipher: method (StreamReader) Read([]byte) (int: error)"],
  ["cipher.StreamWriter.Close", "crypto/cipher: method (StreamWriter) Close() error"],
  ["cipher.StreamWriter.Write", "crypto/cipher: method (StreamWriter) Write([]byte) (int: error)"],
  ["cipher.Block", "crypto/cipher: type Block interface { BlockSize: Decrypt: Encrypt }"],
  ["cipher.BlockMode", "crypto/cipher: type BlockMode interface { BlockSize: CryptBlocks }"],
  ["cipher.Stream", "crypto/cipher: type Stream interface { XORKeyStream }"],
  ["cipher.StreamReader", "crypto/cipher: type StreamReader struct"],
  ["cipher.StreamWriter", "crypto/cipher: type StreamWriter struct"],
  ["des", "import \"crypto/des\""],
  ["des.BlockSize", "crypto/des: const BlockSize ideal-int"],
  ["des.NewCipher", "crypto/des: func NewCipher([]byte) (cipher.Block: error)"],
  ["des.NewTripleDESCipher", "crypto/des: func NewTripleDESCipher([]byte) (cipher.Block: error)"],
  ["des.KeySizeError.Error", "crypto/des: method (KeySizeError) Error() string"],
  ["des.KeySizeError", "crypto/des: type KeySizeError int"],
  ["dsa", "import \"crypto/dsa\""],
  ["dsa.L1024N160", "crypto/dsa: const L1024N160 ParameterSizes"],
  ["dsa.L2048N224", "crypto/dsa: const L2048N224 ParameterSizes"],
  ["dsa.L2048N256", "crypto/dsa: const L2048N256 ParameterSizes"],
  ["dsa.L3072N256", "crypto/dsa: const L3072N256 ParameterSizes"],
  ["dsa.GenerateKey", "crypto/dsa: func GenerateKey(*PrivateKey: io.Reader) error"],
  ["dsa.GenerateParameters", "crypto/dsa: func GenerateParameters(*Parameters: io.Reader: ParameterSizes) error"],
  ["dsa.Sign", "crypto/dsa: func Sign(io.Reader: *PrivateKey: []byte) (*big.Int: error)"],
  ["dsa.Verify", "crypto/dsa: func Verify(*PublicKey: []byte: *big.Int) bool"],
  ["dsa.ParameterSizes", "crypto/dsa: type ParameterSizes int"],
  ["dsa.Parameters", "crypto/dsa: type Parameters struct"],
  ["dsa.PrivateKey", "crypto/dsa: type PrivateKey struct"],
  ["dsa.PublicKey", "crypto/dsa: type PublicKey struct"],
  ["ecdsa", "import \"crypto/ecdsa\""],
  ["ecdsa.GenerateKey", "crypto/ecdsa: func GenerateKey(elliptic.Curve: io.Reader) (*PrivateKey: error)"],
  ["ecdsa.Sign", "crypto/ecdsa: func Sign(io.Reader: *PrivateKey: []byte) (*big.Int: error)"],
  ["ecdsa.Verify", "crypto/ecdsa: func Verify(*PublicKey: []byte: *big.Int) bool"],
  ["ecdsa.PrivateKey", "crypto/ecdsa: type PrivateKey struct"],
  ["ecdsa.PublicKey", "crypto/ecdsa: type PublicKey struct"],
  ["elliptic", "import \"crypto/elliptic\""],
  ["elliptic.GenerateKey", "crypto/elliptic: func GenerateKey(Curve: io.Reader) ([]byte: *big.Int: error)"],
  ["elliptic.Marshal", "crypto/elliptic: func Marshal(Curve: *big.Int) []byte"],
  ["elliptic.P224", "crypto/elliptic: func P224() Curve"],
  ["elliptic.P256", "crypto/elliptic: func P256() Curve"],
  ["elliptic.P384", "crypto/elliptic: func P384() Curve"],
  ["elliptic.P521", "crypto/elliptic: func P521() Curve"],
  ["elliptic.Unmarshal", "crypto/elliptic: func Unmarshal(Curve: []byte) *big.Int"],
  ["elliptic.CurveParams.Add", "crypto/elliptic: method (*CurveParams) Add(*big.Int) (*big.Int: *big.Int)"],
  ["elliptic.CurveParams.Double", "crypto/elliptic: method (*CurveParams) Double(*big.Int) (*big.Int: *big.Int)"],
  ["elliptic.CurveParams.IsOnCurve", "crypto/elliptic: method (*CurveParams) IsOnCurve(*big.Int) bool"],
  ["elliptic.CurveParams.Params", "crypto/elliptic: method (*CurveParams) Params() *CurveParams"],
  ["elliptic.CurveParams.ScalarBaseMult", "crypto/elliptic: method (*CurveParams) ScalarBaseMult([]byte) (*big.Int: *big.Int)"],
  ["elliptic.CurveParams.ScalarMult", "crypto/elliptic: method (*CurveParams) ScalarMult(*big.Int: []byte) (*big.Int: *big.Int)"],
  ["elliptic.Curve", "crypto/elliptic: type Curve interface { Add: Double: IsOnCurve: Params: ScalarBaseMult: ScalarMult }"],
  ["elliptic.CurveParams", "crypto/elliptic: type CurveParams struct"],
  ["hmac", "import \"crypto/hmac\""],
  ["hmac.New", "crypto/hmac: func New(func() hash.Hash: []byte) hash.Hash"],
  ["md5", "import \"crypto/md5\""],
  ["md5.BlockSize", "crypto/md5: const BlockSize ideal-int"],
  ["md5.Size", "crypto/md5: const Size ideal-int"],
  ["md5.New", "crypto/md5: func New() hash.Hash"],
  ["rand", "import \"math/rand\""],
  ["rand.Int", "math/rand: func Int() int"],
  ["rand.Prime", "crypto/rand: func Prime(io.Reader: int) (*big.Int: error)"],
  ["rand.Read", "crypto/rand: func Read([]byte) (int: error)"],
  ["rc4", "import \"crypto/rc4\""],
  ["rc4.NewCipher", "crypto/rc4: func NewCipher([]byte) (*Cipher: error)"],
  ["rc4.Cipher.Reset", "crypto/rc4: method (*Cipher) Reset()"],
  ["rc4.Cipher.XORKeyStream", "crypto/rc4: method (*Cipher) XORKeyStream([]byte)"],
  ["rc4.KeySizeError.Error", "crypto/rc4: method (KeySizeError) Error() string"],
  ["rc4.Cipher", "crypto/rc4: type Cipher struct"],
  ["rc4.KeySizeError", "crypto/rc4: type KeySizeError int"],
  ["rsa", "import \"crypto/rsa\""],
  ["rsa.DecryptOAEP", "crypto/rsa: func DecryptOAEP(hash.Hash: io.Reader: *PrivateKey: []byte: []byte) ([]byte: error)"],
  ["rsa.DecryptPKCS1v15", "crypto/rsa: func DecryptPKCS1v15(io.Reader: *PrivateKey: []byte) ([]byte: error)"],
  ["rsa.DecryptPKCS1v15SessionKey", "crypto/rsa: func DecryptPKCS1v15SessionKey(io.Reader: *PrivateKey: []byte: []byte) error"],
  ["rsa.EncryptOAEP", "crypto/rsa: func EncryptOAEP(hash.Hash: io.Reader: *PublicKey: []byte: []byte) ([]byte: error)"],
  ["rsa.EncryptPKCS1v15", "crypto/rsa: func EncryptPKCS1v15(io.Reader: *PublicKey: []byte) ([]byte: error)"],
  ["rsa.GenerateKey", "crypto/rsa: func GenerateKey(io.Reader: int) (*PrivateKey: error)"],
  ["rsa.GenerateMultiPrimeKey", "crypto/rsa: func GenerateMultiPrimeKey(io.Reader: int: int) (*PrivateKey: error)"],
  ["rsa.SignPKCS1v15", "crypto/rsa: func SignPKCS1v15(io.Reader: *PrivateKey: crypto.Hash: []byte) ([]byte: error)"],
  ["rsa.VerifyPKCS1v15", "crypto/rsa: func VerifyPKCS1v15(*PublicKey: crypto.Hash: []byte: []byte) error"],
  ["rsa.PrivateKey.Precompute", "crypto/rsa: method (*PrivateKey) Precompute()"],
  ["rsa.PrivateKey.Validate", "crypto/rsa: method (*PrivateKey) Validate() error"],
  ["rsa.CRTValue", "crypto/rsa: type CRTValue struct"],
  ["rsa.PrecomputedValues", "crypto/rsa: type PrecomputedValues struct"],
  ["rsa.PrivateKey", "crypto/rsa: type PrivateKey struct"],
  ["rsa.PublicKey", "crypto/rsa: type PublicKey struct"],
  ["sha1", "import \"crypto/sha1\""],
  ["sha1.BlockSize", "crypto/sha1: const BlockSize ideal-int"],
  ["sha1.Size", "crypto/sha1: const Size ideal-int"],
  ["sha1.New", "crypto/sha1: func New() hash.Hash"],
  ["sha256", "import \"crypto/sha256\""],
  ["sha256.BlockSize", "crypto/sha256: const BlockSize ideal-int"],
  ["sha256.Size", "crypto/sha256: const Size ideal-int"],
  ["sha256.Size224", "crypto/sha256: const Size224 ideal-int"],
  ["sha256.New", "crypto/sha256: func New() hash.Hash"],
  ["sha256.New224", "crypto/sha256: func New224() hash.Hash"],
  ["sha512", "import \"crypto/sha512\""],
  ["sha512.BlockSize", "crypto/sha512: const BlockSize ideal-int"],
  ["sha512.Size", "crypto/sha512: const Size ideal-int"],
  ["sha512.Size384", "crypto/sha512: const Size384 ideal-int"],
  ["sha512.New", "crypto/sha512: func New() hash.Hash"],
  ["sha512.New384", "crypto/sha512: func New384() hash.Hash"],
  ["subtle", "import \"crypto/subtle\""],
  ["subtle.ConstantTimeByteEq", "crypto/subtle: func ConstantTimeByteEq(uint8) int"],
  ["subtle.ConstantTimeCompare", "crypto/subtle: func ConstantTimeCompare([]byte) int"],
  ["subtle.ConstantTimeCopy", "crypto/subtle: func ConstantTimeCopy(int: []byte)"],
  ["subtle.ConstantTimeEq", "crypto/subtle: func ConstantTimeEq(int32) int"],
  ["subtle.ConstantTimeSelect", "crypto/subtle: func ConstantTimeSelect(int) int"],
  ["tls", "import \"crypto/tls\""],
  ["tls.NoClientCert", "crypto/tls: const NoClientCert ClientAuthType"],
  ["tls.RequestClientCert", "crypto/tls: const RequestClientCert ClientAuthType"],
  ["tls.RequireAndVerifyClientCert", "crypto/tls: const RequireAndVerifyClientCert ClientAuthType"],
  ["tls.RequireAnyClientCert", "crypto/tls: const RequireAnyClientCert ClientAuthType"],
  ["tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", "crypto/tls: const TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA uint16"],
  ["tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", "crypto/tls: const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA uint16"],
  ["tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA", "crypto/tls: const TLS_ECDHE_RSA_WITH_RC4_128_SHA uint16"],
  ["tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA", "crypto/tls: const TLS_RSA_WITH_3DES_EDE_CBC_SHA uint16"],
  ["tls.TLS_RSA_WITH_AES_128_CBC_SHA", "crypto/tls: const TLS_RSA_WITH_AES_128_CBC_SHA uint16"],
  ["tls.TLS_RSA_WITH_RC4_128_SHA", "crypto/tls: const TLS_RSA_WITH_RC4_128_SHA uint16"],
  ["tls.VerifyClientCertIfGiven", "crypto/tls: const VerifyClientCertIfGiven ClientAuthType"],
  ["tls.Client", "crypto/tls: func Client(net.Conn: *Config) *Conn"],
  ["tls.Dial", "crypto/tls: func Dial(string: *Config) (*Conn: error)"],
  ["tls.Listen", "crypto/tls: func Listen(string: *Config) (net.Listener: error)"],
  ["tls.LoadX509KeyPair", "crypto/tls: func LoadX509KeyPair(string) (Certificate: error)"],
  ["tls.NewListener", "crypto/tls: func NewListener(net.Listener: *Config) net.Listener"],
  ["tls.Server", "crypto/tls: func Server(net.Conn: *Config) *Conn"],
  ["tls.X509KeyPair", "crypto/tls: func X509KeyPair([]byte) (Certificate: error)"],
  ["tls.Config.BuildNameToCertificate", "crypto/tls: method (*Config) BuildNameToCertificate()"],
  ["tls.Conn.Close", "crypto/tls: method (*Conn) Close() error"],
  ["tls.Conn.ConnectionState", "crypto/tls: method (*Conn) ConnectionState() ConnectionState"],
  ["tls.Conn.Handshake", "crypto/tls: method (*Conn) Handshake() error"],
  ["tls.Conn.LocalAddr", "crypto/tls: method (*Conn) LocalAddr() net.Addr"],
  ["tls.Conn.OCSPResponse", "crypto/tls: method (*Conn) OCSPResponse() []byte"],
  ["tls.Conn.Read", "crypto/tls: method (*Conn) Read([]byte) (int: error)"],
  ["tls.Conn.RemoteAddr", "crypto/tls: method (*Conn) RemoteAddr() net.Addr"],
  ["tls.Conn.SetDeadline", "crypto/tls: method (*Conn) SetDeadline(time.Time) error"],
  ["tls.Conn.SetReadDeadline", "crypto/tls: method (*Conn) SetReadDeadline(time.Time) error"],
  ["tls.Conn.SetWriteDeadline", "crypto/tls: method (*Conn) SetWriteDeadline(time.Time) error"],
  ["tls.Conn.VerifyHostname", "crypto/tls: method (*Conn) VerifyHostname(string) error"],
  ["tls.Conn.Write", "crypto/tls: method (*Conn) Write([]byte) (int: error)"],
  ["tls.Certificate", "crypto/tls: type Certificate struct"],
  ["tls.ClientAuthType", "crypto/tls: type ClientAuthType int"],
  ["tls.Config", "crypto/tls: type Config struct"],
  ["tls.Conn", "crypto/tls: type Conn struct"],
  ["tls.ConnectionState", "crypto/tls: type ConnectionState struct"],
  ["x509", "import \"crypto/x509\""],
  ["x509.CANotAuthorizedForThisName", "crypto/x509: const CANotAuthorizedForThisName InvalidReason"],
  ["x509.DSA", "crypto/x509: const DSA PublicKeyAlgorithm"],
  ["x509.DSAWithSHA1", "crypto/x509: const DSAWithSHA1 SignatureAlgorithm"],
  ["x509.DSAWithSHA256", "crypto/x509: const DSAWithSHA256 SignatureAlgorithm"],
  ["x509.Expired", "crypto/x509: const Expired InvalidReason"],
  ["x509.ExtKeyUsageAny", "crypto/x509: const ExtKeyUsageAny ExtKeyUsage"],
  ["x509.ExtKeyUsageClientAuth", "crypto/x509: const ExtKeyUsageClientAuth ExtKeyUsage"],
  ["x509.ExtKeyUsageCodeSigning", "crypto/x509: const ExtKeyUsageCodeSigning ExtKeyUsage"],
  ["x509.ExtKeyUsageEmailProtection", "crypto/x509: const ExtKeyUsageEmailProtection ExtKeyUsage"],
  ["x509.ExtKeyUsageOCSPSigning", "crypto/x509: const ExtKeyUsageOCSPSigning ExtKeyUsage"],
  ["x509.ExtKeyUsageServerAuth", "crypto/x509: const ExtKeyUsageServerAuth ExtKeyUsage"],
  ["x509.ExtKeyUsageTimeStamping", "crypto/x509: const ExtKeyUsageTimeStamping ExtKeyUsage"],
  ["x509.KeyUsageCRLSign", "crypto/x509: const KeyUsageCRLSign KeyUsage"],
  ["x509.KeyUsageCertSign", "crypto/x509: const KeyUsageCertSign KeyUsage"],
  ["x509.KeyUsageContentCommitment", "crypto/x509: const KeyUsageContentCommitment KeyUsage"],
  ["x509.KeyUsageDataEncipherment", "crypto/x509: const KeyUsageDataEncipherment KeyUsage"],
  ["x509.KeyUsageDecipherOnly", "crypto/x509: const KeyUsageDecipherOnly KeyUsage"],
  ["x509.KeyUsageDigitalSignature", "crypto/x509: const KeyUsageDigitalSignature KeyUsage"],
  ["x509.KeyUsageEncipherOnly", "crypto/x509: const KeyUsageEncipherOnly KeyUsage"],
  ["x509.KeyUsageKeyAgreement", "crypto/x509: const KeyUsageKeyAgreement KeyUsage"],
  ["x509.KeyUsageKeyEncipherment", "crypto/x509: const KeyUsageKeyEncipherment KeyUsage"],
  ["x509.MD2WithRSA", "crypto/x509: const MD2WithRSA SignatureAlgorithm"],
  ["x509.MD5WithRSA", "crypto/x509: const MD5WithRSA SignatureAlgorithm"],
  ["x509.NotAuthorizedToSign", "crypto/x509: const NotAuthorizedToSign InvalidReason"],
  ["x509.RSA", "crypto/x509: const RSA PublicKeyAlgorithm"],
  ["x509.SHA1WithRSA", "crypto/x509: const SHA1WithRSA SignatureAlgorithm"],
  ["x509.SHA256WithRSA", "crypto/x509: const SHA256WithRSA SignatureAlgorithm"],
  ["x509.SHA384WithRSA", "crypto/x509: const SHA384WithRSA SignatureAlgorithm"],
  ["x509.SHA512WithRSA", "crypto/x509: const SHA512WithRSA SignatureAlgorithm"],
  ["x509.TooManyIntermediates", "crypto/x509: const TooManyIntermediates InvalidReason"],
  ["x509.UnknownPublicKeyAlgorithm", "crypto/x509: const UnknownPublicKeyAlgorithm PublicKeyAlgorithm"],
  ["x509.UnknownSignatureAlgorithm", "crypto/x509: const UnknownSignatureAlgorithm SignatureAlgorithm"],
  ["x509.CreateCertificate", "crypto/x509: func CreateCertificate(io.Reader: *Certificate: interface{}: interface{}) ([]byte: error)"],
  ["x509.MarshalPKCS1PrivateKey", "crypto/x509: func MarshalPKCS1PrivateKey(*rsa.PrivateKey) []byte"],
  ["x509.MarshalPKIXPublicKey", "crypto/x509: func MarshalPKIXPublicKey(interface{}) ([]byte: error)"],
  ["x509.NewCertPool", "crypto/x509: func NewCertPool() *CertPool"],
  ["x509.ParseCRL", "crypto/x509: func ParseCRL([]byte) (*pkix.CertificateList: error)"],
  ["x509.ParseCertificate", "crypto/x509: func ParseCertificate([]byte) (*Certificate: error)"],
  ["x509.ParseCertificates", "crypto/x509: func ParseCertificates([]byte) ([]*Certificate: error)"],
  ["x509.ParseDERCRL", "crypto/x509: func ParseDERCRL([]byte) (*pkix.CertificateList: error)"],
  ["x509.ParsePKCS1PrivateKey", "crypto/x509: func ParsePKCS1PrivateKey([]byte) (*rsa.PrivateKey: error)"],
  ["x509.ParsePKCS8PrivateKey", "crypto/x509: func ParsePKCS8PrivateKey([]byte) (interface{}: error)"],
  ["x509.ParsePKIXPublicKey", "crypto/x509: func ParsePKIXPublicKey([]byte) (interface{}: error)"],
  ["x509.CertPool.AddCert", "crypto/x509: method (*CertPool) AddCert(*Certificate)"],
  ["x509.CertPool.AppendCertsFromPEM", "crypto/x509: method (*CertPool) AppendCertsFromPEM([]byte) bool"],
  ["x509.CertPool.Subjects", "crypto/x509: method (*CertPool) Subjects() [][]byte"],
  ["x509.Certificate.CheckCRLSignature", "crypto/x509: method (*Certificate) CheckCRLSignature(*pkix.CertificateList) error"],
  ["x509.Certificate.CheckSignature", "crypto/x509: method (*Certificate) CheckSignature(SignatureAlgorithm: []byte) error"],
  ["x509.Certificate.CheckSignatureFrom", "crypto/x509: method (*Certificate) CheckSignatureFrom(*Certificate) error"],
  ["x509.Certificate.CreateCRL", "crypto/x509: method (*Certificate) CreateCRL(io.Reader: interface{}: []pkix.RevokedCertificate: time.Time) ([]byte: error)"],
  ["x509.Certificate.Equal", "crypto/x509: method (*Certificate) Equal(*Certificate) bool"],
  ["x509.Certificate.Verify", "crypto/x509: method (*Certificate) Verify(VerifyOptions) ([][]*Certificate: error)"],
  ["x509.Certificate.VerifyHostname", "crypto/x509: method (*Certificate) VerifyHostname(string) error"],
  ["x509.CertificateInvalidError.Error", "crypto/x509: method (CertificateInvalidError) Error() string"],
  ["x509.ConstraintViolationError.Error", "crypto/x509: method (ConstraintViolationError) Error() string"],
  ["x509.HostnameError.Error", "crypto/x509: method (HostnameError) Error() string"],
  ["x509.UnhandledCriticalExtension.Error", "crypto/x509: method (UnhandledCriticalExtension) Error() string"],
  ["x509.UnknownAuthorityError.Error", "crypto/x509: method (UnknownAuthorityError) Error() string"],
  ["x509.CertPool", "crypto/x509: type CertPool struct"],
  ["x509.Certificate", "crypto/x509: type Certificate struct"],
  ["x509.CertificateInvalidError", "crypto/x509: type CertificateInvalidError struct"],
  ["x509.ConstraintViolationError", "crypto/x509: type ConstraintViolationError struct"],
  ["x509.ExtKeyUsage", "crypto/x509: type ExtKeyUsage int"],
  ["x509.HostnameError", "crypto/x509: type HostnameError struct"],
  ["x509.InvalidReason", "crypto/x509: type InvalidReason int"],
  ["x509.KeyUsage", "crypto/x509: type KeyUsage int"],
  ["x509.PublicKeyAlgorithm", "crypto/x509: type PublicKeyAlgorithm int"],
  ["x509.SignatureAlgorithm", "crypto/x509: type SignatureAlgorithm int"],
  ["x509.UnhandledCriticalExtension", "crypto/x509: type UnhandledCriticalExtension struct"],
  ["x509.UnknownAuthorityError", "crypto/x509: type UnknownAuthorityError struct"],
  ["x509.VerifyOptions", "crypto/x509: type VerifyOptions struct"],
  ["pkix", "import \"crypto/x509/pkix\""],
  ["pkix.CertificateList.HasExpired", "crypto/x509/pkix: method (*CertificateList) HasExpired(time.Time) bool"],
  ["pkix.Name.FillFromRDNSequence", "crypto/x509/pkix: method (*Name) FillFromRDNSequence(*RDNSequence)"],
  ["pkix.Name.ToRDNSequence", "crypto/x509/pkix: method (Name) ToRDNSequence() RDNSequence"],
  ["pkix.AlgorithmIdentifier", "crypto/x509/pkix: type AlgorithmIdentifier struct"],
  ["pkix.AttributeTypeAndValue", "crypto/x509/pkix: type AttributeTypeAndValue struct"],
  ["pkix.CertificateList", "crypto/x509/pkix: type CertificateList struct"],
  ["pkix.Extension", "crypto/x509/pkix: type Extension struct"],
  ["pkix.Name", "crypto/x509/pkix: type Name struct"],
  ["pkix.RDNSequence []RelativeDistinguishedNameSET", "crypto/x509/pkix: type RDNSequence []RelativeDistinguishedNameSET"],
  ["pkix.RelativeDistinguishedNameSET []AttributeTypeAndValue", "crypto/x509/pkix: type RelativeDistinguishedNameSET []AttributeTypeAndValue"],
  ["pkix.RevokedCertificate", "crypto/x509/pkix: type RevokedCertificate struct"],
  ["pkix.TBSCertificateList", "crypto/x509/pkix: type TBSCertificateList struct"],
  ["sql", "import \"database/sql\""],
  ["sql.Open", "database/sql: func Open(string) (*DB: error)"],
  ["sql.Register", "database/sql: func Register(string: driver.Driver)"],
  ["sql.DB.Begin", "database/sql: method (*DB) Begin() (*Tx: error)"],
  ["sql.DB.Close", "database/sql: method (*DB) Close() error"],
  ["sql.DB.Driver", "database/sql: method (*DB) Driver() driver.Driver"],
  ["sql.DB.Exec", "database/sql: method (*DB) Exec(string: ...interface{}) (Result: error)"],
  ["sql.DB.Prepare", "database/sql: method (*DB) Prepare(string) (*Stmt: error)"],
  ["sql.DB.Query", "database/sql: method (*DB) Query(string: ...interface{}) (*Rows: error)"],
  ["sql.DB.QueryRow", "database/sql: method (*DB) QueryRow(string: ...interface{}) *Row"],
  ["sql.NullBool.Scan", "database/sql: method (*NullBool) Scan(interface{}) error"],
  ["sql.NullFloat64.Scan", "database/sql: method (*NullFloat64) Scan(interface{}) error"],
  ["sql.NullInt64.Scan", "database/sql: method (*NullInt64) Scan(interface{}) error"],
  ["sql.NullString.Scan", "database/sql: method (*NullString) Scan(interface{}) error"],
  ["sql.Row.Scan", "database/sql: method (*Row) Scan(...interface{}) error"],
  ["sql.Rows.Close", "database/sql: method (*Rows) Close() error"],
  ["sql.Rows.Columns", "database/sql: method (*Rows) Columns() ([]string: error)"],
  ["sql.Rows.Err", "database/sql: method (*Rows) Err() error"],
  ["sql.Rows.Next", "database/sql: method (*Rows) Next() bool"],
  ["sql.Rows.Scan", "database/sql: method (*Rows) Scan(...interface{}) error"],
  ["sql.Stmt.Close", "database/sql: method (*Stmt) Close() error"],
  ["sql.Stmt.Exec", "database/sql: method (*Stmt) Exec(...interface{}) (Result: error)"],
  ["sql.Stmt.Query", "database/sql: method (*Stmt) Query(...interface{}) (*Rows: error)"],
  ["sql.Stmt.QueryRow", "database/sql: method (*Stmt) QueryRow(...interface{}) *Row"],
  ["sql.Tx.Commit", "database/sql: method (*Tx) Commit() error"],
  ["sql.Tx.Exec", "database/sql: method (*Tx) Exec(string: ...interface{}) (Result: error)"],
  ["sql.Tx.Prepare", "database/sql: method (*Tx) Prepare(string) (*Stmt: error)"],
  ["sql.Tx.Query", "database/sql: method (*Tx) Query(string: ...interface{}) (*Rows: error)"],
  ["sql.Tx.QueryRow", "database/sql: method (*Tx) QueryRow(string: ...interface{}) *Row"],
  ["sql.Tx.Rollback", "database/sql: method (*Tx) Rollback() error"],
  ["sql.Tx.Stmt", "database/sql: method (*Tx) Stmt(*Stmt) *Stmt"],
  ["sql.NullBool.Value", "database/sql: method (NullBool) Value() (driver.Value: error)"],
  ["sql.NullFloat64.Value", "database/sql: method (NullFloat64) Value() (driver.Value: error)"],
  ["sql.NullInt64.Value", "database/sql: method (NullInt64) Value() (driver.Value: error)"],
  ["sql.NullString.Value", "database/sql: method (NullString) Value() (driver.Value: error)"],
  ["sql.DB", "database/sql: type DB struct"],
  ["sql.NullBool", "database/sql: type NullBool struct"],
  ["sql.NullFloat64", "database/sql: type NullFloat64 struct"],
  ["sql.NullInt64", "database/sql: type NullInt64 struct"],
  ["sql.NullString", "database/sql: type NullString struct"],
  ["sql.RawBytes []byte", "database/sql: type RawBytes []byte"],
  ["sql.Result", "database/sql: type Result interface { LastInsertId: RowsAffected }"],
  ["sql.Row", "database/sql: type Row struct"],
  ["sql.Rows", "database/sql: type Rows struct"],
  ["sql.Scanner", "database/sql: type Scanner interface { Scan }"],
  ["sql.Stmt", "database/sql: type Stmt struct"],
  ["sql.Tx", "database/sql: type Tx struct"],
  ["driver", "import \"database/sql/driver\""],
  ["driver.IsScanValue", "database/sql/driver: func IsScanValue(interface{}) bool"],
  ["driver.IsValue", "database/sql/driver: func IsValue(interface{}) bool"],
  ["driver.NotNull.ConvertValue", "database/sql/driver: method (NotNull) ConvertValue(interface{}) (Value: error)"],
  ["driver.Null.ConvertValue", "database/sql/driver: method (Null) ConvertValue(interface{}) (Value: error)"],
  ["driver.RowsAffected.LastInsertId", "database/sql/driver: method (RowsAffected) LastInsertId() (int64: error)"],
  ["driver.RowsAffected.RowsAffected", "database/sql/driver: method (RowsAffected) RowsAffected() (int64: error)"],
  ["driver.ColumnConverter", "database/sql/driver: type ColumnConverter interface { ColumnConverter }"],
  ["driver.Conn", "database/sql/driver: type Conn interface { Begin: Close: Prepare }"],
  ["driver.Driver", "database/sql/driver: type Driver interface { Open }"],
  ["driver.Execer", "database/sql/driver: type Execer interface { Exec }"],
  ["driver.NotNull", "database/sql/driver: type NotNull struct"],
  ["driver.Null", "database/sql/driver: type Null struct"],
  ["driver.Result", "database/sql/driver: type Result interface { LastInsertId: RowsAffected }"],
  ["driver.Rows", "database/sql/driver: type Rows interface { Close: Columns: Next }"],
  ["driver.RowsAffected", "database/sql/driver: type RowsAffected int64"],
  ["driver.Stmt", "database/sql/driver: type Stmt interface { Close: Exec: NumInput: Query }"],
  ["driver.Tx", "database/sql/driver: type Tx interface { Commit: Rollback }"],
  ["driver.Value", "database/sql/driver: type Value interface {}"],
  ["driver.ValueConverter", "database/sql/driver: type ValueConverter interface { ConvertValue }"],
  ["driver.Valuer", "database/sql/driver: type Valuer interface { Value }"],
  ["ascii85", "import \"encoding/ascii85\""],
  ["ascii85.Decode", "encoding/ascii85: func Decode([]byte: bool) (int: error)"],
  ["ascii85.Encode", "encoding/ascii85: func Encode([]byte) int"],
  ["ascii85.MaxEncodedLen", "encoding/ascii85: func MaxEncodedLen(int) int"],
  ["ascii85.NewDecoder", "encoding/ascii85: func NewDecoder(io.Reader) io.Reader"],
  ["ascii85.NewEncoder", "encoding/ascii85: func NewEncoder(io.Writer) io.WriteCloser"],
  ["ascii85.CorruptInputError.Error", "encoding/ascii85: method (CorruptInputError) Error() string"],
  ["ascii85.CorruptInputError", "encoding/ascii85: type CorruptInputError int64"],
  ["asn1", "import \"encoding/asn1\""],
  ["asn1.Marshal", "encoding/asn1: func Marshal(interface{}) ([]byte: error)"],
  ["asn1.Unmarshal", "encoding/asn1: func Unmarshal([]byte: interface{}) ([]byte: error)"],
  ["asn1.UnmarshalWithParams", "encoding/asn1: func UnmarshalWithParams([]byte: interface{}: string) ([]byte: error)"],
  ["asn1.BitString.At", "encoding/asn1: method (BitString) At(int) int"],
  ["asn1.BitString.RightAlign", "encoding/asn1: method (BitString) RightAlign() []byte"],
  ["asn1.ObjectIdentifier.Equal", "encoding/asn1: method (ObjectIdentifier) Equal(ObjectIdentifier) bool"],
  ["asn1.StructuralError.Error", "encoding/asn1: method (StructuralError) Error() string"],
  ["asn1.SyntaxError.Error", "encoding/asn1: method (SyntaxError) Error() string"],
  ["asn1.BitString", "encoding/asn1: type BitString struct"],
  ["asn1.Enumerated", "encoding/asn1: type Enumerated int"],
  ["asn1.Flag", "encoding/asn1: type Flag bool"],
  ["asn1.ObjectIdentifier []int", "encoding/asn1: type ObjectIdentifier []int"],
  ["asn1.RawContent []byte", "encoding/asn1: type RawContent []byte"],
  ["asn1.RawValue", "encoding/asn1: type RawValue struct"],
  ["asn1.StructuralError", "encoding/asn1: type StructuralError struct"],
  ["asn1.SyntaxError", "encoding/asn1: type SyntaxError struct"],
  ["base32", "import \"encoding/base32\""],
  ["base32.NewDecoder", "encoding/base32: func NewDecoder(*Encoding: io.Reader) io.Reader"],
  ["base32.NewEncoder", "encoding/base32: func NewEncoder(*Encoding: io.Writer) io.WriteCloser"],
  ["base32.NewEncoding", "encoding/base32: func NewEncoding(string) *Encoding"],
  ["base32.Encoding.Decode", "encoding/base32: method (*Encoding) Decode([]byte) (int: error)"],
  ["base32.Encoding.DecodeString", "encoding/base32: method (*Encoding) DecodeString(string) ([]byte: error)"],
  ["base32.Encoding.DecodedLen", "encoding/base32: method (*Encoding) DecodedLen(int) int"],
  ["base32.Encoding.Encode", "encoding/base32: method (*Encoding) Encode([]byte)"],
  ["base32.Encoding.EncodeToString", "encoding/base32: method (*Encoding) EncodeToString([]byte) string"],
  ["base32.Encoding.EncodedLen", "encoding/base32: method (*Encoding) EncodedLen(int) int"],
  ["base32.CorruptInputError.Error", "encoding/base32: method (CorruptInputError) Error() string"],
  ["base32.CorruptInputError", "encoding/base32: type CorruptInputError int64"],
  ["base32.Encoding", "encoding/base32: type Encoding struct"],
  ["base64", "import \"encoding/base64\""],
  ["base64.NewDecoder", "encoding/base64: func NewDecoder(*Encoding: io.Reader) io.Reader"],
  ["base64.NewEncoder", "encoding/base64: func NewEncoder(*Encoding: io.Writer) io.WriteCloser"],
  ["base64.NewEncoding", "encoding/base64: func NewEncoding(string) *Encoding"],
  ["base64.Encoding.Decode", "encoding/base64: method (*Encoding) Decode([]byte) (int: error)"],
  ["base64.Encoding.DecodeString", "encoding/base64: method (*Encoding) DecodeString(string) ([]byte: error)"],
  ["base64.Encoding.DecodedLen", "encoding/base64: method (*Encoding) DecodedLen(int) int"],
  ["base64.Encoding.Encode", "encoding/base64: method (*Encoding) Encode([]byte)"],
  ["base64.Encoding.EncodeToString", "encoding/base64: method (*Encoding) EncodeToString([]byte) string"],
  ["base64.Encoding.EncodedLen", "encoding/base64: method (*Encoding) EncodedLen(int) int"],
  ["base64.CorruptInputError.Error", "encoding/base64: method (CorruptInputError) Error() string"],
  ["base64.CorruptInputError", "encoding/base64: type CorruptInputError int64"],
  ["base64.Encoding", "encoding/base64: type Encoding struct"],
  ["binary", "import \"encoding/binary\""],
  ["binary.MaxVarintLen16", "encoding/binary: const MaxVarintLen16 ideal-int"],
  ["binary.MaxVarintLen32", "encoding/binary: const MaxVarintLen32 ideal-int"],
  ["binary.MaxVarintLen64", "encoding/binary: const MaxVarintLen64 ideal-int"],
  ["binary.PutUvarint", "encoding/binary: func PutUvarint([]byte: uint64) int"],
  ["binary.PutVarint", "encoding/binary: func PutVarint([]byte: int64) int"],
  ["binary.Read", "encoding/binary: func Read(io.Reader: ByteOrder: interface{}) error"],
  ["binary.ReadUvarint", "encoding/binary: func ReadUvarint(io.ByteReader) (uint64: error)"],
  ["binary.ReadVarint", "encoding/binary: func ReadVarint(io.ByteReader) (int64: error)"],
  ["binary.Size", "encoding/binary: func Size(interface{}) int"],
  ["binary.Uvarint", "encoding/binary: func Uvarint([]byte) (uint64: int)"],
  ["binary.Varint", "encoding/binary: func Varint([]byte) (int64: int)"],
  ["binary.Write", "encoding/binary: func Write(io.Writer: ByteOrder: interface{}) error"],
  ["binary.ByteOrder", "encoding/binary: type ByteOrder interface { PutUint16: PutUint32: PutUint64: String: Uint16: Uint32: Uint64 }"],
  ["csv", "import \"encoding/csv\""],
  ["csv.NewReader", "encoding/csv: func NewReader(io.Reader) *Reader"],
  ["csv.NewWriter", "encoding/csv: func NewWriter(io.Writer) *Writer"],
  ["csv.ParseError.Error", "encoding/csv: method (*ParseError) Error() string"],
  ["csv.Reader.Read", "encoding/csv: method (*Reader) Read() ([]string: error)"],
  ["csv.Reader.ReadAll", "encoding/csv: method (*Reader) ReadAll() ([][]string: error)"],
  ["csv.Writer.Flush", "encoding/csv: method (*Writer) Flush()"],
  ["csv.Writer.Write", "encoding/csv: method (*Writer) Write([]string) error"],
  ["csv.Writer.WriteAll", "encoding/csv: method (*Writer) WriteAll([][]string) error"],
  ["csv.ParseError", "encoding/csv: type ParseError struct"],
  ["csv.Reader", "encoding/csv: type Reader struct"],
  ["csv.Writer", "encoding/csv: type Writer struct"],
  ["gob", "import \"encoding/gob\""],
  ["gob.NewDecoder", "encoding/gob: func NewDecoder(io.Reader) *Decoder"],
  ["gob.NewEncoder", "encoding/gob: func NewEncoder(io.Writer) *Encoder"],
  ["gob.Register", "encoding/gob: func Register(interface{})"],
  ["gob.RegisterName", "encoding/gob: func RegisterName(string: interface{})"],
  ["gob.Decoder.Decode", "encoding/gob: method (*Decoder) Decode(interface{}) error"],
  ["gob.Decoder.DecodeValue", "encoding/gob: method (*Decoder) DecodeValue(reflect.Value) error"],
  ["gob.Encoder.Encode", "encoding/gob: method (*Encoder) Encode(interface{}) error"],
  ["gob.Encoder.EncodeValue", "encoding/gob: method (*Encoder) EncodeValue(reflect.Value) error"],
  ["gob.CommonType", "encoding/gob: type CommonType struct"],
  ["gob.Decoder", "encoding/gob: type Decoder struct"],
  ["gob.Encoder", "encoding/gob: type Encoder struct"],
  ["gob.GobDecoder", "encoding/gob: type GobDecoder interface { GobDecode }"],
  ["gob.GobEncoder", "encoding/gob: type GobEncoder interface { GobEncode }"],
  ["hex", "import \"encoding/hex\""],
  ["hex.Decode", "encoding/hex: func Decode([]byte) (int: error)"],
  ["hex.DecodeString", "encoding/hex: func DecodeString(string) ([]byte: error)"],
  ["hex.DecodedLen", "encoding/hex: func DecodedLen(int) int"],
  ["hex.Dump", "encoding/hex: func Dump([]byte) string"],
  ["hex.Dumper", "encoding/hex: func Dumper(io.Writer) io.WriteCloser"],
  ["hex.Encode", "encoding/hex: func Encode([]byte) int"],
  ["hex.EncodeToString", "encoding/hex: func EncodeToString([]byte) string"],
  ["hex.EncodedLen", "encoding/hex: func EncodedLen(int) int"],
  ["hex.InvalidByteError.Error", "encoding/hex: method (InvalidByteError) Error() string"],
  ["hex.InvalidByteError", "encoding/hex: type InvalidByteError byte"],
  ["json", "import \"encoding/json\""],
  ["json.Compact", "encoding/json: func Compact(*bytes.Buffer: []byte) error"],
  ["json.HTMLEscape", "encoding/json: func HTMLEscape(*bytes.Buffer: []byte)"],
  ["json.Indent", "encoding/json: func Indent(*bytes.Buffer: []byte: string) error"],
  ["json.Marshal", "encoding/json: func Marshal(interface{}) ([]byte: error)"],
  ["json.MarshalIndent", "encoding/json: func MarshalIndent(interface{}: string) ([]byte: error)"],
  ["json.NewDecoder", "encoding/json: func NewDecoder(io.Reader) *Decoder"],
  ["json.NewEncoder", "encoding/json: func NewEncoder(io.Writer) *Encoder"],
  ["json.Unmarshal", "encoding/json: func Unmarshal([]byte: interface{}) error"],
  ["json.Decoder.Decode", "encoding/json: method (*Decoder) Decode(interface{}) error"],
  ["json.Encoder.Encode", "encoding/json: method (*Encoder) Encode(interface{}) error"],
  ["json.InvalidUTF8Error.Error", "encoding/json: method (*InvalidUTF8Error) Error() string"],
  ["json.InvalidUnmarshalError.Error", "encoding/json: method (*InvalidUnmarshalError) Error() string"],
  ["json.MarshalerError.Error", "encoding/json: method (*MarshalerError) Error() string"],
  ["json.RawMessage.MarshalJSON", "encoding/json: method (*RawMessage) MarshalJSON() ([]byte: error)"],
  ["json.RawMessage.UnmarshalJSON", "encoding/json: method (*RawMessage) UnmarshalJSON([]byte) error"],
  ["json.SyntaxError.Error", "encoding/json: method (*SyntaxError) Error() string"],
  ["json.UnmarshalFieldError.Error", "encoding/json: method (*UnmarshalFieldError) Error() string"],
  ["json.UnmarshalTypeError.Error", "encoding/json: method (*UnmarshalTypeError) Error() string"],
  ["json.UnsupportedTypeError.Error", "encoding/json: method (*UnsupportedTypeError) Error() string"],
  ["json.UnsupportedValueError.Error", "encoding/json: method (*UnsupportedValueError) Error() string"],
  ["json.Decoder", "encoding/json: type Decoder struct"],
  ["json.Encoder", "encoding/json: type Encoder struct"],
  ["json.InvalidUTF8Error", "encoding/json: type InvalidUTF8Error struct"],
  ["json.InvalidUnmarshalError", "encoding/json: type InvalidUnmarshalError struct"],
  ["json.Marshaler", "encoding/json: type Marshaler interface { MarshalJSON }"],
  ["json.MarshalerError", "encoding/json: type MarshalerError struct"],
  ["json.RawMessage []byte", "encoding/json: type RawMessage []byte"],
  ["json.SyntaxError", "encoding/json: type SyntaxError struct"],
  ["json.UnmarshalFieldError", "encoding/json: type UnmarshalFieldError struct"],
  ["json.UnmarshalTypeError", "encoding/json: type UnmarshalTypeError struct"],
  ["json.Unmarshaler", "encoding/json: type Unmarshaler interface { UnmarshalJSON }"],
  ["json.UnsupportedTypeError", "encoding/json: type UnsupportedTypeError struct"],
  ["json.UnsupportedValueError", "encoding/json: type UnsupportedValueError struct"],
  ["pem", "import \"encoding/pem\""],
  ["pem.Decode", "encoding/pem: func Decode([]byte) (*Block: []byte)"],
  ["pem.Encode", "encoding/pem: func Encode(io.Writer: *Block) error"],
  ["pem.EncodeToMemory", "encoding/pem: func EncodeToMemory(*Block) []byte"],
  ["pem.Block", "encoding/pem: type Block struct"],
  ["xml", "import \"encoding/xml\""],
  ["xml.Header", "encoding/xml: const Header ideal-string"],
  ["xml.CopyToken", "encoding/xml: func CopyToken(Token) Token"],
  ["xml.Escape", "encoding/xml: func Escape(io.Writer: []byte)"],
  ["xml.Marshal", "encoding/xml: func Marshal(interface{}) ([]byte: error)"],
  ["xml.MarshalIndent", "encoding/xml: func MarshalIndent(interface{}: string) ([]byte: error)"],
  ["xml.NewDecoder", "encoding/xml: func NewDecoder(io.Reader) *Decoder"],
  ["xml.NewEncoder", "encoding/xml: func NewEncoder(io.Writer) *Encoder"],
  ["xml.Unmarshal", "encoding/xml: func Unmarshal([]byte: interface{}) error"],
  ["xml.Decoder.Decode", "encoding/xml: method (*Decoder) Decode(interface{}) error"],
  ["xml.Decoder.DecodeElement", "encoding/xml: method (*Decoder) DecodeElement(interface{}: *StartElement) error"],
  ["xml.Decoder.RawToken", "encoding/xml: method (*Decoder) RawToken() (Token: error)"],
  ["xml.Decoder.Skip", "encoding/xml: method (*Decoder) Skip() error"],
  ["xml.Decoder.Token", "encoding/xml: method (*Decoder) Token() (Token: error)"],
  ["xml.Encoder.Encode", "encoding/xml: method (*Encoder) Encode(interface{}) error"],
  ["xml.SyntaxError.Error", "encoding/xml: method (*SyntaxError) Error() string"],
  ["xml.TagPathError.Error", "encoding/xml: method (*TagPathError) Error() string"],
  ["xml.UnsupportedTypeError.Error", "encoding/xml: method (*UnsupportedTypeError) Error() string"],
  ["xml.CharData.Copy", "encoding/xml: method (CharData) Copy() CharData"],
  ["xml.Comment.Copy", "encoding/xml: method (Comment) Copy() Comment"],
  ["xml.Directive.Copy", "encoding/xml: method (Directive) Copy() Directive"],
  ["xml.ProcInst.Copy", "encoding/xml: method (ProcInst) Copy() ProcInst"],
  ["xml.StartElement.Copy", "encoding/xml: method (StartElement) Copy() StartElement"],
  ["xml.UnmarshalError.Error", "encoding/xml: method (UnmarshalError) Error() string"],
  ["xml.Attr", "encoding/xml: type Attr struct"],
  ["xml.CharData []byte", "encoding/xml: type CharData []byte"],
  ["xml.Comment []byte", "encoding/xml: type Comment []byte"],
  ["xml.Decoder", "encoding/xml: type Decoder struct"],
  ["xml.Directive []byte", "encoding/xml: type Directive []byte"],
  ["xml.Encoder", "encoding/xml: type Encoder struct"],
  ["xml.EndElement", "encoding/xml: type EndElement struct"],
  ["xml.Name", "encoding/xml: type Name struct"],
  ["xml.ProcInst", "encoding/xml: type ProcInst struct"],
  ["xml.StartElement", "encoding/xml: type StartElement struct"],
  ["xml.SyntaxError", "encoding/xml: type SyntaxError struct"],
  ["xml.TagPathError", "encoding/xml: type TagPathError struct"],
  ["xml.Token", "encoding/xml: type Token interface {}"],
  ["xml.UnmarshalError", "encoding/xml: type UnmarshalError string"],
  ["xml.UnsupportedTypeError", "encoding/xml: type UnsupportedTypeError struct"],
  ["errors", "import \"errors\""],
  ["errors.New", "errors: func New(string) error"],
  ["expvar", "import \"expvar\""],
  ["expvar.Do", "expvar: func Do(func(KeyValue))"],
  ["expvar.Get", "expvar: func Get(string) Var"],
  ["expvar.NewFloat", "expvar: func NewFloat(string) *Float"],
  ["expvar.NewInt", "expvar: func NewInt(string) *Int"],
  ["expvar.NewMap", "expvar: func NewMap(string) *Map"],
  ["expvar.NewString", "expvar: func NewString(string) *String"],
  ["expvar.Publish", "expvar: func Publish(string: Var)"],
  ["expvar.Float.Add", "expvar: method (*Float) Add(float64)"],
  ["expvar.Float.Set", "expvar: method (*Float) Set(float64)"],
  ["expvar.Float.String", "expvar: method (*Float) String() string"],
  ["expvar.Int.Add", "expvar: method (*Int) Add(int64)"],
  ["expvar.Int.Set", "expvar: method (*Int) Set(int64)"],
  ["expvar.Int.String", "expvar: method (*Int) String() string"],
  ["expvar.Map.Add", "expvar: method (*Map) Add(string: int64)"],
  ["expvar.Map.AddFloat", "expvar: method (*Map) AddFloat(string: float64)"],
  ["expvar.Map.Do", "expvar: method (*Map) Do(func(KeyValue))"],
  ["expvar.Map.Get", "expvar: method (*Map) Get(string) Var"],
  ["expvar.Map.Init", "expvar: method (*Map) Init() *Map"],
  ["expvar.Map.Set", "expvar: method (*Map) Set(string: Var)"],
  ["expvar.Map.String", "expvar: method (*Map) String() string"],
  ["expvar.String.Set", "expvar: method (*String) Set(string)"],
  ["expvar.String.String", "expvar: method (*String) String() string"],
  ["expvar.Func.String", "expvar: method (Func) String() string"],
  ["expvar.Float", "expvar: type Float struct"],
  ["expvar.Func func", "expvar: type Func func() interface{}"],
  ["expvar.Int", "expvar: type Int struct"],
  ["expvar.KeyValue", "expvar: type KeyValue struct"],
  ["expvar.Map", "expvar: type Map struct"],
  ["expvar.String", "expvar: type String struct"],
  ["expvar.Var", "expvar: type Var interface { String }"],
  ["flag", "import \"flag\""],
  ["flag.ContinueOnError", "flag: const ContinueOnError ErrorHandling"],
  ["flag.ExitOnError", "flag: const ExitOnError ErrorHandling"],
  ["flag.PanicOnError", "flag: const PanicOnError ErrorHandling"],
  ["flag.Arg", "flag: func Arg(int) string"],
  ["flag.Args", "flag: func Args() []string"],
  ["flag.Bool", "flag: func Bool(string: bool: string) *bool"],
  ["flag.BoolVar", "flag: func BoolVar(*bool: string: bool: string)"],
  ["flag.Duration", "flag: func Duration(string: time.Duration: string) *time.Duration"],
  ["flag.DurationVar", "flag: func DurationVar(*time.Duration: string: time.Duration: string)"],
  ["flag.Float64", "flag: func Float64(string: float64: string) *float64"],
  ["flag.Float64Var", "flag: func Float64Var(*float64: string: float64: string)"],
  ["flag.Int", "flag: func Int(string: int: string) *int"],
  ["flag.Int64", "flag: func Int64(string: int64: string) *int64"],
  ["flag.Int64Var", "flag: func Int64Var(*int64: string: int64: string)"],
  ["flag.IntVar", "flag: func IntVar(*int: string: int: string)"],
  ["flag.Lookup", "flag: func Lookup(string) *Flag"],
  ["flag.NArg", "flag: func NArg() int"],
  ["flag.NFlag", "flag: func NFlag() int"],
  ["flag.NewFlagSet", "flag: func NewFlagSet(string: ErrorHandling) *FlagSet"],
  ["flag.Parse", "flag: func Parse()"],
  ["flag.Parsed", "flag: func Parsed() bool"],
  ["flag.PrintDefaults", "flag: func PrintDefaults()"],
  ["flag.Set", "flag: func Set(string) error"],
  ["flag.String", "flag: func String(string: string: string) *string"],
  ["flag.StringVar", "flag: func StringVar(*string: string: string: string)"],
  ["flag.Uint", "flag: func Uint(string: uint: string) *uint"],
  ["flag.Uint64", "flag: func Uint64(string: uint64: string) *uint64"],
  ["flag.Uint64Var", "flag: func Uint64Var(*uint64: string: uint64: string)"],
  ["flag.UintVar", "flag: func UintVar(*uint: string: uint: string)"],
  ["flag.Var", "flag: func Var(Value: string: string)"],
  ["flag.Visit", "flag: func Visit(func(*Flag))"],
  ["flag.VisitAll", "flag: func VisitAll(func(*Flag))"],
  ["flag.FlagSet.Arg", "flag: method (*FlagSet) Arg(int) string"],
  ["flag.FlagSet.Args", "flag: method (*FlagSet) Args() []string"],
  ["flag.FlagSet.Bool", "flag: method (*FlagSet) Bool(string: bool: string) *bool"],
  ["flag.FlagSet.BoolVar", "flag: method (*FlagSet) BoolVar(*bool: string: bool: string)"],
  ["flag.FlagSet.Duration", "flag: method (*FlagSet) Duration(string: time.Duration: string) *time.Duration"],
  ["flag.FlagSet.DurationVar", "flag: method (*FlagSet) DurationVar(*time.Duration: string: time.Duration: string)"],
  ["flag.FlagSet.Float64", "flag: method (*FlagSet) Float64(string: float64: string) *float64"],
  ["flag.FlagSet.Float64Var", "flag: method (*FlagSet) Float64Var(*float64: string: float64: string)"],
  ["flag.FlagSet.Init", "flag: method (*FlagSet) Init(string: ErrorHandling)"],
  ["flag.FlagSet.Int", "flag: method (*FlagSet) Int(string: int: string) *int"],
  ["flag.FlagSet.Int64", "flag: method (*FlagSet) Int64(string: int64: string) *int64"],
  ["flag.FlagSet.Int64Var", "flag: method (*FlagSet) Int64Var(*int64: string: int64: string)"],
  ["flag.FlagSet.IntVar", "flag: method (*FlagSet) IntVar(*int: string: int: string)"],
  ["flag.FlagSet.Lookup", "flag: method (*FlagSet) Lookup(string) *Flag"],
  ["flag.FlagSet.NArg", "flag: method (*FlagSet) NArg() int"],
  ["flag.FlagSet.NFlag", "flag: method (*FlagSet) NFlag() int"],
  ["flag.FlagSet.Parse", "flag: method (*FlagSet) Parse([]string) error"],
  ["flag.FlagSet.Parsed", "flag: method (*FlagSet) Parsed() bool"],
  ["flag.FlagSet.PrintDefaults", "flag: method (*FlagSet) PrintDefaults()"],
  ["flag.FlagSet.Set", "flag: method (*FlagSet) Set(string) error"],
  ["flag.FlagSet.SetOutput", "flag: method (*FlagSet) SetOutput(io.Writer)"],
  ["flag.FlagSet.String", "flag: method (*FlagSet) String(string: string: string) *string"],
  ["flag.FlagSet.StringVar", "flag: method (*FlagSet) StringVar(*string: string: string: string)"],
  ["flag.FlagSet.Uint", "flag: method (*FlagSet) Uint(string: uint: string) *uint"],
  ["flag.FlagSet.Uint64", "flag: method (*FlagSet) Uint64(string: uint64: string) *uint64"],
  ["flag.FlagSet.Uint64Var", "flag: method (*FlagSet) Uint64Var(*uint64: string: uint64: string)"],
  ["flag.FlagSet.UintVar", "flag: method (*FlagSet) UintVar(*uint: string: uint: string)"],
  ["flag.FlagSet.Var", "flag: method (*FlagSet) Var(Value: string: string)"],
  ["flag.FlagSet.Visit", "flag: method (*FlagSet) Visit(func(*Flag))"],
  ["flag.FlagSet.VisitAll", "flag: method (*FlagSet) VisitAll(func(*Flag))"],
  ["flag.ErrorHandling", "flag: type ErrorHandling int"],
  ["flag.Flag", "flag: type Flag struct"],
  ["flag.FlagSet", "flag: type FlagSet struct"],
  ["flag.Value", "flag: type Value interface { Set: String }"],
  ["fmt", "import \"fmt\""],
  ["fmt.Errorf", "fmt: func Errorf(string: ...interface{}) error"],
  ["fmt.Fprint", "fmt: func Fprint(io.Writer: ...interface{}) (int: error)"],
  ["fmt.Fprintf", "fmt: func Fprintf(io.Writer: string: ...interface{}) (int: error)"],
  ["fmt.Fprintln", "fmt: func Fprintln(io.Writer: ...interface{}) (int: error)"],
  ["fmt.Fscan", "fmt: func Fscan(io.Reader: ...interface{}) (int: error)"],
  ["fmt.Fscanf", "fmt: func Fscanf(io.Reader: string: ...interface{}) (int: error)"],
  ["fmt.Fscanln", "fmt: func Fscanln(io.Reader: ...interface{}) (int: error)"],
  ["fmt.Print", "fmt: func Print(...interface{}) (int: error)"],
  ["fmt.Printf", "fmt: func Printf(string: ...interface{}) (int: error)"],
  ["fmt.Println", "fmt: func Println(...interface{}) (int: error)"],
  ["fmt.Scan", "fmt: func Scan(...interface{}) (int: error)"],
  ["fmt.Scanf", "fmt: func Scanf(string: ...interface{}) (int: error)"],
  ["fmt.Scanln", "fmt: func Scanln(...interface{}) (int: error)"],
  ["fmt.Sprint", "fmt: func Sprint(...interface{}) string"],
  ["fmt.Sprintf", "fmt: func Sprintf(string: ...interface{}) string"],
  ["fmt.Sprintln", "fmt: func Sprintln(...interface{}) string"],
  ["fmt.Sscan", "fmt: func Sscan(string: ...interface{}) (int: error)"],
  ["fmt.Sscanf", "fmt: func Sscanf(string: string: ...interface{}) (int: error)"],
  ["fmt.Sscanln", "fmt: func Sscanln(string: ...interface{}) (int: error)"],
  ["fmt.Formatter", "fmt: type Formatter interface { Format }"],
  ["fmt.GoStringer", "fmt: type GoStringer interface { GoString }"],
  ["fmt.ScanState", "fmt: type ScanState interface { Read: ReadRune: SkipSpace: Token: UnreadRune: Width }"],
  ["fmt.Scanner", "fmt: type Scanner interface { Scan }"],
  ["fmt.State", "fmt: type State interface { Flag: Precision: Width: Write }"],
  ["fmt.Stringer", "fmt: type Stringer interface { String }"],
  ["ast", "import \"go/ast\""],
  ["ast.Bad", "go/ast: const Bad ObjKind"],
  ["ast.Con", "go/ast: const Con ObjKind"],
  ["ast.FilterFuncDuplicates", "go/ast: const FilterFuncDuplicates MergeMode"],
  ["ast.FilterImportDuplicates", "go/ast: const FilterImportDuplicates MergeMode"],
  ["ast.FilterUnassociatedComments", "go/ast: const FilterUnassociatedComments MergeMode"],
  ["ast.Fun", "go/ast: const Fun ObjKind"],
  ["ast.Lbl", "go/ast: const Lbl ObjKind"],
  ["ast.Pkg", "go/ast: const Pkg ObjKind"],
  ["ast.RECV", "go/ast: const RECV ChanDir"],
  ["ast.SEND", "go/ast: const SEND ChanDir"],
  ["ast.Typ", "go/ast: const Typ ObjKind"],
  ["ast.Var", "go/ast: const Var ObjKind"],
  ["ast.FileExports", "go/ast: func FileExports(*File) bool"],
  ["ast.FilterDecl", "go/ast: func FilterDecl(Decl: Filter) bool"],
  ["ast.FilterFile", "go/ast: func FilterFile(*File: Filter) bool"],
  ["ast.FilterPackage", "go/ast: func FilterPackage(*Package: Filter) bool"],
  ["ast.Fprint", "go/ast: func Fprint(io.Writer: *token.FileSet: interface{}: FieldFilter) error"],
  ["ast.Inspect", "go/ast: func Inspect(Node: func(Node) bool)"],
  ["ast.IsExported", "go/ast: func IsExported(string) bool"],
  ["ast.MergePackageFiles", "go/ast: func MergePackageFiles(*Package: MergeMode) *File"],
  ["ast.NewIdent", "go/ast: func NewIdent(string) *Ident"],
  ["ast.NewObj", "go/ast: func NewObj(ObjKind: string) *Object"],
  ["ast.NewPackage", "go/ast: func NewPackage(*token.FileSet: map[string]*File: Importer: *Scope) (*Package: error)"],
  ["ast.NewScope", "go/ast: func NewScope(*Scope) *Scope"],
  ["ast.NotNilFilter", "go/ast: func NotNilFilter(string: reflect.Value) bool"],
  ["ast.PackageExports", "go/ast: func PackageExports(*Package) bool"],
  ["ast.Print", "go/ast: func Print(*token.FileSet: interface{}) error"],
  ["ast.SortImports", "go/ast: func SortImports(*token.FileSet: *File)"],
  ["ast.Walk", "go/ast: func Walk(Visitor: Node)"],
  ["ast.ArrayType.End", "go/ast: method (*ArrayType) End() token.Pos"],
  ["ast.ArrayType.Pos", "go/ast: method (*ArrayType) Pos() token.Pos"],
  ["ast.AssignStmt.End", "go/ast: method (*AssignStmt) End() token.Pos"],
  ["ast.AssignStmt.Pos", "go/ast: method (*AssignStmt) Pos() token.Pos"],
  ["ast.BadDecl.End", "go/ast: method (*BadDecl) End() token.Pos"],
  ["ast.BadDecl.Pos", "go/ast: method (*BadDecl) Pos() token.Pos"],
  ["ast.BadExpr.End", "go/ast: method (*BadExpr) End() token.Pos"],
  ["ast.BadExpr.Pos", "go/ast: method (*BadExpr) Pos() token.Pos"],
  ["ast.BadStmt.End", "go/ast: method (*BadStmt) End() token.Pos"],
  ["ast.BadStmt.Pos", "go/ast: method (*BadStmt) Pos() token.Pos"],
  ["ast.BasicLit.End", "go/ast: method (*BasicLit) End() token.Pos"],
  ["ast.BasicLit.Pos", "go/ast: method (*BasicLit) Pos() token.Pos"],
  ["ast.BinaryExpr.End", "go/ast: method (*BinaryExpr) End() token.Pos"],
  ["ast.BinaryExpr.Pos", "go/ast: method (*BinaryExpr) Pos() token.Pos"],
  ["ast.BlockStmt.End", "go/ast: method (*BlockStmt) End() token.Pos"],
  ["ast.BlockStmt.Pos", "go/ast: method (*BlockStmt) Pos() token.Pos"],
  ["ast.BranchStmt.End", "go/ast: method (*BranchStmt) End() token.Pos"],
  ["ast.BranchStmt.Pos", "go/ast: method (*BranchStmt) Pos() token.Pos"],
  ["ast.CallExpr.End", "go/ast: method (*CallExpr) End() token.Pos"],
  ["ast.CallExpr.Pos", "go/ast: method (*CallExpr) Pos() token.Pos"],
  ["ast.CaseClause.End", "go/ast: method (*CaseClause) End() token.Pos"],
  ["ast.CaseClause.Pos", "go/ast: method (*CaseClause) Pos() token.Pos"],
  ["ast.ChanType.End", "go/ast: method (*ChanType) End() token.Pos"],
  ["ast.ChanType.Pos", "go/ast: method (*ChanType) Pos() token.Pos"],
  ["ast.CommClause.End", "go/ast: method (*CommClause) End() token.Pos"],
  ["ast.CommClause.Pos", "go/ast: method (*CommClause) Pos() token.Pos"],
  ["ast.Comment.End", "go/ast: method (*Comment) End() token.Pos"],
  ["ast.Comment.Pos", "go/ast: method (*Comment) Pos() token.Pos"],
  ["ast.CommentGroup.End", "go/ast: method (*CommentGroup) End() token.Pos"],
  ["ast.CommentGroup.Pos", "go/ast: method (*CommentGroup) Pos() token.Pos"],
  ["ast.CommentGroup.Text", "go/ast: method (*CommentGroup) Text() string"],
  ["ast.CompositeLit.End", "go/ast: method (*CompositeLit) End() token.Pos"],
  ["ast.CompositeLit.Pos", "go/ast: method (*CompositeLit) Pos() token.Pos"],
  ["ast.DeclStmt.End", "go/ast: method (*DeclStmt) End() token.Pos"],
  ["ast.DeclStmt.Pos", "go/ast: method (*DeclStmt) Pos() token.Pos"],
  ["ast.DeferStmt.End", "go/ast: method (*DeferStmt) End() token.Pos"],
  ["ast.DeferStmt.Pos", "go/ast: method (*DeferStmt) Pos() token.Pos"],
  ["ast.Ellipsis.End", "go/ast: method (*Ellipsis) End() token.Pos"],
  ["ast.Ellipsis.Pos", "go/ast: method (*Ellipsis) Pos() token.Pos"],
  ["ast.EmptyStmt.End", "go/ast: method (*EmptyStmt) End() token.Pos"],
  ["ast.EmptyStmt.Pos", "go/ast: method (*EmptyStmt) Pos() token.Pos"],
  ["ast.ExprStmt.End", "go/ast: method (*ExprStmt) End() token.Pos"],
  ["ast.ExprStmt.Pos", "go/ast: method (*ExprStmt) Pos() token.Pos"],
  ["ast.Field.End", "go/ast: method (*Field) End() token.Pos"],
  ["ast.Field.Pos", "go/ast: method (*Field) Pos() token.Pos"],
  ["ast.FieldList.End", "go/ast: method (*FieldList) End() token.Pos"],
  ["ast.FieldList.NumFields", "go/ast: method (*FieldList) NumFields() int"],
  ["ast.FieldList.Pos", "go/ast: method (*FieldList) Pos() token.Pos"],
  ["ast.File.End", "go/ast: method (*File) End() token.Pos"],
  ["ast.File.Pos", "go/ast: method (*File) Pos() token.Pos"],
  ["ast.ForStmt.End", "go/ast: method (*ForStmt) End() token.Pos"],
  ["ast.ForStmt.Pos", "go/ast: method (*ForStmt) Pos() token.Pos"],
  ["ast.FuncDecl.End", "go/ast: method (*FuncDecl) End() token.Pos"],
  ["ast.FuncDecl.Pos", "go/ast: method (*FuncDecl) Pos() token.Pos"],
  ["ast.FuncLit.End", "go/ast: method (*FuncLit) End() token.Pos"],
  ["ast.FuncLit.Pos", "go/ast: method (*FuncLit) Pos() token.Pos"],
  ["ast.FuncType.End", "go/ast: method (*FuncType) End() token.Pos"],
  ["ast.FuncType.Pos", "go/ast: method (*FuncType) Pos() token.Pos"],
  ["ast.GenDecl.End", "go/ast: method (*GenDecl) End() token.Pos"],
  ["ast.GenDecl.Pos", "go/ast: method (*GenDecl) Pos() token.Pos"],
  ["ast.GoStmt.End", "go/ast: method (*GoStmt) End() token.Pos"],
  ["ast.GoStmt.Pos", "go/ast: method (*GoStmt) Pos() token.Pos"],
  ["ast.Ident.End", "go/ast: method (*Ident) End() token.Pos"],
  ["ast.Ident.IsExported", "go/ast: method (*Ident) IsExported() bool"],
  ["ast.Ident.Pos", "go/ast: method (*Ident) Pos() token.Pos"],
  ["ast.Ident.String", "go/ast: method (*Ident) String() string"],
  ["ast.IfStmt.End", "go/ast: method (*IfStmt) End() token.Pos"],
  ["ast.IfStmt.Pos", "go/ast: method (*IfStmt) Pos() token.Pos"],
  ["ast.ImportSpec.End", "go/ast: method (*ImportSpec) End() token.Pos"],
  ["ast.ImportSpec.Pos", "go/ast: method (*ImportSpec) Pos() token.Pos"],
  ["ast.IncDecStmt.End", "go/ast: method (*IncDecStmt) End() token.Pos"],
  ["ast.IncDecStmt.Pos", "go/ast: method (*IncDecStmt) Pos() token.Pos"],
  ["ast.IndexExpr.End", "go/ast: method (*IndexExpr) End() token.Pos"],
  ["ast.IndexExpr.Pos", "go/ast: method (*IndexExpr) Pos() token.Pos"],
  ["ast.InterfaceType.End", "go/ast: method (*InterfaceType) End() token.Pos"],
  ["ast.InterfaceType.Pos", "go/ast: method (*InterfaceType) Pos() token.Pos"],
  ["ast.KeyValueExpr.End", "go/ast: method (*KeyValueExpr) End() token.Pos"],
  ["ast.KeyValueExpr.Pos", "go/ast: method (*KeyValueExpr) Pos() token.Pos"],
  ["ast.LabeledStmt.End", "go/ast: method (*LabeledStmt) End() token.Pos"],
  ["ast.LabeledStmt.Pos", "go/ast: method (*LabeledStmt) Pos() token.Pos"],
  ["ast.MapType.End", "go/ast: method (*MapType) End() token.Pos"],
  ["ast.MapType.Pos", "go/ast: method (*MapType) Pos() token.Pos"],
  ["ast.Object.Pos", "go/ast: method (*Object) Pos() token.Pos"],
  ["ast.Package.End", "go/ast: method (*Package) End() token.Pos"],
  ["ast.Package.Pos", "go/ast: method (*Package) Pos() token.Pos"],
  ["ast.ParenExpr.End", "go/ast: method (*ParenExpr) End() token.Pos"],
  ["ast.ParenExpr.Pos", "go/ast: method (*ParenExpr) Pos() token.Pos"],
  ["ast.RangeStmt.End", "go/ast: method (*RangeStmt) End() token.Pos"],
  ["ast.RangeStmt.Pos", "go/ast: method (*RangeStmt) Pos() token.Pos"],
  ["ast.ReturnStmt.End", "go/ast: method (*ReturnStmt) End() token.Pos"],
  ["ast.ReturnStmt.Pos", "go/ast: method (*ReturnStmt) Pos() token.Pos"],
  ["ast.Scope.Insert", "go/ast: method (*Scope) Insert(*Object) *Object"],
  ["ast.Scope.Lookup", "go/ast: method (*Scope) Lookup(string) *Object"],
  ["ast.Scope.String", "go/ast: method (*Scope) String() string"],
  ["ast.SelectStmt.End", "go/ast: method (*SelectStmt) End() token.Pos"],
  ["ast.SelectStmt.Pos", "go/ast: method (*SelectStmt) Pos() token.Pos"],
  ["ast.SelectorExpr.End", "go/ast: method (*SelectorExpr) End() token.Pos"],
  ["ast.SelectorExpr.Pos", "go/ast: method (*SelectorExpr) Pos() token.Pos"],
  ["ast.SendStmt.End", "go/ast: method (*SendStmt) End() token.Pos"],
  ["ast.SendStmt.Pos", "go/ast: method (*SendStmt) Pos() token.Pos"],
  ["ast.SliceExpr.End", "go/ast: method (*SliceExpr) End() token.Pos"],
  ["ast.SliceExpr.Pos", "go/ast: method (*SliceExpr) Pos() token.Pos"],
  ["ast.StarExpr.End", "go/ast: method (*StarExpr) End() token.Pos"],
  ["ast.StarExpr.Pos", "go/ast: method (*StarExpr) Pos() token.Pos"],
  ["ast.StructType.End", "go/ast: method (*StructType) End() token.Pos"],
  ["ast.StructType.Pos", "go/ast: method (*StructType) Pos() token.Pos"],
  ["ast.SwitchStmt.End", "go/ast: method (*SwitchStmt) End() token.Pos"],
  ["ast.SwitchStmt.Pos", "go/ast: method (*SwitchStmt) Pos() token.Pos"],
  ["ast.TypeAssertExpr.End", "go/ast: method (*TypeAssertExpr) End() token.Pos"],
  ["ast.TypeAssertExpr.Pos", "go/ast: method (*TypeAssertExpr) Pos() token.Pos"],
  ["ast.TypeSpec.End", "go/ast: method (*TypeSpec) End() token.Pos"],
  ["ast.TypeSpec.Pos", "go/ast: method (*TypeSpec) Pos() token.Pos"],
  ["ast.TypeSwitchStmt.End", "go/ast: method (*TypeSwitchStmt) End() token.Pos"],
  ["ast.TypeSwitchStmt.Pos", "go/ast: method (*TypeSwitchStmt) Pos() token.Pos"],
  ["ast.UnaryExpr.End", "go/ast: method (*UnaryExpr) End() token.Pos"],
  ["ast.UnaryExpr.Pos", "go/ast: method (*UnaryExpr) Pos() token.Pos"],
  ["ast.ValueSpec.End", "go/ast: method (*ValueSpec) End() token.Pos"],
  ["ast.ValueSpec.Pos", "go/ast: method (*ValueSpec) Pos() token.Pos"],
  ["ast.ObjKind.String", "go/ast: method (ObjKind) String() string"],
  ["ast.ArrayType", "go/ast: type ArrayType struct"],
  ["ast.AssignStmt", "go/ast: type AssignStmt struct"],
  ["ast.BadDecl", "go/ast: type BadDecl struct"],
  ["ast.BadExpr", "go/ast: type BadExpr struct"],
  ["ast.BadStmt", "go/ast: type BadStmt struct"],
  ["ast.BasicLit", "go/ast: type BasicLit struct"],
  ["ast.BinaryExpr", "go/ast: type BinaryExpr struct"],
  ["ast.BlockStmt", "go/ast: type BlockStmt struct"],
  ["ast.BranchStmt", "go/ast: type BranchStmt struct"],
  ["ast.CallExpr", "go/ast: type CallExpr struct"],
  ["ast.CaseClause", "go/ast: type CaseClause struct"],
  ["ast.ChanDir", "go/ast: type ChanDir int"],
  ["ast.ChanType", "go/ast: type ChanType struct"],
  ["ast.CommClause", "go/ast: type CommClause struct"],
  ["ast.Comment", "go/ast: type Comment struct"],
  ["ast.CommentGroup", "go/ast: type CommentGroup struct"],
  ["ast.CompositeLit", "go/ast: type CompositeLit struct"],
  ["ast.Decl", "go/ast: type Decl interface { End: Pos }"],
  ["ast.DeclStmt", "go/ast: type DeclStmt struct"],
  ["ast.DeferStmt", "go/ast: type DeferStmt struct"],
  ["ast.Ellipsis", "go/ast: type Ellipsis struct"],
  ["ast.EmptyStmt", "go/ast: type EmptyStmt struct"],
  ["ast.Expr", "go/ast: type Expr interface { End: Pos }"],
  ["ast.ExprStmt", "go/ast: type ExprStmt struct"],
  ["ast.Field", "go/ast: type Field struct"],
  ["ast.FieldFilter func", "go/ast: type FieldFilter func(name string: value reflect.Value) bool"],
  ["ast.FieldList", "go/ast: type FieldList struct"],
  ["ast.File", "go/ast: type File struct"],
  ["ast.Filter func", "go/ast: type Filter func(string) bool"],
  ["ast.ForStmt", "go/ast: type ForStmt struct"],
  ["ast.FuncDecl", "go/ast: type FuncDecl struct"],
  ["ast.FuncLit", "go/ast: type FuncLit struct"],
  ["ast.FuncType", "go/ast: type FuncType struct"],
  ["ast.GenDecl", "go/ast: type GenDecl struct"],
  ["ast.GoStmt", "go/ast: type GoStmt struct"],
  ["ast.Ident", "go/ast: type Ident struct"],
  ["ast.IfStmt", "go/ast: type IfStmt struct"],
  ["ast.ImportSpec", "go/ast: type ImportSpec struct"],
  ["ast.Importer func", "go/ast: type Importer func(imports map[string]*Object: path string) (*Object: err error)"],
  ["ast.IncDecStmt", "go/ast: type IncDecStmt struct"],
  ["ast.IndexExpr", "go/ast: type IndexExpr struct"],
  ["ast.InterfaceType", "go/ast: type InterfaceType struct"],
  ["ast.KeyValueExpr", "go/ast: type KeyValueExpr struct"],
  ["ast.LabeledStmt", "go/ast: type LabeledStmt struct"],
  ["ast.MapType", "go/ast: type MapType struct"],
  ["ast.MergeMode", "go/ast: type MergeMode uint"],
  ["ast.Node", "go/ast: type Node interface { End: Pos }"],
  ["ast.ObjKind", "go/ast: type ObjKind int"],
  ["ast.Object", "go/ast: type Object struct"],
  ["ast.Package", "go/ast: type Package struct"],
  ["ast.ParenExpr", "go/ast: type ParenExpr struct"],
  ["ast.RangeStmt", "go/ast: type RangeStmt struct"],
  ["ast.ReturnStmt", "go/ast: type ReturnStmt struct"],
  ["ast.Scope", "go/ast: type Scope struct"],
  ["ast.SelectStmt", "go/ast: type SelectStmt struct"],
  ["ast.SelectorExpr", "go/ast: type SelectorExpr struct"],
  ["ast.SendStmt", "go/ast: type SendStmt struct"],
  ["ast.SliceExpr", "go/ast: type SliceExpr struct"],
  ["ast.Spec", "go/ast: type Spec interface { End: Pos }"],
  ["ast.StarExpr", "go/ast: type StarExpr struct"],
  ["ast.Stmt", "go/ast: type Stmt interface { End: Pos }"],
  ["ast.StructType", "go/ast: type StructType struct"],
  ["ast.SwitchStmt", "go/ast: type SwitchStmt struct"],
  ["ast.TypeAssertExpr", "go/ast: type TypeAssertExpr struct"],
  ["ast.TypeSpec", "go/ast: type TypeSpec struct"],
  ["ast.TypeSwitchStmt", "go/ast: type TypeSwitchStmt struct"],
  ["ast.UnaryExpr", "go/ast: type UnaryExpr struct"],
  ["ast.ValueSpec", "go/ast: type ValueSpec struct"],
  ["ast.Visitor", "go/ast: type Visitor interface { Visit }"],
  ["build", "import \"go/build\""],
  ["build.AllowBinary", "go/build: const AllowBinary ImportMode"],
  ["build.FindOnly", "go/build: const FindOnly ImportMode"],
  ["build.ArchChar", "go/build: func ArchChar(string) (string: error)"],
  ["build.Import", "go/build: func Import(string: ImportMode) (*Package: error)"],
  ["build.ImportDir", "go/build: func ImportDir(string: ImportMode) (*Package: error)"],
  ["build.IsLocalImport", "go/build: func IsLocalImport(string) bool"],
  ["build.Context.Import", "go/build: method (*Context) Import(string: string: ImportMode) (*Package: error)"],
  ["build.Context.ImportDir", "go/build: method (*Context) ImportDir(string: ImportMode) (*Package: error)"],
  ["build.Context.SrcDirs", "go/build: method (*Context) SrcDirs() []string"],
  ["build.NoGoError.Error", "go/build: method (*NoGoError) Error() string"],
  ["build.Package.IsCommand", "go/build: method (*Package) IsCommand() bool"],
  ["build.Context", "go/build: type Context struct"],
  ["build.ImportMode", "go/build: type ImportMode uint"],
  ["build.NoGoError", "go/build: type NoGoError struct"],
  ["build.Package", "go/build: type Package struct"],
  ["doc", "import \"go/doc\""],
  ["doc.AllDecls", "go/doc: const AllDecls Mode"],
  ["doc.AllMethods", "go/doc: const AllMethods Mode"],
  ["doc.Examples", "go/doc: func Examples(...*ast.File) []*Example"],
  ["doc.New", "go/doc: func New(*ast.Package: string: Mode) *Package"],
  ["doc.Synopsis", "go/doc: func Synopsis(string) string"],
  ["doc.ToHTML", "go/doc: func ToHTML(io.Writer: string: map[string]string)"],
  ["doc.ToText", "go/doc: func ToText(io.Writer: string: string: int)"],
  ["doc.Package.Filter", "go/doc: method (*Package) Filter(Filter)"],
  ["doc.Example", "go/doc: type Example struct"],
  ["doc.Filter func", "go/doc: type Filter func(string) bool"],
  ["doc.Func", "go/doc: type Func struct"],
  ["doc.Mode", "go/doc: type Mode int"],
  ["doc.Package", "go/doc: type Package struct"],
  ["doc.Type", "go/doc: type Type struct"],
  ["doc.Value", "go/doc: type Value struct"],
  ["parser", "import \"go/parser\""],
  ["parser.DeclarationErrors", "go/parser: const DeclarationErrors Mode"],
  ["parser.ImportsOnly", "go/parser: const ImportsOnly Mode"],
  ["parser.PackageClauseOnly", "go/parser: const PackageClauseOnly Mode"],
  ["parser.ParseComments", "go/parser: const ParseComments Mode"],
  ["parser.SpuriousErrors", "go/parser: const SpuriousErrors Mode"],
  ["parser.Trace", "go/parser: const Trace Mode"],
  ["parser.ParseDir", "go/parser: func ParseDir(*token.FileSet: string: func(os.FileInfo) bool: Mode) (map[string]*ast.Package: error)"],
  ["parser.ParseExpr", "go/parser: func ParseExpr(string) (ast.Expr: error)"],
  ["parser.ParseFile", "go/parser: func ParseFile(*token.FileSet: string: interface{}: Mode) (*ast.File: error)"],
  ["parser.Mode", "go/parser: type Mode uint"],
  ["printer", "import \"go/printer\""],
  ["printer.RawFormat", "go/printer: const RawFormat Mode"],
  ["printer.SourcePos", "go/printer: const SourcePos Mode"],
  ["printer.TabIndent", "go/printer: const TabIndent Mode"],
  ["printer.UseSpaces", "go/printer: const UseSpaces Mode"],
  ["printer.Fprint", "go/printer: func Fprint(io.Writer: *token.FileSet: interface{}) error"],
  ["printer.Config.Fprint", "go/printer: method (*Config) Fprint(io.Writer: *token.FileSet: interface{}) error"],
  ["printer.CommentedNode", "go/printer: type CommentedNode struct"],
  ["printer.Config", "go/printer: type Config struct"],
  ["printer.Mode", "go/printer: type Mode uint"],
  ["scanner", "import \"text/scanner\""],
  ["scanner.ScanComments", "text/scanner: const ScanComments ideal-int"],
  ["scanner.PrintError", "go/scanner: func PrintError(io.Writer: error)"],
  ["scanner.ErrorList.Add", "go/scanner: method (*ErrorList) Add(token.Position: string)"],
  ["scanner.ErrorList.RemoveMultiples", "go/scanner: method (*ErrorList) RemoveMultiples()"],
  ["scanner.ErrorList.Reset", "go/scanner: method (*ErrorList) Reset()"],
  ["scanner.Scanner.Init", "text/scanner: method (*Scanner) Init(io.Reader) *Scanner"],
  ["scanner.Scanner.Scan", "text/scanner: method (*Scanner) Scan() rune"],
  ["scanner.Error.Error", "go/scanner: method (Error) Error() string"],
  ["scanner.ErrorList.Err", "go/scanner: method (ErrorList) Err() error"],
  ["scanner.ErrorList.Error", "go/scanner: method (ErrorList) Error() string"],
  ["scanner.ErrorList.Len", "go/scanner: method (ErrorList) Len() int"],
  ["scanner.ErrorList.Less", "go/scanner: method (ErrorList) Less(int) bool"],
  ["scanner.ErrorList.Sort", "go/scanner: method (ErrorList) Sort()"],
  ["scanner.ErrorList.Swap", "go/scanner: method (ErrorList) Swap(int)"],
  ["scanner.Error", "go/scanner: type Error struct"],
  ["scanner.ErrorHandler func", "go/scanner: type ErrorHandler func(pos token.Position: msg string)"],
  ["scanner.ErrorList []*Error", "go/scanner: type ErrorList []*Error"],
  ["scanner.Mode", "go/scanner: type Mode uint"],
  ["scanner.Scanner", "text/scanner: type Scanner struct"],
  ["token", "import \"go/token\""],
  ["token.ADD", "go/token: const ADD Token"],
  ["token.ADD_ASSIGN", "go/token: const ADD_ASSIGN Token"],
  ["token.AND", "go/token: const AND Token"],
  ["token.AND_ASSIGN", "go/token: const AND_ASSIGN Token"],
  ["token.AND_NOT", "go/token: const AND_NOT Token"],
  ["token.AND_NOT_ASSIGN", "go/token: const AND_NOT_ASSIGN Token"],
  ["token.ARROW", "go/token: const ARROW Token"],
  ["token.ASSIGN", "go/token: const ASSIGN Token"],
  ["token.BREAK", "go/token: const BREAK Token"],
  ["token.CASE", "go/token: const CASE Token"],
  ["token.CHAN", "go/token: const CHAN Token"],
  ["token.CHAR", "go/token: const CHAR Token"],
  ["token.COLON", "go/token: const COLON Token"],
  ["token.COMMA", "go/token: const COMMA Token"],
  ["token.COMMENT", "go/token: const COMMENT Token"],
  ["token.CONST", "go/token: const CONST Token"],
  ["token.CONTINUE", "go/token: const CONTINUE Token"],
  ["token.DEC", "go/token: const DEC Token"],
  ["token.DEFAULT", "go/token: const DEFAULT Token"],
  ["token.DEFER", "go/token: const DEFER Token"],
  ["token.DEFINE", "go/token: const DEFINE Token"],
  ["token.ELLIPSIS", "go/token: const ELLIPSIS Token"],
  ["token.ELSE", "go/token: const ELSE Token"],
  ["token.EOF", "go/token: const EOF Token"],
  ["token.EQL", "go/token: const EQL Token"],
  ["token.FALLTHROUGH", "go/token: const FALLTHROUGH Token"],
  ["token.FLOAT", "go/token: const FLOAT Token"],
  ["token.FOR", "go/token: const FOR Token"],
  ["token.FUNC", "go/token: const FUNC Token"],
  ["token.GEQ", "go/token: const GEQ Token"],
  ["token.GO", "go/token: const GO Token"],
  ["token.GOTO", "go/token: const GOTO Token"],
  ["token.GTR", "go/token: const GTR Token"],
  ["token.HighestPrec", "go/token: const HighestPrec ideal-int"],
  ["token.IDENT", "go/token: const IDENT Token"],
  ["token.IF", "go/token: const IF Token"],
  ["token.ILLEGAL", "go/token: const ILLEGAL Token"],
  ["token.IMAG", "go/token: const IMAG Token"],
  ["token.IMPORT", "go/token: const IMPORT Token"],
  ["token.INC", "go/token: const INC Token"],
  ["token.INT", "go/token: const INT Token"],
  ["token.INTERFACE", "go/token: const INTERFACE Token"],
  ["token.LAND", "go/token: const LAND Token"],
  ["token.LBRACE", "go/token: const LBRACE Token"],
  ["token.LBRACK", "go/token: const LBRACK Token"],
  ["token.LEQ", "go/token: const LEQ Token"],
  ["token.LOR", "go/token: const LOR Token"],
  ["token.LPAREN", "go/token: const LPAREN Token"],
  ["token.LSS", "go/token: const LSS Token"],
  ["token.LowestPrec", "go/token: const LowestPrec ideal-int"],
  ["token.MAP", "go/token: const MAP Token"],
  ["token.MUL", "go/token: const MUL Token"],
  ["token.MUL_ASSIGN", "go/token: const MUL_ASSIGN Token"],
  ["token.NEQ", "go/token: const NEQ Token"],
  ["token.NOT", "go/token: const NOT Token"],
  ["token.NoPos", "go/token: const NoPos Pos"],
  ["token.OR", "go/token: const OR Token"],
  ["token.OR_ASSIGN", "go/token: const OR_ASSIGN Token"],
  ["token.PACKAGE", "go/token: const PACKAGE Token"],
  ["token.PERIOD", "go/token: const PERIOD Token"],
  ["token.QUO", "go/token: const QUO Token"],
  ["token.QUO_ASSIGN", "go/token: const QUO_ASSIGN Token"],
  ["token.RANGE", "go/token: const RANGE Token"],
  ["token.RBRACE", "go/token: const RBRACE Token"],
  ["token.RBRACK", "go/token: const RBRACK Token"],
  ["token.REM", "go/token: const REM Token"],
  ["token.REM_ASSIGN", "go/token: const REM_ASSIGN Token"],
  ["token.RETURN", "go/token: const RETURN Token"],
  ["token.RPAREN", "go/token: const RPAREN Token"],
  ["token.SELECT", "go/token: const SELECT Token"],
  ["token.SEMICOLON", "go/token: const SEMICOLON Token"],
  ["token.SHL", "go/token: const SHL Token"],
  ["token.SHL_ASSIGN", "go/token: const SHL_ASSIGN Token"],
  ["token.SHR", "go/token: const SHR Token"],
  ["token.SHR_ASSIGN", "go/token: const SHR_ASSIGN Token"],
  ["token.STRING", "go/token: const STRING Token"],
  ["token.STRUCT", "go/token: const STRUCT Token"],
  ["token.SUB", "go/token: const SUB Token"],
  ["token.SUB_ASSIGN", "go/token: const SUB_ASSIGN Token"],
  ["token.SWITCH", "go/token: const SWITCH Token"],
  ["token.TYPE", "go/token: const TYPE Token"],
  ["token.UnaryPrec", "go/token: const UnaryPrec ideal-int"],
  ["token.VAR", "go/token: const VAR Token"],
  ["token.XOR", "go/token: const XOR Token"],
  ["token.XOR_ASSIGN", "go/token: const XOR_ASSIGN Token"],
  ["token.Lookup", "go/token: func Lookup(string) Token"],
  ["token.NewFileSet", "go/token: func NewFileSet() *FileSet"],
  ["token.File.AddLine", "go/token: method (*File) AddLine(int)"],
  ["token.File.AddLineInfo", "go/token: method (*File) AddLineInfo(int: string: int)"],
  ["token.File.Base", "go/token: method (*File) Base() int"],
  ["token.File.Line", "go/token: method (*File) Line(Pos) int"],
  ["token.File.LineCount", "go/token: method (*File) LineCount() int"],
  ["token.File.Name", "go/token: method (*File) Name() string"],
  ["token.File.Offset", "go/token: method (*File) Offset(Pos) int"],
  ["token.File.Pos", "go/token: method (*File) Pos(int) Pos"],
  ["token.File.Position", "go/token: method (*File) Position(Pos) Position"],
  ["token.File.SetLines", "go/token: method (*File) SetLines([]int) bool"],
  ["token.File.SetLinesForContent", "go/token: method (*File) SetLinesForContent([]byte)"],
  ["token.File.Size", "go/token: method (*File) Size() int"],
  ["token.FileSet.AddFile", "go/token: method (*FileSet) AddFile(string: int) *File"],
  ["token.FileSet.Base", "go/token: method (*FileSet) Base() int"],
  ["token.FileSet.File", "go/token: method (*FileSet) File(Pos) *File"],
  ["token.FileSet.Iterate", "go/token: method (*FileSet) Iterate(func(*File) bool)"],
  ["token.FileSet.Position", "go/token: method (*FileSet) Position(Pos) Position"],
  ["token.FileSet.Read", "go/token: method (*FileSet) Read(func(interface{}) error) error"],
  ["token.FileSet.Write", "go/token: method (*FileSet) Write(func(interface{}) error) error"],
  ["token.Position.IsValid", "go/token: method (*Position) IsValid() bool"],
  ["token.Pos.IsValid", "go/token: method (Pos) IsValid() bool"],
  ["token.Position.String", "go/token: method (Position) String() string"],
  ["token.Token.IsKeyword", "go/token: method (Token) IsKeyword() bool"],
  ["token.Token.IsLiteral", "go/token: method (Token) IsLiteral() bool"],
  ["token.Token.IsOperator", "go/token: method (Token) IsOperator() bool"],
  ["token.Token.Precedence", "go/token: method (Token) Precedence() int"],
  ["token.Token.String", "go/token: method (Token) String() string"],
  ["token.File", "go/token: type File struct"],
  ["token.FileSet", "go/token: type FileSet struct"],
  ["token.Pos", "go/token: type Pos int"],
  ["token.Position", "go/token: type Position struct"],
  ["token.Token", "go/token: type Token int"],
  ["hash", "import \"hash\""],
  ["hash.Hash", "hash: type Hash interface { BlockSize: Reset: Size: Sum: Write }"],
  ["hash.Hash32", "hash: type Hash32 interface { BlockSize: Reset: Size: Sum: Sum32: Write }"],
  ["hash.Hash64", "hash: type Hash64 interface { BlockSize: Reset: Size: Sum: Sum64: Write }"],
  ["adler32", "import \"hash/adler32\""],
  ["adler32.Size", "hash/adler32: const Size ideal-int"],
  ["adler32.Checksum", "hash/adler32: func Checksum([]byte) uint32"],
  ["adler32.New", "hash/adler32: func New() hash.Hash32"],
  ["crc32", "import \"hash/crc32\""],
  ["crc32.Castagnoli", "hash/crc32: const Castagnoli ideal-int"],
  ["crc32.IEEE", "hash/crc32: const IEEE ideal-int"],
  ["crc32.Koopman", "hash/crc32: const Koopman ideal-int"],
  ["crc32.Size", "hash/crc32: const Size ideal-int"],
  ["crc32.Checksum", "hash/crc32: func Checksum([]byte: *Table) uint32"],
  ["crc32.ChecksumIEEE", "hash/crc32: func ChecksumIEEE([]byte) uint32"],
  ["crc32.MakeTable", "hash/crc32: func MakeTable(uint32) *Table"],
  ["crc32.New", "hash/crc32: func New(*Table) hash.Hash32"],
  ["crc32.NewIEEE", "hash/crc32: func NewIEEE() hash.Hash32"],
  ["crc32.Update", "hash/crc32: func Update(uint32: *Table: []byte) uint32"],
  ["crc32.Table [256]uint32", "hash/crc32: type Table [256]uint32"],
  ["crc64", "import \"hash/crc64\""],
  ["crc64.ECMA", "hash/crc64: const ECMA ideal-int"],
  ["crc64.ISO", "hash/crc64: const ISO ideal-int"],
  ["crc64.Size", "hash/crc64: const Size ideal-int"],
  ["crc64.Checksum", "hash/crc64: func Checksum([]byte: *Table) uint64"],
  ["crc64.MakeTable", "hash/crc64: func MakeTable(uint64) *Table"],
  ["crc64.New", "hash/crc64: func New(*Table) hash.Hash64"],
  ["crc64.Update", "hash/crc64: func Update(uint64: *Table: []byte) uint64"],
  ["crc64.Table [256]uint64", "hash/crc64: type Table [256]uint64"],
  ["fnv", "import \"hash/fnv\""],
  ["fnv.New32", "hash/fnv: func New32() hash.Hash32"],
  ["fnv.New32a", "hash/fnv: func New32a() hash.Hash32"],
  ["fnv.New64", "hash/fnv: func New64() hash.Hash64"],
  ["fnv.New64a", "hash/fnv: func New64a() hash.Hash64"],
  ["html", "import \"html\""],
  ["html.EscapeString", "html: func EscapeString(string) string"],
  ["html.UnescapeString", "html: func UnescapeString(string) string"],
  ["template", "import \"html/template\""],
  ["template.ErrAmbigContext", "html/template: const ErrAmbigContext ErrorCode"],
  ["template.ErrBadHTML", "html/template: const ErrBadHTML ErrorCode"],
  ["template.ErrBranchEnd", "html/template: const ErrBranchEnd ErrorCode"],
  ["template.ErrEndContext", "html/template: const ErrEndContext ErrorCode"],
  ["template.ErrNoSuchTemplate", "html/template: const ErrNoSuchTemplate ErrorCode"],
  ["template.ErrOutputContext", "html/template: const ErrOutputContext ErrorCode"],
  ["template.ErrPartialCharset", "html/template: const ErrPartialCharset ErrorCode"],
  ["template.ErrPartialEscape", "html/template: const ErrPartialEscape ErrorCode"],
  ["template.ErrRangeLoopReentry", "html/template: const ErrRangeLoopReentry ErrorCode"],
  ["template.ErrSlashAmbig", "html/template: const ErrSlashAmbig ErrorCode"],
  ["template.OK", "html/template: const OK ErrorCode"],
  ["template.HTMLEscape", "text/template: func HTMLEscape(io.Writer: []byte)"],
  ["template.HTMLEscapeString", "text/template: func HTMLEscapeString(string) string"],
  ["template.HTMLEscaper", "text/template: func HTMLEscaper(...interface{}) string"],
  ["template.JSEscape", "text/template: func JSEscape(io.Writer: []byte)"],
  ["template.JSEscapeString", "text/template: func JSEscapeString(string) string"],
  ["template.JSEscaper", "text/template: func JSEscaper(...interface{}) string"],
  ["template.Must", "text/template: func Must(*Template: error) *Template"],
  ["template.New", "text/template: func New(string) *Template"],
  ["template.ParseFiles", "text/template: func ParseFiles(...string) (*Template: error)"],
  ["template.ParseGlob", "text/template: func ParseGlob(string) (*Template: error)"],
  ["template.URLQueryEscaper", "text/template: func URLQueryEscaper(...interface{}) string"],
  ["template.Error.Error", "html/template: method (*Error) Error() string"],
  ["template.Template.AddParseTree", "text/template: method (*Template) AddParseTree(string: *parse.Tree) (*Template: error)"],
  ["template.Template.Clone", "text/template: method (*Template) Clone() (*Template: error)"],
  ["template.Template.Delims", "text/template: method (*Template) Delims(string) *Template"],
  ["template.Template.Execute", "text/template: method (*Template) Execute(io.Writer: interface{}) error"],
  ["template.Template.ExecuteTemplate", "text/template: method (*Template) ExecuteTemplate(io.Writer: string: interface{}) error"],
  ["template.Template.Funcs", "text/template: method (*Template) Funcs(FuncMap) *Template"],
  ["template.Template.Lookup", "text/template: method (*Template) Lookup(string) *Template"],
  ["template.Template.Name", "text/template: method (*Template) Name() string"],
  ["template.Template.New", "text/template: method (*Template) New(string) *Template"],
  ["template.Template.Parse", "text/template: method (*Template) Parse(string) (*Template: error)"],
  ["template.Template.ParseFiles", "text/template: method (*Template) ParseFiles(...string) (*Template: error)"],
  ["template.Template.ParseGlob", "text/template: method (*Template) ParseGlob(string) (*Template: error)"],
  ["template.Template.Templates", "text/template: method (*Template) Templates() []*Template"],
  ["template.CSS", "html/template: type CSS string"],
  ["template.Error", "html/template: type Error struct"],
  ["template.ErrorCode", "html/template: type ErrorCode int"],
  ["template.FuncMap map[string]interface{}", "text/template: type FuncMap map[string]interface{}"],
  ["template.HTML", "html/template: type HTML string"],
  ["template.HTMLAttr", "html/template: type HTMLAttr string"],
  ["template.JS", "html/template: type JS string"],
  ["template.JSStr", "html/template: type JSStr string"],
  ["template.Template", "text/template: type Template struct"],
  ["template.URL", "html/template: type URL string"],
  ["image", "import \"image\""],
  ["image.YCbCrSubsampleRatio420", "image: const YCbCrSubsampleRatio420 YCbCrSubsampleRatio"],
  ["image.YCbCrSubsampleRatio422", "image: const YCbCrSubsampleRatio422 YCbCrSubsampleRatio"],
  ["image.YCbCrSubsampleRatio444", "image: const YCbCrSubsampleRatio444 YCbCrSubsampleRatio"],
  ["image.Decode", "image: func Decode(io.Reader) (Image: string: error)"],
  ["image.DecodeConfig", "image: func DecodeConfig(io.Reader) (Config: string: error)"],
  ["image.NewAlpha", "image: func NewAlpha(Rectangle) *Alpha"],
  ["image.NewAlpha16", "image: func NewAlpha16(Rectangle) *Alpha16"],
  ["image.NewGray", "image: func NewGray(Rectangle) *Gray"],
  ["image.NewGray16", "image: func NewGray16(Rectangle) *Gray16"],
  ["image.NewNRGBA", "image: func NewNRGBA(Rectangle) *NRGBA"],
  ["image.NewNRGBA64", "image: func NewNRGBA64(Rectangle) *NRGBA64"],
  ["image.NewPaletted", "image: func NewPaletted(Rectangle: color.Palette) *Paletted"],
  ["image.NewRGBA", "image: func NewRGBA(Rectangle) *RGBA"],
  ["image.NewRGBA64", "image: func NewRGBA64(Rectangle) *RGBA64"],
  ["image.NewUniform", "image: func NewUniform(color.Color) *Uniform"],
  ["image.NewYCbCr", "image: func NewYCbCr(Rectangle: YCbCrSubsampleRatio) *YCbCr"],
  ["image.Pt", "image: func Pt(int) Point"],
  ["image.Rect", "image: func Rect(int) Rectangle"],
  ["image.RegisterFormat", "image: func RegisterFormat(string: func(io.Reader) (Image: error): func(io.Reader) (Config: error))"],
  ["image.Alpha.At", "image: method (*Alpha) At(int) color.Color"],
  ["image.Alpha.Bounds", "image: method (*Alpha) Bounds() Rectangle"],
  ["image.Alpha.ColorModel", "image: method (*Alpha) ColorModel() color.Model"],
  ["image.Alpha.Opaque", "image: method (*Alpha) Opaque() bool"],
  ["image.Alpha.PixOffset", "image: method (*Alpha) PixOffset(int) int"],
  ["image.Alpha.Set", "image: method (*Alpha) Set(int: color.Color)"],
  ["image.Alpha.SetAlpha", "image: method (*Alpha) SetAlpha(int: color.Alpha)"],
  ["image.Alpha.SubImage", "image: method (*Alpha) SubImage(Rectangle) Image"],
  ["image.Alpha16.At", "image: method (*Alpha16) At(int) color.Color"],
  ["image.Alpha16.Bounds", "image: method (*Alpha16) Bounds() Rectangle"],
  ["image.Alpha16.ColorModel", "image: method (*Alpha16) ColorModel() color.Model"],
  ["image.Alpha16.Opaque", "image: method (*Alpha16) Opaque() bool"],
  ["image.Alpha16.PixOffset", "image: method (*Alpha16) PixOffset(int) int"],
  ["image.Alpha16.Set", "image: method (*Alpha16) Set(int: color.Color)"],
  ["image.Alpha16.SetAlpha16", "image: method (*Alpha16) SetAlpha16(int: color.Alpha16)"],
  ["image.Alpha16.SubImage", "image: method (*Alpha16) SubImage(Rectangle) Image"],
  ["image.Gray.At", "image: method (*Gray) At(int) color.Color"],
  ["image.Gray.Bounds", "image: method (*Gray) Bounds() Rectangle"],
  ["image.Gray.ColorModel", "image: method (*Gray) ColorModel() color.Model"],
  ["image.Gray.Opaque", "image: method (*Gray) Opaque() bool"],
  ["image.Gray.PixOffset", "image: method (*Gray) PixOffset(int) int"],
  ["image.Gray.Set", "image: method (*Gray) Set(int: color.Color)"],
  ["image.Gray.SetGray", "image: method (*Gray) SetGray(int: color.Gray)"],
  ["image.Gray.SubImage", "image: method (*Gray) SubImage(Rectangle) Image"],
  ["image.Gray16.At", "image: method (*Gray16) At(int) color.Color"],
  ["image.Gray16.Bounds", "image: method (*Gray16) Bounds() Rectangle"],
  ["image.Gray16.ColorModel", "image: method (*Gray16) ColorModel() color.Model"],
  ["image.Gray16.Opaque", "image: method (*Gray16) Opaque() bool"],
  ["image.Gray16.PixOffset", "image: method (*Gray16) PixOffset(int) int"],
  ["image.Gray16.Set", "image: method (*Gray16) Set(int: color.Color)"],
  ["image.Gray16.SetGray16", "image: method (*Gray16) SetGray16(int: color.Gray16)"],
  ["image.Gray16.SubImage", "image: method (*Gray16) SubImage(Rectangle) Image"],
  ["image.NRGBA.At", "image: method (*NRGBA) At(int) color.Color"],
  ["image.NRGBA.Bounds", "image: method (*NRGBA) Bounds() Rectangle"],
  ["image.NRGBA.ColorModel", "image: method (*NRGBA) ColorModel() color.Model"],
  ["image.NRGBA.Opaque", "image: method (*NRGBA) Opaque() bool"],
  ["image.NRGBA.PixOffset", "image: method (*NRGBA) PixOffset(int) int"],
  ["image.NRGBA.Set", "image: method (*NRGBA) Set(int: color.Color)"],
  ["image.NRGBA.SetNRGBA", "image: method (*NRGBA) SetNRGBA(int: color.NRGBA)"],
  ["image.NRGBA.SubImage", "image: method (*NRGBA) SubImage(Rectangle) Image"],
  ["image.NRGBA64.At", "image: method (*NRGBA64) At(int) color.Color"],
  ["image.NRGBA64.Bounds", "image: method (*NRGBA64) Bounds() Rectangle"],
  ["image.NRGBA64.ColorModel", "image: method (*NRGBA64) ColorModel() color.Model"],
  ["image.NRGBA64.Opaque", "image: method (*NRGBA64) Opaque() bool"],
  ["image.NRGBA64.PixOffset", "image: method (*NRGBA64) PixOffset(int) int"],
  ["image.NRGBA64.Set", "image: method (*NRGBA64) Set(int: color.Color)"],
  ["image.NRGBA64.SetNRGBA64", "image: method (*NRGBA64) SetNRGBA64(int: color.NRGBA64)"],
  ["image.NRGBA64.SubImage", "image: method (*NRGBA64) SubImage(Rectangle) Image"],
  ["image.Paletted.At", "image: method (*Paletted) At(int) color.Color"],
  ["image.Paletted.Bounds", "image: method (*Paletted) Bounds() Rectangle"],
  ["image.Paletted.ColorIndexAt", "image: method (*Paletted) ColorIndexAt(int) uint8"],
  ["image.Paletted.ColorModel", "image: method (*Paletted) ColorModel() color.Model"],
  ["image.Paletted.Opaque", "image: method (*Paletted) Opaque() bool"],
  ["image.Paletted.PixOffset", "image: method (*Paletted) PixOffset(int) int"],
  ["image.Paletted.Set", "image: method (*Paletted) Set(int: color.Color)"],
  ["image.Paletted.SetColorIndex", "image: method (*Paletted) SetColorIndex(int: uint8)"],
  ["image.Paletted.SubImage", "image: method (*Paletted) SubImage(Rectangle) Image"],
  ["image.RGBA.At", "image: method (*RGBA) At(int) color.Color"],
  ["image.RGBA.Bounds", "image: method (*RGBA) Bounds() Rectangle"],
  ["image.RGBA.ColorModel", "image: method (*RGBA) ColorModel() color.Model"],
  ["image.RGBA.Opaque", "image: method (*RGBA) Opaque() bool"],
  ["image.RGBA.PixOffset", "image: method (*RGBA) PixOffset(int) int"],
  ["image.RGBA.Set", "image: method (*RGBA) Set(int: color.Color)"],
  ["image.RGBA.SetRGBA", "image: method (*RGBA) SetRGBA(int: color.RGBA)"],
  ["image.RGBA.SubImage", "image: method (*RGBA) SubImage(Rectangle) Image"],
  ["image.RGBA64.At", "image: method (*RGBA64) At(int) color.Color"],
  ["image.RGBA64.Bounds", "image: method (*RGBA64) Bounds() Rectangle"],
  ["image.RGBA64.ColorModel", "image: method (*RGBA64) ColorModel() color.Model"],
  ["image.RGBA64.Opaque", "image: method (*RGBA64) Opaque() bool"],
  ["image.RGBA64.PixOffset", "image: method (*RGBA64) PixOffset(int) int"],
  ["image.RGBA64.Set", "image: method (*RGBA64) Set(int: color.Color)"],
  ["image.RGBA64.SetRGBA64", "image: method (*RGBA64) SetRGBA64(int: color.RGBA64)"],
  ["image.RGBA64.SubImage", "image: method (*RGBA64) SubImage(Rectangle) Image"],
  ["image.Uniform.At", "image: method (*Uniform) At(int) color.Color"],
  ["image.Uniform.Bounds", "image: method (*Uniform) Bounds() Rectangle"],
  ["image.Uniform.ColorModel", "image: method (*Uniform) ColorModel() color.Model"],
  ["image.Uniform.Convert", "image: method (*Uniform) Convert(color.Color) color.Color"],
  ["image.Uniform.Opaque", "image: method (*Uniform) Opaque() bool"],
  ["image.Uniform.RGBA", "image: method (*Uniform) RGBA() uint32"],
  ["image.YCbCr.At", "image: method (*YCbCr) At(int) color.Color"],
  ["image.YCbCr.Bounds", "image: method (*YCbCr) Bounds() Rectangle"],
  ["image.YCbCr.COffset", "image: method (*YCbCr) COffset(int) int"],
  ["image.YCbCr.ColorModel", "image: method (*YCbCr) ColorModel() color.Model"],
  ["image.YCbCr.Opaque", "image: method (*YCbCr) Opaque() bool"],
  ["image.YCbCr.SubImage", "image: method (*YCbCr) SubImage(Rectangle) Image"],
  ["image.YCbCr.YOffset", "image: method (*YCbCr) YOffset(int) int"],
  ["image.Point.Add", "image: method (Point) Add(Point) Point"],
  ["image.Point.Div", "image: method (Point) Div(int) Point"],
  ["image.Point.Eq", "image: method (Point) Eq(Point) bool"],
  ["image.Point.In", "image: method (Point) In(Rectangle) bool"],
  ["image.Point.Mod", "image: method (Point) Mod(Rectangle) Point"],
  ["image.Point.Mul", "image: method (Point) Mul(int) Point"],
  ["image.Point.String", "image: method (Point) String() string"],
  ["image.Point.Sub", "image: method (Point) Sub(Point) Point"],
  ["image.Rectangle.Add", "image: method (Rectangle) Add(Point) Rectangle"],
  ["image.Rectangle.Canon", "image: method (Rectangle) Canon() Rectangle"],
  ["image.Rectangle.Dx", "image: method (Rectangle) Dx() int"],
  ["image.Rectangle.Dy", "image: method (Rectangle) Dy() int"],
  ["image.Rectangle.Empty", "image: method (Rectangle) Empty() bool"],
  ["image.Rectangle.Eq", "image: method (Rectangle) Eq(Rectangle) bool"],
  ["image.Rectangle.In", "image: method (Rectangle) In(Rectangle) bool"],
  ["image.Rectangle.Inset", "image: method (Rectangle) Inset(int) Rectangle"],
  ["image.Rectangle.Intersect", "image: method (Rectangle) Intersect(Rectangle) Rectangle"],
  ["image.Rectangle.Overlaps", "image: method (Rectangle) Overlaps(Rectangle) bool"],
  ["image.Rectangle.Size", "image: method (Rectangle) Size() Point"],
  ["image.Rectangle.String", "image: method (Rectangle) String() string"],
  ["image.Rectangle.Sub", "image: method (Rectangle) Sub(Point) Rectangle"],
  ["image.Rectangle.Union", "image: method (Rectangle) Union(Rectangle) Rectangle"],
  ["image.YCbCrSubsampleRatio.String", "image: method (YCbCrSubsampleRatio) String() string"],
  ["image.Alpha", "image: type Alpha struct"],
  ["image.Alpha16", "image: type Alpha16 struct"],
  ["image.Config", "image: type Config struct"],
  ["image.Gray", "image: type Gray struct"],
  ["image.Gray16", "image: type Gray16 struct"],
  ["image.Image", "image: type Image interface { At: Bounds: ColorModel }"],
  ["image.NRGBA", "image: type NRGBA struct"],
  ["image.NRGBA64", "image: type NRGBA64 struct"],
  ["image.Paletted", "image: type Paletted struct"],
  ["image.PalettedImage", "image: type PalettedImage interface { At: Bounds: ColorIndexAt: ColorModel }"],
  ["image.Point", "image: type Point struct"],
  ["image.RGBA", "image: type RGBA struct"],
  ["image.RGBA64", "image: type RGBA64 struct"],
  ["image.Rectangle", "image: type Rectangle struct"],
  ["image.Uniform", "image: type Uniform struct"],
  ["image.YCbCr", "image: type YCbCr struct"],
  ["image.YCbCrSubsampleRatio", "image: type YCbCrSubsampleRatio int"],
  ["color", "import \"image/color\""],
  ["color.ModelFunc", "image/color: func ModelFunc(func(Color) Color) Model"],
  ["color.RGBToYCbCr", "image/color: func RGBToYCbCr(uint8) (uint8: uint8: uint8)"],
  ["color.YCbCrToRGB", "image/color: func YCbCrToRGB(uint8) (uint8: uint8: uint8)"],
  ["color.Alpha.RGBA", "image/color: method (Alpha) RGBA() uint32"],
  ["color.Alpha16.RGBA", "image/color: method (Alpha16) RGBA() uint32"],
  ["color.Gray.RGBA", "image/color: method (Gray) RGBA() uint32"],
  ["color.Gray16.RGBA", "image/color: method (Gray16) RGBA() uint32"],
  ["color.NRGBA.RGBA", "image/color: method (NRGBA) RGBA() uint32"],
  ["color.NRGBA64.RGBA", "image/color: method (NRGBA64) RGBA() uint32"],
  ["color.Palette.Convert", "image/color: method (Palette) Convert(Color) Color"],
  ["color.Palette.Index", "image/color: method (Palette) Index(Color) int"],
  ["color.RGBA.RGBA", "image/color: method (RGBA) RGBA() uint32"],
  ["color.RGBA64.RGBA", "image/color: method (RGBA64) RGBA() uint32"],
  ["color.YCbCr.RGBA", "image/color: method (YCbCr) RGBA() (uint32: uint32: uint32: uint32)"],
  ["color.Alpha", "image/color: type Alpha struct"],
  ["color.Alpha16", "image/color: type Alpha16 struct"],
  ["color.Color", "image/color: type Color interface { RGBA }"],
  ["color.Gray", "image/color: type Gray struct"],
  ["color.Gray16", "image/color: type Gray16 struct"],
  ["color.Model", "image/color: type Model interface { Convert }"],
  ["color.NRGBA", "image/color: type NRGBA struct"],
  ["color.NRGBA64", "image/color: type NRGBA64 struct"],
  ["color.Palette []Color", "image/color: type Palette []Color"],
  ["color.RGBA", "image/color: type RGBA struct"],
  ["color.RGBA64", "image/color: type RGBA64 struct"],
  ["color.YCbCr", "image/color: type YCbCr struct"],
  ["draw", "import \"image/draw\""],
  ["draw.Over", "image/draw: const Over Op"],
  ["draw.Src", "image/draw: const Src Op"],
  ["draw.Draw", "image/draw: func Draw(Image: image.Rectangle: image.Image: image.Point: Op)"],
  ["draw.DrawMask", "image/draw: func DrawMask(Image: image.Rectangle: image.Image: image.Point: image.Image: image.Point: Op)"],
  ["draw.Image", "image/draw: type Image interface { At: Bounds: ColorModel: Set }"],
  ["draw.Op", "image/draw: type Op int"],
  ["gif", "import \"image/gif\""],
  ["gif.Decode", "image/gif: func Decode(io.Reader) (image.Image: error)"],
  ["gif.DecodeAll", "image/gif: func DecodeAll(io.Reader) (*GIF: error)"],
  ["gif.DecodeConfig", "image/gif: func DecodeConfig(io.Reader) (image.Config: error)"],
  ["gif.GIF", "image/gif: type GIF struct"],
  ["jpeg", "import \"image/jpeg\""],
  ["jpeg.DefaultQuality", "image/jpeg: const DefaultQuality ideal-int"],
  ["jpeg.Decode", "image/jpeg: func Decode(io.Reader) (image.Image: error)"],
  ["jpeg.DecodeConfig", "image/jpeg: func DecodeConfig(io.Reader) (image.Config: error)"],
  ["jpeg.Encode", "image/jpeg: func Encode(io.Writer: image.Image: *Options) error"],
  ["jpeg.FormatError.Error", "image/jpeg: method (FormatError) Error() string"],
  ["jpeg.UnsupportedError.Error", "image/jpeg: method (UnsupportedError) Error() string"],
  ["jpeg.FormatError", "image/jpeg: type FormatError string"],
  ["jpeg.Options", "image/jpeg: type Options struct"],
  ["jpeg.Reader", "image/jpeg: type Reader interface { Read: ReadByte }"],
  ["jpeg.UnsupportedError", "image/jpeg: type UnsupportedError string"],
  ["png", "import \"image/png\""],
  ["png.Decode", "image/png: func Decode(io.Reader) (image.Image: error)"],
  ["png.DecodeConfig", "image/png: func DecodeConfig(io.Reader) (image.Config: error)"],
  ["png.Encode", "image/png: func Encode(io.Writer: image.Image) error"],
  ["png.FormatError.Error", "image/png: method (FormatError) Error() string"],
  ["png.UnsupportedError.Error", "image/png: method (UnsupportedError) Error() string"],
  ["png.FormatError", "image/png: type FormatError string"],
  ["png.UnsupportedError", "image/png: type UnsupportedError string"],
  ["suffixarray", "import \"index/suffixarray\""],
  ["suffixarray.New", "index/suffixarray: func New([]byte) *Index"],
  ["suffixarray.Index.Bytes", "index/suffixarray: method (*Index) Bytes() []byte"],
  ["suffixarray.Index.FindAllIndex", "index/suffixarray: method (*Index) FindAllIndex(*regexp.Regexp: int) [][]int"],
  ["suffixarray.Index.Lookup", "index/suffixarray: method (*Index) Lookup([]byte: int) []int"],
  ["suffixarray.Index.Read", "index/suffixarray: method (*Index) Read(io.Reader) error"],
  ["suffixarray.Index.Write", "index/suffixarray: method (*Index) Write(io.Writer) error"],
  ["suffixarray.Index", "index/suffixarray: type Index struct"],
  ["io", "import \"io\""],
  ["io.Copy", "io: func Copy(Writer: Reader) (int64: error)"],
  ["io.CopyN", "io: func CopyN(Writer: Reader: int64) (int64: error)"],
  ["io.LimitReader", "io: func LimitReader(Reader: int64) Reader"],
  ["io.MultiReader", "io: func MultiReader(...Reader) Reader"],
  ["io.MultiWriter", "io: func MultiWriter(...Writer) Writer"],
  ["io.NewSectionReader", "io: func NewSectionReader(ReaderAt: int64: int64) *SectionReader"],
  ["io.Pipe", "io: func Pipe() (*PipeReader: *PipeWriter)"],
  ["io.ReadAtLeast", "io: func ReadAtLeast(Reader: []byte: int) (int: error)"],
  ["io.ReadFull", "io: func ReadFull(Reader: []byte) (int: error)"],
  ["io.TeeReader", "io: func TeeReader(Reader: Writer) Reader"],
  ["io.WriteString", "io: func WriteString(Writer: string) (int: error)"],
  ["io.LimitedReader.Read", "io: method (*LimitedReader) Read([]byte) (int: error)"],
  ["io.PipeReader.Close", "io: method (*PipeReader) Close() error"],
  ["io.PipeReader.CloseWithError", "io: method (*PipeReader) CloseWithError(error) error"],
  ["io.PipeReader.Read", "io: method (*PipeReader) Read([]byte) (int: error)"],
  ["io.PipeWriter.Close", "io: method (*PipeWriter) Close() error"],
  ["io.PipeWriter.CloseWithError", "io: method (*PipeWriter) CloseWithError(error) error"],
  ["io.PipeWriter.Write", "io: method (*PipeWriter) Write([]byte) (int: error)"],
  ["io.SectionReader.Read", "io: method (*SectionReader) Read([]byte) (int: error)"],
  ["io.SectionReader.ReadAt", "io: method (*SectionReader) ReadAt([]byte: int64) (int: error)"],
  ["io.SectionReader.Seek", "io: method (*SectionReader) Seek(int64: int) (int64: error)"],
  ["io.SectionReader.Size", "io: method (*SectionReader) Size() int64"],
  ["io.ByteReader", "io: type ByteReader interface { ReadByte }"],
  ["io.ByteScanner", "io: type ByteScanner interface { ReadByte: UnreadByte }"],
  ["io.Closer", "io: type Closer interface { Close }"],
  ["io.LimitedReader", "io: type LimitedReader struct"],
  ["io.PipeReader", "io: type PipeReader struct"],
  ["io.PipeWriter", "io: type PipeWriter struct"],
  ["io.ReadCloser", "io: type ReadCloser interface { Close: Read }"],
  ["io.ReadSeeker", "io: type ReadSeeker interface { Read: Seek }"],
  ["io.ReadWriteCloser", "io: type ReadWriteCloser interface { Close: Read: Write }"],
  ["io.ReadWriteSeeker", "io: type ReadWriteSeeker interface { Read: Seek: Write }"],
  ["io.ReadWriter", "io: type ReadWriter interface { Read: Write }"],
  ["io.Reader", "io: type Reader interface { Read }"],
  ["io.ReaderAt", "io: type ReaderAt interface { ReadAt }"],
  ["io.ReaderFrom", "io: type ReaderFrom interface { ReadFrom }"],
  ["io.RuneReader", "io: type RuneReader interface { ReadRune }"],
  ["io.RuneScanner", "io: type RuneScanner interface { ReadRune: UnreadRune }"],
  ["io.SectionReader", "io: type SectionReader struct"],
  ["io.Seeker", "io: type Seeker interface { Seek }"],
  ["io.WriteCloser", "io: type WriteCloser interface { Close: Write }"],
  ["io.WriteSeeker", "io: type WriteSeeker interface { Seek: Write }"],
  ["io.Writer", "io: type Writer interface { Write }"],
  ["io.WriterAt", "io: type WriterAt interface { WriteAt }"],
  ["io.WriterTo", "io: type WriterTo interface { WriteTo }"],
  ["ioutil", "import \"io/ioutil\""],
  ["ioutil.NopCloser", "io/ioutil: func NopCloser(io.Reader) io.ReadCloser"],
  ["ioutil.ReadAll", "io/ioutil: func ReadAll(io.Reader) ([]byte: error)"],
  ["ioutil.ReadDir", "io/ioutil: func ReadDir(string) ([]os.FileInfo: error)"],
  ["ioutil.ReadFile", "io/ioutil: func ReadFile(string) ([]byte: error)"],
  ["ioutil.TempDir", "io/ioutil: func TempDir(string) (string: error)"],
  ["ioutil.TempFile", "io/ioutil: func TempFile(string) (*os.File: error)"],
  ["ioutil.WriteFile", "io/ioutil: func WriteFile(string: []byte: os.FileMode) error"],
  ["log", "import \"log\""],
  ["log.Ldate", "log: const Ldate ideal-int"],
  ["log.Llongfile", "log: const Llongfile ideal-int"],
  ["log.Lmicroseconds", "log: const Lmicroseconds ideal-int"],
  ["log.Lshortfile", "log: const Lshortfile ideal-int"],
  ["log.LstdFlags", "log: const LstdFlags ideal-int"],
  ["log.Ltime", "log: const Ltime ideal-int"],
  ["log.Fatal", "log: func Fatal(...interface{})"],
  ["log.Fatalf", "log: func Fatalf(string: ...interface{})"],
  ["log.Fatalln", "log: func Fatalln(...interface{})"],
  ["log.Flags", "log: func Flags() int"],
  ["log.New", "log: func New(io.Writer: string: int) *Logger"],
  ["log.Panic", "log: func Panic(...interface{})"],
  ["log.Panicf", "log: func Panicf(string: ...interface{})"],
  ["log.Panicln", "log: func Panicln(...interface{})"],
  ["log.Prefix", "log: func Prefix() string"],
  ["log.Print", "log: func Print(...interface{})"],
  ["log.Printf", "log: func Printf(string: ...interface{})"],
  ["log.Println", "log: func Println(...interface{})"],
  ["log.SetFlags", "log: func SetFlags(int)"],
  ["log.SetOutput", "log: func SetOutput(io.Writer)"],
  ["log.SetPrefix", "log: func SetPrefix(string)"],
  ["log.Logger.Fatal", "log: method (*Logger) Fatal(...interface{})"],
  ["log.Logger.Fatalf", "log: method (*Logger) Fatalf(string: ...interface{})"],
  ["log.Logger.Fatalln", "log: method (*Logger) Fatalln(...interface{})"],
  ["log.Logger.Flags", "log: method (*Logger) Flags() int"],
  ["log.Logger.Output", "log: method (*Logger) Output(int: string) error"],
  ["log.Logger.Panic", "log: method (*Logger) Panic(...interface{})"],
  ["log.Logger.Panicf", "log: method (*Logger) Panicf(string: ...interface{})"],
  ["log.Logger.Panicln", "log: method (*Logger) Panicln(...interface{})"],
  ["log.Logger.Prefix", "log: method (*Logger) Prefix() string"],
  ["log.Logger.Print", "log: method (*Logger) Print(...interface{})"],
  ["log.Logger.Printf", "log: method (*Logger) Printf(string: ...interface{})"],
  ["log.Logger.Println", "log: method (*Logger) Println(...interface{})"],
  ["log.Logger.SetFlags", "log: method (*Logger) SetFlags(int)"],
  ["log.Logger.SetPrefix", "log: method (*Logger) SetPrefix(string)"],
  ["log.Logger", "log: type Logger struct"],
  ["syslog", "import \"log/syslog\""],
  ["syslog.LOG_ALERT", "log/syslog: const LOG_ALERT Priority"],
  ["syslog.LOG_CRIT", "log/syslog: const LOG_CRIT Priority"],
  ["syslog.LOG_DEBUG", "log/syslog: const LOG_DEBUG Priority"],
  ["syslog.LOG_EMERG", "log/syslog: const LOG_EMERG Priority"],
  ["syslog.LOG_ERR", "log/syslog: const LOG_ERR Priority"],
  ["syslog.LOG_INFO", "log/syslog: const LOG_INFO Priority"],
  ["syslog.LOG_NOTICE", "log/syslog: const LOG_NOTICE Priority"],
  ["syslog.LOG_WARNING", "log/syslog: const LOG_WARNING Priority"],
  ["syslog.Dial", "log/syslog: func Dial(string: Priority: string) (*Writer: error)"],
  ["syslog.New", "log/syslog: func New(Priority: string) (*Writer: error)"],
  ["syslog.NewLogger", "log/syslog: func NewLogger(Priority: int) (*log.Logger: error)"],
  ["syslog.Writer.Alert", "log/syslog: method (*Writer) Alert(string) error"],
  ["syslog.Writer.Close", "log/syslog: method (*Writer) Close() error"],
  ["syslog.Writer.Crit", "log/syslog: method (*Writer) Crit(string) error"],
  ["syslog.Writer.Debug", "log/syslog: method (*Writer) Debug(string) error"],
  ["syslog.Writer.Emerg", "log/syslog: method (*Writer) Emerg(string) error"],
  ["syslog.Writer.Err", "log/syslog: method (*Writer) Err(string) error"],
  ["syslog.Writer.Info", "log/syslog: method (*Writer) Info(string) error"],
  ["syslog.Writer.Notice", "log/syslog: method (*Writer) Notice(string) error"],
  ["syslog.Writer.Warning", "log/syslog: method (*Writer) Warning(string) error"],
  ["syslog.Writer.Write", "log/syslog: method (*Writer) Write([]byte) (int: error)"],
  ["syslog.Priority", "log/syslog: type Priority int"],
  ["syslog.Writer", "log/syslog: type Writer struct"],
  ["math", "import \"math\""],
  ["math.E", "math: const E ideal-float"],
  ["math.Ln10", "math: const Ln10 ideal-float"],
  ["math.Ln2", "math: const Ln2 ideal-float"],
  ["math.Log10E", "math: const Log10E ideal-float"],
  ["math.Log2E", "math: const Log2E ideal-float"],
  ["math.MaxFloat32", "math: const MaxFloat32 ideal-float"],
  ["math.MaxFloat64", "math: const MaxFloat64 ideal-float"],
  ["math.MaxInt16", "math: const MaxInt16 ideal-int"],
  ["math.MaxInt32", "math: const MaxInt32 ideal-int"],
  ["math.MaxInt64", "math: const MaxInt64 ideal-int"],
  ["math.MaxInt8", "math: const MaxInt8 ideal-int"],
  ["math.MaxUint16", "math: const MaxUint16 ideal-int"],
  ["math.MaxUint32", "math: const MaxUint32 ideal-int"],
  ["math.MaxUint64", "math: const MaxUint64 ideal-int"],
  ["math.MaxUint8", "math: const MaxUint8 ideal-int"],
  ["math.MinInt16", "math: const MinInt16 ideal-int"],
  ["math.MinInt32", "math: const MinInt32 ideal-int"],
  ["math.MinInt64", "math: const MinInt64 ideal-int"],
  ["math.MinInt8", "math: const MinInt8 ideal-int"],
  ["math.Phi", "math: const Phi ideal-float"],
  ["math.Pi", "math: const Pi ideal-float"],
  ["math.SmallestNonzeroFloat32", "math: const SmallestNonzeroFloat32 ideal-float"],
  ["math.SmallestNonzeroFloat64", "math: const SmallestNonzeroFloat64 ideal-float"],
  ["math.Sqrt2", "math: const Sqrt2 ideal-float"],
  ["math.SqrtE", "math: const SqrtE ideal-float"],
  ["math.SqrtPhi", "math: const SqrtPhi ideal-float"],
  ["math.SqrtPi", "math: const SqrtPi ideal-float"],
  ["math.Abs", "math: func Abs(float64) float64"],
  ["math.Acos", "math: func Acos(float64) float64"],
  ["math.Acosh", "math: func Acosh(float64) float64"],
  ["math.Asin", "math: func Asin(float64) float64"],
  ["math.Asinh", "math: func Asinh(float64) float64"],
  ["math.Atan", "math: func Atan(float64) float64"],
  ["math.Atan2", "math: func Atan2(float64) float64"],
  ["math.Atanh", "math: func Atanh(float64) float64"],
  ["math.Cbrt", "math: func Cbrt(float64) float64"],
  ["math.Ceil", "math: func Ceil(float64) float64"],
  ["math.Copysign", "math: func Copysign(float64) float64"],
  ["math.Cos", "math: func Cos(float64) float64"],
  ["math.Cosh", "math: func Cosh(float64) float64"],
  ["math.Dim", "math: func Dim(float64) float64"],
  ["math.Erf", "math: func Erf(float64) float64"],
  ["math.Erfc", "math: func Erfc(float64) float64"],
  ["math.Exp", "math: func Exp(float64) float64"],
  ["math.Exp2", "math: func Exp2(float64) float64"],
  ["math.Expm1", "math: func Expm1(float64) float64"],
  ["math.Float32bits", "math: func Float32bits(float32) uint32"],
  ["math.Float32frombits", "math: func Float32frombits(uint32) float32"],
  ["math.Float64bits", "math: func Float64bits(float64) uint64"],
  ["math.Float64frombits", "math: func Float64frombits(uint64) float64"],
  ["math.Floor", "math: func Floor(float64) float64"],
  ["math.Frexp", "math: func Frexp(float64) (float64: int)"],
  ["math.Gamma", "math: func Gamma(float64) float64"],
  ["math.Hypot", "math: func Hypot(float64) float64"],
  ["math.Ilogb", "math: func Ilogb(float64) int"],
  ["math.Inf", "math: func Inf(int) float64"],
  ["math.IsInf", "math: func IsInf(float64: int) bool"],
  ["math.IsNaN", "math: func IsNaN(float64) bool"],
  ["math.J0", "math: func J0(float64) float64"],
  ["math.J1", "math: func J1(float64) float64"],
  ["math.Jn", "math: func Jn(int: float64) float64"],
  ["math.Ldexp", "math: func Ldexp(float64: int) float64"],
  ["math.Lgamma", "math: func Lgamma(float64) (float64: int)"],
  ["math.Log", "math: func Log(float64) float64"],
  ["math.Log10", "math: func Log10(float64) float64"],
  ["math.Log1p", "math: func Log1p(float64) float64"],
  ["math.Log2", "math: func Log2(float64) float64"],
  ["math.Logb", "math: func Logb(float64) float64"],
  ["math.Max", "math: func Max(float64) float64"],
  ["math.Min", "math: func Min(float64) float64"],
  ["math.Mod", "math: func Mod(float64) float64"],
  ["math.Modf", "math: func Modf(float64) (float64: float64)"],
  ["math.NaN", "math: func NaN() float64"],
  ["math.Nextafter", "math: func Nextafter(float64) float64"],
  ["math.Pow", "math: func Pow(float64) float64"],
  ["math.Pow10", "math: func Pow10(int) float64"],
  ["math.Remainder", "math: func Remainder(float64) float64"],
  ["math.Signbit", "math: func Signbit(float64) bool"],
  ["math.Sin", "math: func Sin(float64) float64"],
  ["math.Sincos", "math: func Sincos(float64) float64"],
  ["math.Sinh", "math: func Sinh(float64) float64"],
  ["math.Sqrt", "math: func Sqrt(float64) float64"],
  ["math.Tan", "math: func Tan(float64) float64"],
  ["math.Tanh", "math: func Tanh(float64) float64"],
  ["math.Trunc", "math: func Trunc(float64) float64"],
  ["math.Y0", "math: func Y0(float64) float64"],
  ["math.Y1", "math: func Y1(float64) float64"],
  ["math.Yn", "math: func Yn(int: float64) float64"],
  ["big", "import \"math/big\""],
  ["big.MaxBase", "math/big: const MaxBase ideal-int"],
  ["big.NewInt", "math/big: func NewInt(int64) *Int"],
  ["big.NewRat", "math/big: func NewRat(int64) *Rat"],
  ["big.Int.Abs", "math/big: method (*Int) Abs(*Int) *Int"],
  ["big.Int.Add", "math/big: method (*Int) Add(*Int) *Int"],
  ["big.Int.And", "math/big: method (*Int) And(*Int) *Int"],
  ["big.Int.AndNot", "math/big: method (*Int) AndNot(*Int) *Int"],
  ["big.Int.Binomial", "math/big: method (*Int) Binomial(int64) *Int"],
  ["big.Int.Bit", "math/big: method (*Int) Bit(int) uint"],
  ["big.Int.BitLen", "math/big: method (*Int) BitLen() int"],
  ["big.Int.Bits", "math/big: method (*Int) Bits() []Word"],
  ["big.Int.Bytes", "math/big: method (*Int) Bytes() []byte"],
  ["big.Int.Cmp", "math/big: method (*Int) Cmp(*Int) int"],
  ["big.Int.Div", "math/big: method (*Int) Div(*Int) *Int"],
  ["big.Int.DivMod", "math/big: method (*Int) DivMod(*Int) (*Int: *Int)"],
  ["big.Int.Exp", "math/big: method (*Int) Exp(*Int) *Int"],
  ["big.Int.Format", "math/big: method (*Int) Format(fmt.State: rune)"],
  ["big.Int.GCD", "math/big: method (*Int) GCD(*Int) *Int"],
  ["big.Int.GobDecode", "math/big: method (*Int) GobDecode([]byte) error"],
  ["big.Int.GobEncode", "math/big: method (*Int) GobEncode() ([]byte: error)"],
  ["big.Int.Int64", "math/big: method (*Int) Int64() int64"],
  ["big.Int.Lsh", "math/big: method (*Int) Lsh(*Int: uint) *Int"],
  ["big.Int.Mod", "math/big: method (*Int) Mod(*Int) *Int"],
  ["big.Int.ModInverse", "math/big: method (*Int) ModInverse(*Int) *Int"],
  ["big.Int.Mul", "math/big: method (*Int) Mul(*Int) *Int"],
  ["big.Int.MulRange", "math/big: method (*Int) MulRange(int64) *Int"],
  ["big.Int.Neg", "math/big: method (*Int) Neg(*Int) *Int"],
  ["big.Int.Not", "math/big: method (*Int) Not(*Int) *Int"],
  ["big.Int.Or", "math/big: method (*Int) Or(*Int) *Int"],
  ["big.Int.ProbablyPrime", "math/big: method (*Int) ProbablyPrime(int) bool"],
  ["big.Int.Quo", "math/big: method (*Int) Quo(*Int) *Int"],
  ["big.Int.QuoRem", "math/big: method (*Int) QuoRem(*Int) (*Int: *Int)"],
  ["big.Int.Rand", "math/big: method (*Int) Rand(*rand.Rand: *Int) *Int"],
  ["big.Int.Rem", "math/big: method (*Int) Rem(*Int) *Int"],
  ["big.Int.Rsh", "math/big: method (*Int) Rsh(*Int: uint) *Int"],
  ["big.Int.Scan", "math/big: method (*Int) Scan(fmt.ScanState: rune) error"],
  ["big.Int.Set", "math/big: method (*Int) Set(*Int) *Int"],
  ["big.Int.SetBit", "math/big: method (*Int) SetBit(*Int: int: uint) *Int"],
  ["big.Int.SetBits", "math/big: method (*Int) SetBits([]Word) *Int"],
  ["big.Int.SetBytes", "math/big: method (*Int) SetBytes([]byte) *Int"],
  ["big.Int.SetInt64", "math/big: method (*Int) SetInt64(int64) *Int"],
  ["big.Int.SetString", "math/big: method (*Int) SetString(string: int) (*Int: bool)"],
  ["big.Int.Sign", "math/big: method (*Int) Sign() int"],
  ["big.Int.String", "math/big: method (*Int) String() string"],
  ["big.Int.Sub", "math/big: method (*Int) Sub(*Int) *Int"],
  ["big.Int.Xor", "math/big: method (*Int) Xor(*Int) *Int"],
  ["big.Rat.Abs", "math/big: method (*Rat) Abs(*Rat) *Rat"],
  ["big.Rat.Add", "math/big: method (*Rat) Add(*Rat) *Rat"],
  ["big.Rat.Cmp", "math/big: method (*Rat) Cmp(*Rat) int"],
  ["big.Rat.Denom", "math/big: method (*Rat) Denom() *Int"],
  ["big.Rat.FloatString", "math/big: method (*Rat) FloatString(int) string"],
  ["big.Rat.GobDecode", "math/big: method (*Rat) GobDecode([]byte) error"],
  ["big.Rat.GobEncode", "math/big: method (*Rat) GobEncode() ([]byte: error)"],
  ["big.Rat.Inv", "math/big: method (*Rat) Inv(*Rat) *Rat"],
  ["big.Rat.IsInt", "math/big: method (*Rat) IsInt() bool"],
  ["big.Rat.Mul", "math/big: method (*Rat) Mul(*Rat) *Rat"],
  ["big.Rat.Neg", "math/big: method (*Rat) Neg(*Rat) *Rat"],
  ["big.Rat.Num", "math/big: method (*Rat) Num() *Int"],
  ["big.Rat.Quo", "math/big: method (*Rat) Quo(*Rat) *Rat"],
  ["big.Rat.RatString", "math/big: method (*Rat) RatString() string"],
  ["big.Rat.Scan", "math/big: method (*Rat) Scan(fmt.ScanState: rune) error"],
  ["big.Rat.Set", "math/big: method (*Rat) Set(*Rat) *Rat"],
  ["big.Rat.SetFrac", "math/big: method (*Rat) SetFrac(*Int) *Rat"],
  ["big.Rat.SetFrac64", "math/big: method (*Rat) SetFrac64(int64) *Rat"],
  ["big.Rat.SetInt", "math/big: method (*Rat) SetInt(*Int) *Rat"],
  ["big.Rat.SetInt64", "math/big: method (*Rat) SetInt64(int64) *Rat"],
  ["big.Rat.SetString", "math/big: method (*Rat) SetString(string) (*Rat: bool)"],
  ["big.Rat.Sign", "math/big: method (*Rat) Sign() int"],
  ["big.Rat.String", "math/big: method (*Rat) String() string"],
  ["big.Rat.Sub", "math/big: method (*Rat) Sub(*Rat) *Rat"],
  ["big.Int", "math/big: type Int struct"],
  ["big.Rat", "math/big: type Rat struct"],
  ["big.Word", "math/big: type Word uintptr"],
  ["cmplx", "import \"math/cmplx\""],
  ["cmplx.Abs", "math/cmplx: func Abs(complex128) float64"],
  ["cmplx.Acos", "math/cmplx: func Acos(complex128) complex128"],
  ["cmplx.Acosh", "math/cmplx: func Acosh(complex128) complex128"],
  ["cmplx.Asin", "math/cmplx: func Asin(complex128) complex128"],
  ["cmplx.Asinh", "math/cmplx: func Asinh(complex128) complex128"],
  ["cmplx.Atan", "math/cmplx: func Atan(complex128) complex128"],
  ["cmplx.Atanh", "math/cmplx: func Atanh(complex128) complex128"],
  ["cmplx.Conj", "math/cmplx: func Conj(complex128) complex128"],
  ["cmplx.Cos", "math/cmplx: func Cos(complex128) complex128"],
  ["cmplx.Cosh", "math/cmplx: func Cosh(complex128) complex128"],
  ["cmplx.Cot", "math/cmplx: func Cot(complex128) complex128"],
  ["cmplx.Exp", "math/cmplx: func Exp(complex128) complex128"],
  ["cmplx.Inf", "math/cmplx: func Inf() complex128"],
  ["cmplx.IsInf", "math/cmplx: func IsInf(complex128) bool"],
  ["cmplx.IsNaN", "math/cmplx: func IsNaN(complex128) bool"],
  ["cmplx.Log", "math/cmplx: func Log(complex128) complex128"],
  ["cmplx.Log10", "math/cmplx: func Log10(complex128) complex128"],
  ["cmplx.NaN", "math/cmplx: func NaN() complex128"],
  ["cmplx.Phase", "math/cmplx: func Phase(complex128) float64"],
  ["cmplx.Polar", "math/cmplx: func Polar(complex128) float64"],
  ["cmplx.Pow", "math/cmplx: func Pow(complex128) complex128"],
  ["cmplx.Rect", "math/cmplx: func Rect(float64) complex128"],
  ["cmplx.Sin", "math/cmplx: func Sin(complex128) complex128"],
  ["cmplx.Sinh", "math/cmplx: func Sinh(complex128) complex128"],
  ["cmplx.Sqrt", "math/cmplx: func Sqrt(complex128) complex128"],
  ["cmplx.Tan", "math/cmplx: func Tan(complex128) complex128"],
  ["cmplx.Tanh", "math/cmplx: func Tanh(complex128) complex128"],
  ["rand.ExpFloat64", "math/rand: func ExpFloat64() float64"],
  ["rand.Float32", "math/rand: func Float32() float32"],
  ["rand.Float64", "math/rand: func Float64() float64"],
  ["rand.Int31", "math/rand: func Int31() int32"],
  ["rand.Int31n", "math/rand: func Int31n(int32) int32"],
  ["rand.Int63", "math/rand: func Int63() int64"],
  ["rand.Int63n", "math/rand: func Int63n(int64) int64"],
  ["rand.Intn", "math/rand: func Intn(int) int"],
  ["rand.New", "math/rand: func New(Source) *Rand"],
  ["rand.NewSource", "math/rand: func NewSource(int64) Source"],
  ["rand.NewZipf", "math/rand: func NewZipf(*Rand: float64: float64: uint64) *Zipf"],
  ["rand.NormFloat64", "math/rand: func NormFloat64() float64"],
  ["rand.Perm", "math/rand: func Perm(int) []int"],
  ["rand.Seed", "math/rand: func Seed(int64)"],
  ["rand.Uint32", "math/rand: func Uint32() uint32"],
  ["rand.Rand.ExpFloat64", "math/rand: method (*Rand) ExpFloat64() float64"],
  ["rand.Rand.Float32", "math/rand: method (*Rand) Float32() float32"],
  ["rand.Rand.Float64", "math/rand: method (*Rand) Float64() float64"],
  ["rand.Rand.Int", "math/rand: method (*Rand) Int() int"],
  ["rand.Rand.Int31", "math/rand: method (*Rand) Int31() int32"],
  ["rand.Rand.Int31n", "math/rand: method (*Rand) Int31n(int32) int32"],
  ["rand.Rand.Int63", "math/rand: method (*Rand) Int63() int64"],
  ["rand.Rand.Int63n", "math/rand: method (*Rand) Int63n(int64) int64"],
  ["rand.Rand.Intn", "math/rand: method (*Rand) Intn(int) int"],
  ["rand.Rand.NormFloat64", "math/rand: method (*Rand) NormFloat64() float64"],
  ["rand.Rand.Perm", "math/rand: method (*Rand) Perm(int) []int"],
  ["rand.Rand.Seed", "math/rand: method (*Rand) Seed(int64)"],
  ["rand.Rand.Uint32", "math/rand: method (*Rand) Uint32() uint32"],
  ["rand.Zipf.Uint64", "math/rand: method (*Zipf) Uint64() uint64"],
  ["rand.Rand", "math/rand: type Rand struct"],
  ["rand.Source", "math/rand: type Source interface { Int63: Seed }"],
  ["rand.Zipf", "math/rand: type Zipf struct"],
  ["mime", "import \"mime\""],
  ["mime.AddExtensionType", "mime: func AddExtensionType(string) error"],
  ["mime.FormatMediaType", "mime: func FormatMediaType(string: map[string]string) string"],
  ["mime.ParseMediaType", "mime: func ParseMediaType(string) (string: map[string]string: error)"],
  ["mime.TypeByExtension", "mime: func TypeByExtension(string) string"],
  ["multipart", "import \"mime/multipart\""],
  ["multipart.NewReader", "mime/multipart: func NewReader(io.Reader: string) *Reader"],
  ["multipart.NewWriter", "mime/multipart: func NewWriter(io.Writer) *Writer"],
  ["multipart.FileHeader.Open", "mime/multipart: method (*FileHeader) Open() (File: error)"],
  ["multipart.Form.RemoveAll", "mime/multipart: method (*Form) RemoveAll() error"],
  ["multipart.Part.Close", "mime/multipart: method (*Part) Close() error"],
  ["multipart.Part.FileName", "mime/multipart: method (*Part) FileName() string"],
  ["multipart.Part.FormName", "mime/multipart: method (*Part) FormName() string"],
  ["multipart.Part.Read", "mime/multipart: method (*Part) Read([]byte) (int: error)"],
  ["multipart.Reader.NextPart", "mime/multipart: method (*Reader) NextPart() (*Part: error)"],
  ["multipart.Reader.ReadForm", "mime/multipart: method (*Reader) ReadForm(int64) (*Form: error)"],
  ["multipart.Writer.Boundary", "mime/multipart: method (*Writer) Boundary() string"],
  ["multipart.Writer.Close", "mime/multipart: method (*Writer) Close() error"],
  ["multipart.Writer.CreateFormField", "mime/multipart: method (*Writer) CreateFormField(string) (io.Writer: error)"],
  ["multipart.Writer.CreateFormFile", "mime/multipart: method (*Writer) CreateFormFile(string) (io.Writer: error)"],
  ["multipart.Writer.CreatePart", "mime/multipart: method (*Writer) CreatePart(textproto.MIMEHeader) (io.Writer: error)"],
  ["multipart.Writer.FormDataContentType", "mime/multipart: method (*Writer) FormDataContentType() string"],
  ["multipart.Writer.WriteField", "mime/multipart: method (*Writer) WriteField(string) error"],
  ["multipart.File", "mime/multipart: type File interface { Close: Read: ReadAt: Seek }"],
  ["multipart.FileHeader", "mime/multipart: type FileHeader struct"],
  ["multipart.Form", "mime/multipart: type Form struct"],
  ["multipart.Part", "mime/multipart: type Part struct"],
  ["multipart.Reader", "mime/multipart: type Reader struct"],
  ["multipart.Writer", "mime/multipart: type Writer struct"],
  ["net", "import \"net\""],
  ["net.FlagBroadcast", "net: const FlagBroadcast Flags"],
  ["net.FlagLoopback", "net: const FlagLoopback Flags"],
  ["net.FlagMulticast", "net: const FlagMulticast Flags"],
  ["net.FlagPointToPoint", "net: const FlagPointToPoint Flags"],
  ["net.FlagUp", "net: const FlagUp Flags"],
  ["net.IPv4len", "net: const IPv4len ideal-int"],
  ["net.IPv6len", "net: const IPv6len ideal-int"],
  ["net.CIDRMask", "net: func CIDRMask(int) IPMask"],
  ["net.Dial", "net: func Dial(string) (Conn: error)"],
  ["net.DialIP", "net: func DialIP(string: *IPAddr) (*IPConn: error)"],
  ["net.DialTCP", "net: func DialTCP(string: *TCPAddr) (*TCPConn: error)"],
  ["net.DialTimeout", "net: func DialTimeout(string: time.Duration) (Conn: error)"],
  ["net.DialUDP", "net: func DialUDP(string: *UDPAddr) (*UDPConn: error)"],
  ["net.DialUnix", "net: func DialUnix(string: *UnixAddr) (*UnixConn: error)"],
  ["net.FileConn", "net: func FileConn(*os.File) (Conn: error)"],
  ["net.FileListener", "net: func FileListener(*os.File) (Listener: error)"],
  ["net.FilePacketConn", "net: func FilePacketConn(*os.File) (PacketConn: error)"],
  ["net.IPv4", "net: func IPv4(byte) IP"],
  ["net.IPv4Mask", "net: func IPv4Mask(byte) IPMask"],
  ["net.InterfaceAddrs", "net: func InterfaceAddrs() ([]Addr: error)"],
  ["net.InterfaceByIndex", "net: func InterfaceByIndex(int) (*Interface: error)"],
  ["net.InterfaceByName", "net: func InterfaceByName(string) (*Interface: error)"],
  ["net.Interfaces", "net: func Interfaces() ([]Interface: error)"],
  ["net.JoinHostPort", "net: func JoinHostPort(string) string"],
  ["net.Listen", "net: func Listen(string) (Listener: error)"],
  ["net.ListenIP", "net: func ListenIP(string: *IPAddr) (*IPConn: error)"],
  ["net.ListenMulticastUDP", "net: func ListenMulticastUDP(string: *Interface: *UDPAddr) (*UDPConn: error)"],
  ["net.ListenPacket", "net: func ListenPacket(string) (PacketConn: error)"],
  ["net.ListenTCP", "net: func ListenTCP(string: *TCPAddr) (*TCPListener: error)"],
  ["net.ListenUDP", "net: func ListenUDP(string: *UDPAddr) (*UDPConn: error)"],
  ["net.ListenUnix", "net: func ListenUnix(string: *UnixAddr) (*UnixListener: error)"],
  ["net.ListenUnixgram", "net: func ListenUnixgram(string: *UnixAddr) (*UDPConn: error)"],
  ["net.LookupAddr", "net: func LookupAddr(string) ([]string: error)"],
  ["net.LookupCNAME", "net: func LookupCNAME(string) (string: error)"],
  ["net.LookupHost", "net: func LookupHost(string) ([]string: error)"],
  ["net.LookupIP", "net: func LookupIP(string) ([]IP: error)"],
  ["net.LookupMX", "net: func LookupMX(string) ([]*MX: error)"],
  ["net.LookupPort", "net: func LookupPort(string) (int: error)"],
  ["net.LookupSRV", "net: func LookupSRV(string) (string: []*SRV: error)"],
  ["net.LookupTXT", "net: func LookupTXT(string) ([]string: error)"],
  ["net.ParseCIDR", "net: func ParseCIDR(string) (IP: *IPNet: error)"],
  ["net.ParseIP", "net: func ParseIP(string) IP"],
  ["net.ParseMAC", "net: func ParseMAC(string) (HardwareAddr: error)"],
  ["net.Pipe", "net: func Pipe() (Conn: Conn)"],
  ["net.ResolveIPAddr", "net: func ResolveIPAddr(string) (*IPAddr: error)"],
  ["net.ResolveTCPAddr", "net: func ResolveTCPAddr(string) (*TCPAddr: error)"],
  ["net.ResolveUDPAddr", "net: func ResolveUDPAddr(string) (*UDPAddr: error)"],
  ["net.ResolveUnixAddr", "net: func ResolveUnixAddr(string) (*UnixAddr: error)"],
  ["net.SplitHostPort", "net: func SplitHostPort(string) (string: error)"],
  ["net.AddrError.Error", "net: method (*AddrError) Error() string"],
  ["net.AddrError.Temporary", "net: method (*AddrError) Temporary() bool"],
  ["net.AddrError.Timeout", "net: method (*AddrError) Timeout() bool"],
  ["net.DNSConfigError.Error", "net: method (*DNSConfigError) Error() string"],
  ["net.DNSConfigError.Temporary", "net: method (*DNSConfigError) Temporary() bool"],
  ["net.DNSConfigError.Timeout", "net: method (*DNSConfigError) Timeout() bool"],
  ["net.DNSError.Error", "net: method (*DNSError) Error() string"],
  ["net.DNSError.Temporary", "net: method (*DNSError) Temporary() bool"],
  ["net.DNSError.Timeout", "net: method (*DNSError) Timeout() bool"],
  ["net.IPAddr.Network", "net: method (*IPAddr) Network() string"],
  ["net.IPAddr.String", "net: method (*IPAddr) String() string"],
  ["net.IPConn.Close", "net: method (*IPConn) Close() error"],
  ["net.IPConn.File", "net: method (*IPConn) File() (*os.File: error)"],
  ["net.IPConn.LocalAddr", "net: method (*IPConn) LocalAddr() Addr"],
  ["net.IPConn.Read", "net: method (*IPConn) Read([]byte) (int: error)"],
  ["net.IPConn.ReadFrom", "net: method (*IPConn) ReadFrom([]byte) (int: Addr: error)"],
  ["net.IPConn.ReadFromIP", "net: method (*IPConn) ReadFromIP([]byte) (int: *IPAddr: error)"],
  ["net.IPConn.RemoteAddr", "net: method (*IPConn) RemoteAddr() Addr"],
  ["net.IPConn.SetDeadline", "net: method (*IPConn) SetDeadline(time.Time) error"],
  ["net.IPConn.SetReadBuffer", "net: method (*IPConn) SetReadBuffer(int) error"],
  ["net.IPConn.SetReadDeadline", "net: method (*IPConn) SetReadDeadline(time.Time) error"],
  ["net.IPConn.SetWriteBuffer", "net: method (*IPConn) SetWriteBuffer(int) error"],
  ["net.IPConn.SetWriteDeadline", "net: method (*IPConn) SetWriteDeadline(time.Time) error"],
  ["net.IPConn.Write", "net: method (*IPConn) Write([]byte) (int: error)"],
  ["net.IPConn.WriteTo", "net: method (*IPConn) WriteTo([]byte: Addr) (int: error)"],
  ["net.IPConn.WriteToIP", "net: method (*IPConn) WriteToIP([]byte: *IPAddr) (int: error)"],
  ["net.IPNet.Contains", "net: method (*IPNet) Contains(IP) bool"],
  ["net.IPNet.Network", "net: method (*IPNet) Network() string"],
  ["net.IPNet.String", "net: method (*IPNet) String() string"],
  ["net.Interface.Addrs", "net: method (*Interface) Addrs() ([]Addr: error)"],
  ["net.Interface.MulticastAddrs", "net: method (*Interface) MulticastAddrs() ([]Addr: error)"],
  ["net.OpError.Error", "net: method (*OpError) Error() string"],
  ["net.OpError.Temporary", "net: method (*OpError) Temporary() bool"],
  ["net.OpError.Timeout", "net: method (*OpError) Timeout() bool"],
  ["net.ParseError.Error", "net: method (*ParseError) Error() string"],
  ["net.TCPAddr.Network", "net: method (*TCPAddr) Network() string"],
  ["net.TCPAddr.String", "net: method (*TCPAddr) String() string"],
  ["net.TCPConn.Close", "net: method (*TCPConn) Close() error"],
  ["net.TCPConn.CloseRead", "net: method (*TCPConn) CloseRead() error"],
  ["net.TCPConn.CloseWrite", "net: method (*TCPConn) CloseWrite() error"],
  ["net.TCPConn.File", "net: method (*TCPConn) File() (*os.File: error)"],
  ["net.TCPConn.LocalAddr", "net: method (*TCPConn) LocalAddr() Addr"],
  ["net.TCPConn.Read", "net: method (*TCPConn) Read([]byte) (int: error)"],
  ["net.TCPConn.ReadFrom", "net: method (*TCPConn) ReadFrom(io.Reader) (int64: error)"],
  ["net.TCPConn.RemoteAddr", "net: method (*TCPConn) RemoteAddr() Addr"],
  ["net.TCPConn.SetDeadline", "net: method (*TCPConn) SetDeadline(time.Time) error"],
  ["net.TCPConn.SetKeepAlive", "net: method (*TCPConn) SetKeepAlive(bool) error"],
  ["net.TCPConn.SetLinger", "net: method (*TCPConn) SetLinger(int) error"],
  ["net.TCPConn.SetNoDelay", "net: method (*TCPConn) SetNoDelay(bool) error"],
  ["net.TCPConn.SetReadBuffer", "net: method (*TCPConn) SetReadBuffer(int) error"],
  ["net.TCPConn.SetReadDeadline", "net: method (*TCPConn) SetReadDeadline(time.Time) error"],
  ["net.TCPConn.SetWriteBuffer", "net: method (*TCPConn) SetWriteBuffer(int) error"],
  ["net.TCPConn.SetWriteDeadline", "net: method (*TCPConn) SetWriteDeadline(time.Time) error"],
  ["net.TCPConn.Write", "net: method (*TCPConn) Write([]byte) (int: error)"],
  ["net.TCPListener.Accept", "net: method (*TCPListener) Accept() (Conn: error)"],
  ["net.TCPListener.AcceptTCP", "net: method (*TCPListener) AcceptTCP() (*TCPConn: error)"],
  ["net.TCPListener.Addr", "net: method (*TCPListener) Addr() Addr"],
  ["net.TCPListener.Close", "net: method (*TCPListener) Close() error"],
  ["net.TCPListener.File", "net: method (*TCPListener) File() (*os.File: error)"],
  ["net.TCPListener.SetDeadline", "net: method (*TCPListener) SetDeadline(time.Time) error"],
  ["net.UDPAddr.Network", "net: method (*UDPAddr) Network() string"],
  ["net.UDPAddr.String", "net: method (*UDPAddr) String() string"],
  ["net.UDPConn.Close", "net: method (*UDPConn) Close() error"],
  ["net.UDPConn.File", "net: method (*UDPConn) File() (*os.File: error)"],
  ["net.UDPConn.LocalAddr", "net: method (*UDPConn) LocalAddr() Addr"],
  ["net.UDPConn.Read", "net: method (*UDPConn) Read([]byte) (int: error)"],
  ["net.UDPConn.ReadFrom", "net: method (*UDPConn) ReadFrom([]byte) (int: Addr: error)"],
  ["net.UDPConn.ReadFromUDP", "net: method (*UDPConn) ReadFromUDP([]byte) (int: *UDPAddr: error)"],
  ["net.UDPConn.RemoteAddr", "net: method (*UDPConn) RemoteAddr() Addr"],
  ["net.UDPConn.SetDeadline", "net: method (*UDPConn) SetDeadline(time.Time) error"],
  ["net.UDPConn.SetReadBuffer", "net: method (*UDPConn) SetReadBuffer(int) error"],
  ["net.UDPConn.SetReadDeadline", "net: method (*UDPConn) SetReadDeadline(time.Time) error"],
  ["net.UDPConn.SetWriteBuffer", "net: method (*UDPConn) SetWriteBuffer(int) error"],
  ["net.UDPConn.SetWriteDeadline", "net: method (*UDPConn) SetWriteDeadline(time.Time) error"],
  ["net.UDPConn.Write", "net: method (*UDPConn) Write([]byte) (int: error)"],
  ["net.UDPConn.WriteTo", "net: method (*UDPConn) WriteTo([]byte: Addr) (int: error)"],
  ["net.UDPConn.WriteToUDP", "net: method (*UDPConn) WriteToUDP([]byte: *UDPAddr) (int: error)"],
  ["net.UnixAddr.Network", "net: method (*UnixAddr) Network() string"],
  ["net.UnixAddr.String", "net: method (*UnixAddr) String() string"],
  ["net.UnixConn.Close", "net: method (*UnixConn) Close() error"],
  ["net.UnixConn.File", "net: method (*UnixConn) File() (*os.File: error)"],
  ["net.UnixConn.LocalAddr", "net: method (*UnixConn) LocalAddr() Addr"],
  ["net.UnixConn.Read", "net: method (*UnixConn) Read([]byte) (int: error)"],
  ["net.UnixConn.ReadFrom", "net: method (*UnixConn) ReadFrom([]byte) (int: Addr: error)"],
  ["net.UnixConn.ReadFromUnix", "net: method (*UnixConn) ReadFromUnix([]byte) (int: *UnixAddr: error)"],
  ["net.UnixConn.ReadMsgUnix", "net: method (*UnixConn) ReadMsgUnix([]byte) (int: *UnixAddr: error)"],
  ["net.UnixConn.RemoteAddr", "net: method (*UnixConn) RemoteAddr() Addr"],
  ["net.UnixConn.SetDeadline", "net: method (*UnixConn) SetDeadline(time.Time) error"],
  ["net.UnixConn.SetReadBuffer", "net: method (*UnixConn) SetReadBuffer(int) error"],
  ["net.UnixConn.SetReadDeadline", "net: method (*UnixConn) SetReadDeadline(time.Time) error"],
  ["net.UnixConn.SetWriteBuffer", "net: method (*UnixConn) SetWriteBuffer(int) error"],
  ["net.UnixConn.SetWriteDeadline", "net: method (*UnixConn) SetWriteDeadline(time.Time) error"],
  ["net.UnixConn.Write", "net: method (*UnixConn) Write([]byte) (int: error)"],
  ["net.UnixConn.WriteMsgUnix", "net: method (*UnixConn) WriteMsgUnix([]byte: *UnixAddr) (int: error)"],
  ["net.UnixConn.WriteTo", "net: method (*UnixConn) WriteTo([]byte: Addr) (int: error)"],
  ["net.UnixConn.WriteToUnix", "net: method (*UnixConn) WriteToUnix([]byte: *UnixAddr) (int: error)"],
  ["net.UnixListener.Accept", "net: method (*UnixListener) Accept() (Conn: error)"],
  ["net.UnixListener.AcceptUnix", "net: method (*UnixListener) AcceptUnix() (*UnixConn: error)"],
  ["net.UnixListener.Addr", "net: method (*UnixListener) Addr() Addr"],
  ["net.UnixListener.Close", "net: method (*UnixListener) Close() error"],
  ["net.UnixListener.File", "net: method (*UnixListener) File() (*os.File: error)"],
  ["net.UnixListener.SetDeadline", "net: method (*UnixListener) SetDeadline(time.Time) error"],
  ["net.Flags.String", "net: method (Flags) String() string"],
  ["net.HardwareAddr.String", "net: method (HardwareAddr) String() string"],
  ["net.IP.DefaultMask", "net: method (IP) DefaultMask() IPMask"],
  ["net.IP.Equal", "net: method (IP) Equal(IP) bool"],
  ["net.IP.IsGlobalUnicast", "net: method (IP) IsGlobalUnicast() bool"],
  ["net.IP.IsInterfaceLocalMulticast", "net: method (IP) IsInterfaceLocalMulticast() bool"],
  ["net.IP.IsLinkLocalMulticast", "net: method (IP) IsLinkLocalMulticast() bool"],
  ["net.IP.IsLinkLocalUnicast", "net: method (IP) IsLinkLocalUnicast() bool"],
  ["net.IP.IsLoopback", "net: method (IP) IsLoopback() bool"],
  ["net.IP.IsMulticast", "net: method (IP) IsMulticast() bool"],
  ["net.IP.IsUnspecified", "net: method (IP) IsUnspecified() bool"],
  ["net.IP.Mask", "net: method (IP) Mask(IPMask) IP"],
  ["net.IP.String", "net: method (IP) String() string"],
  ["net.IP.To16", "net: method (IP) To16() IP"],
  ["net.IP.To4", "net: method (IP) To4() IP"],
  ["net.IPMask.Size", "net: method (IPMask) Size() int"],
  ["net.IPMask.String", "net: method (IPMask) String() string"],
  ["net.InvalidAddrError.Error", "net: method (InvalidAddrError) Error() string"],
  ["net.InvalidAddrError.Temporary", "net: method (InvalidAddrError) Temporary() bool"],
  ["net.InvalidAddrError.Timeout", "net: method (InvalidAddrError) Timeout() bool"],
  ["net.UnknownNetworkError.Error", "net: method (UnknownNetworkError) Error() string"],
  ["net.UnknownNetworkError.Temporary", "net: method (UnknownNetworkError) Temporary() bool"],
  ["net.UnknownNetworkError.Timeout", "net: method (UnknownNetworkError) Timeout() bool"],
  ["net.Addr", "net: type Addr interface { Network: String }"],
  ["net.AddrError", "net: type AddrError struct"],
  ["net.Conn", "net: type Conn interface { Close: LocalAddr: Read: RemoteAddr: SetDeadline: SetReadDeadline: SetWriteDeadline: Write }"],
  ["net.DNSConfigError", "net: type DNSConfigError struct"],
  ["net.DNSError", "net: type DNSError struct"],
  ["net.Error", "net: type Error interface { Error: Temporary: Timeout }"],
  ["net.Flags", "net: type Flags uint"],
  ["net.HardwareAddr []byte", "net: type HardwareAddr []byte"],
  ["net.IP []byte", "net: type IP []byte"],
  ["net.IPAddr", "net: type IPAddr struct"],
  ["net.IPConn", "net: type IPConn struct"],
  ["net.IPMask []byte", "net: type IPMask []byte"],
  ["net.IPNet", "net: type IPNet struct"],
  ["net.Interface", "net: type Interface struct"],
  ["net.InvalidAddrError", "net: type InvalidAddrError string"],
  ["net.Listener", "net: type Listener interface { Accept: Addr: Close }"],
  ["net.MX", "net: type MX struct"],
  ["net.OpError", "net: type OpError struct"],
  ["net.PacketConn", "net: type PacketConn interface { Close: LocalAddr: ReadFrom: SetDeadline: SetReadDeadline: SetWriteDeadline: WriteTo }"],
  ["net.ParseError", "net: type ParseError struct"],
  ["net.SRV", "net: type SRV struct"],
  ["net.TCPAddr", "net: type TCPAddr struct"],
  ["net.TCPConn", "net: type TCPConn struct"],
  ["net.TCPListener", "net: type TCPListener struct"],
  ["net.UDPAddr", "net: type UDPAddr struct"],
  ["net.UDPConn", "net: type UDPConn struct"],
  ["net.UnixAddr", "net: type UnixAddr struct"],
  ["net.UnixConn", "net: type UnixConn struct"],
  ["net.UnixListener", "net: type UnixListener struct"],
  ["net.UnknownNetworkError", "net: type UnknownNetworkError string"],
  ["http", "import \"net/http\""],
  ["http.DefaultMaxHeaderBytes", "net/http: const DefaultMaxHeaderBytes ideal-int"],
  ["http.DefaultMaxIdleConnsPerHost", "net/http: const DefaultMaxIdleConnsPerHost ideal-int"],
  ["http.StatusAccepted", "net/http: const StatusAccepted ideal-int"],
  ["http.StatusBadGateway", "net/http: const StatusBadGateway ideal-int"],
  ["http.StatusBadRequest", "net/http: const StatusBadRequest ideal-int"],
  ["http.StatusConflict", "net/http: const StatusConflict ideal-int"],
  ["http.StatusContinue", "net/http: const StatusContinue ideal-int"],
  ["http.StatusCreated", "net/http: const StatusCreated ideal-int"],
  ["http.StatusExpectationFailed", "net/http: const StatusExpectationFailed ideal-int"],
  ["http.StatusForbidden", "net/http: const StatusForbidden ideal-int"],
  ["http.StatusFound", "net/http: const StatusFound ideal-int"],
  ["http.StatusGatewayTimeout", "net/http: const StatusGatewayTimeout ideal-int"],
  ["http.StatusGone", "net/http: const StatusGone ideal-int"],
  ["http.StatusHTTPVersionNotSupported", "net/http: const StatusHTTPVersionNotSupported ideal-int"],
  ["http.StatusInternalServerError", "net/http: const StatusInternalServerError ideal-int"],
  ["http.StatusLengthRequired", "net/http: const StatusLengthRequired ideal-int"],
  ["http.StatusMethodNotAllowed", "net/http: const StatusMethodNotAllowed ideal-int"],
  ["http.StatusMovedPermanently", "net/http: const StatusMovedPermanently ideal-int"],
  ["http.StatusMultipleChoices", "net/http: const StatusMultipleChoices ideal-int"],
  ["http.StatusNoContent", "net/http: const StatusNoContent ideal-int"],
  ["http.StatusNonAuthoritativeInfo", "net/http: const StatusNonAuthoritativeInfo ideal-int"],
  ["http.StatusNotAcceptable", "net/http: const StatusNotAcceptable ideal-int"],
  ["http.StatusNotFound", "net/http: const StatusNotFound ideal-int"],
  ["http.StatusNotImplemented", "net/http: const StatusNotImplemented ideal-int"],
  ["http.StatusNotModified", "net/http: const StatusNotModified ideal-int"],
  ["http.StatusOK", "net/http: const StatusOK ideal-int"],
  ["http.StatusPartialContent", "net/http: const StatusPartialContent ideal-int"],
  ["http.StatusPaymentRequired", "net/http: const StatusPaymentRequired ideal-int"],
  ["http.StatusPreconditionFailed", "net/http: const StatusPreconditionFailed ideal-int"],
  ["http.StatusProxyAuthRequired", "net/http: const StatusProxyAuthRequired ideal-int"],
  ["http.StatusRequestEntityTooLarge", "net/http: const StatusRequestEntityTooLarge ideal-int"],
  ["http.StatusRequestTimeout", "net/http: const StatusRequestTimeout ideal-int"],
  ["http.StatusRequestURITooLong", "net/http: const StatusRequestURITooLong ideal-int"],
  ["http.StatusRequestedRangeNotSatisfiable", "net/http: const StatusRequestedRangeNotSatisfiable ideal-int"],
  ["http.StatusResetContent", "net/http: const StatusResetContent ideal-int"],
  ["http.StatusSeeOther", "net/http: const StatusSeeOther ideal-int"],
  ["http.StatusServiceUnavailable", "net/http: const StatusServiceUnavailable ideal-int"],
  ["http.StatusSwitchingProtocols", "net/http: const StatusSwitchingProtocols ideal-int"],
  ["http.StatusTeapot", "net/http: const StatusTeapot ideal-int"],
  ["http.StatusTemporaryRedirect", "net/http: const StatusTemporaryRedirect ideal-int"],
  ["http.StatusUnauthorized", "net/http: const StatusUnauthorized ideal-int"],
  ["http.StatusUnsupportedMediaType", "net/http: const StatusUnsupportedMediaType ideal-int"],
  ["http.StatusUseProxy", "net/http: const StatusUseProxy ideal-int"],
  ["http.TimeFormat", "net/http: const TimeFormat ideal-string"],
  ["http.CanonicalHeaderKey", "net/http: func CanonicalHeaderKey(string) string"],
  ["http.DetectContentType", "net/http: func DetectContentType([]byte) string"],
  ["http.Error", "net/http: func Error(ResponseWriter: string: int)"],
  ["http.FileServer", "net/http: func FileServer(FileSystem) Handler"],
  ["http.Get", "net/http: func Get(string) (*Response: error)"],
  ["http.Handle", "net/http: func Handle(string: Handler)"],
  ["http.HandleFunc", "net/http: func HandleFunc(string: func(ResponseWriter: *Request))"],
  ["http.Head", "net/http: func Head(string) (*Response: error)"],
  ["http.ListenAndServe", "net/http: func ListenAndServe(string: Handler) error"],
  ["http.ListenAndServeTLS", "net/http: func ListenAndServeTLS(string: string: string: Handler) error"],
  ["http.MaxBytesReader", "net/http: func MaxBytesReader(ResponseWriter: io.ReadCloser: int64) io.ReadCloser"],
  ["http.NewFileTransport", "net/http: func NewFileTransport(FileSystem) RoundTripper"],
  ["http.NewRequest", "net/http: func NewRequest(string: io.Reader) (*Request: error)"],
  ["http.NewServeMux", "net/http: func NewServeMux() *ServeMux"],
  ["http.NotFound", "net/http: func NotFound(ResponseWriter: *Request)"],
  ["http.NotFoundHandler", "net/http: func NotFoundHandler() Handler"],
  ["http.ParseHTTPVersion", "net/http: func ParseHTTPVersion(string) (int: bool)"],
  ["http.Post", "net/http: func Post(string: string: io.Reader) (*Response: error)"],
  ["http.PostForm", "net/http: func PostForm(string: url.Values) (*Response: error)"],
  ["http.ProxyFromEnvironment", "net/http: func ProxyFromEnvironment(*Request) (*url.URL: error)"],
  ["http.ProxyURL", "net/http: func ProxyURL(*url.URL) func(*Request) (*url.URL: error)"],
  ["http.ReadRequest", "net/http: func ReadRequest(*bufio.Reader) (*Request: error)"],
  ["http.ReadResponse", "net/http: func ReadResponse(*bufio.Reader: *Request) (*Response: error)"],
  ["http.Redirect", "net/http: func Redirect(ResponseWriter: *Request: string: int)"],
  ["http.RedirectHandler", "net/http: func RedirectHandler(string: int) Handler"],
  ["http.Serve", "net/http: func Serve(net.Listener: Handler) error"],
  ["http.ServeContent", "net/http: func ServeContent(ResponseWriter: *Request: string: time.Time: io.ReadSeeker)"],
  ["http.ServeFile", "net/http: func ServeFile(ResponseWriter: *Request: string)"],
  ["http.SetCookie", "net/http: func SetCookie(ResponseWriter: *Cookie)"],
  ["http.StatusText", "net/http: func StatusText(int) string"],
  ["http.StripPrefix", "net/http: func StripPrefix(string: Handler) Handler"],
  ["http.TimeoutHandler", "net/http: func TimeoutHandler(Handler: time.Duration: string) Handler"],
  ["http.Client.Do", "net/http: method (*Client) Do(*Request) (*Response: error)"],
  ["http.Client.Get", "net/http: method (*Client) Get(string) (*Response: error)"],
  ["http.Client.Head", "net/http: method (*Client) Head(string) (*Response: error)"],
  ["http.Client.Post", "net/http: method (*Client) Post(string: string: io.Reader) (*Response: error)"],
  ["http.Client.PostForm", "net/http: method (*Client) PostForm(string: url.Values) (*Response: error)"],
  ["http.Cookie.String", "net/http: method (*Cookie) String() string"],
  ["http.ProtocolError.Error", "net/http: method (*ProtocolError) Error() string"],
  ["http.Request.AddCookie", "net/http: method (*Request) AddCookie(*Cookie)"],
  ["http.Request.Cookie", "net/http: method (*Request) Cookie(string) (*Cookie: error)"],
  ["http.Request.Cookies", "net/http: method (*Request) Cookies() []*Cookie"],
  ["http.Request.FormFile", "net/http: method (*Request) FormFile(string) (multipart.File: *multipart.FileHeader: error)"],
  ["http.Request.FormValue", "net/http: method (*Request) FormValue(string) string"],
  ["http.Request.MultipartReader", "net/http: method (*Request) MultipartReader() (*multipart.Reader: error)"],
  ["http.Request.ParseForm", "net/http: method (*Request) ParseForm() error"],
  ["http.Request.ParseMultipartForm", "net/http: method (*Request) ParseMultipartForm(int64) error"],
  ["http.Request.ProtoAtLeast", "net/http: method (*Request) ProtoAtLeast(int) bool"],
  ["http.Request.Referer", "net/http: method (*Request) Referer() string"],
  ["http.Request.SetBasicAuth", "net/http: method (*Request) SetBasicAuth(string)"],
  ["http.Request.UserAgent", "net/http: method (*Request) UserAgent() string"],
  ["http.Request.Write", "net/http: method (*Request) Write(io.Writer) error"],
  ["http.Request.WriteProxy", "net/http: method (*Request) WriteProxy(io.Writer) error"],
  ["http.Response.Cookies", "net/http: method (*Response) Cookies() []*Cookie"],
  ["http.Response.Location", "net/http: method (*Response) Location() (*url.URL: error)"],
  ["http.Response.ProtoAtLeast", "net/http: method (*Response) ProtoAtLeast(int) bool"],
  ["http.Response.Write", "net/http: method (*Response) Write(io.Writer) error"],
  ["http.ServeMux.Handle", "net/http: method (*ServeMux) Handle(string: Handler)"],
  ["http.ServeMux.HandleFunc", "net/http: method (*ServeMux) HandleFunc(string: func(ResponseWriter: *Request))"],
  ["http.ServeMux.ServeHTTP", "net/http: method (*ServeMux) ServeHTTP(ResponseWriter: *Request)"],
  ["http.Server.ListenAndServe", "net/http: method (*Server) ListenAndServe() error"],
  ["http.Server.ListenAndServeTLS", "net/http: method (*Server) ListenAndServeTLS(string) error"],
  ["http.Server.Serve", "net/http: method (*Server) Serve(net.Listener) error"],
  ["http.Transport.CloseIdleConnections", "net/http: method (*Transport) CloseIdleConnections()"],
  ["http.Transport.RegisterProtocol", "net/http: method (*Transport) RegisterProtocol(string: RoundTripper)"],
  ["http.Transport.RoundTrip", "net/http: method (*Transport) RoundTrip(*Request) (*Response: error)"],
  ["http.Dir.Open", "net/http: method (Dir) Open(string) (File: error)"],
  ["http.HandlerFunc.ServeHTTP", "net/http: method (HandlerFunc) ServeHTTP(ResponseWriter: *Request)"],
  ["http.Header.Add", "net/http: method (Header) Add(string)"],
  ["http.Header.Del", "net/http: method (Header) Del(string)"],
  ["http.Header.Get", "net/http: method (Header) Get(string) string"],
  ["http.Header.Set", "net/http: method (Header) Set(string)"],
  ["http.Header.Write", "net/http: method (Header) Write(io.Writer) error"],
  ["http.Header.WriteSubset", "net/http: method (Header) WriteSubset(io.Writer: map[string]bool) error"],
  ["http.Client", "net/http: type Client struct"],
  ["http.Cookie", "net/http: type Cookie struct"],
  ["http.CookieJar", "net/http: type CookieJar interface { Cookies: SetCookies }"],
  ["http.Dir", "net/http: type Dir string"],
  ["http.File", "net/http: type File interface { Close: Read: Readdir: Seek: Stat }"],
  ["http.FileSystem", "net/http: type FileSystem interface { Open }"],
  ["http.Flusher", "net/http: type Flusher interface { Flush }"],
  ["http.Handler", "net/http: type Handler interface { ServeHTTP }"],
  ["http.HandlerFunc func", "net/http: type HandlerFunc func(ResponseWriter: *Request)"],
  ["http.Header map[string][]string", "net/http: type Header map[string][]string"],
  ["http.Hijacker", "net/http: type Hijacker interface { Hijack }"],
  ["http.ProtocolError", "net/http: type ProtocolError struct"],
  ["http.Request", "net/http: type Request struct"],
  ["http.Response", "net/http: type Response struct"],
  ["http.ResponseWriter", "net/http: type ResponseWriter interface { Header: Write: WriteHeader }"],
  ["http.RoundTripper", "net/http: type RoundTripper interface { RoundTrip }"],
  ["http.ServeMux", "net/http: type ServeMux struct"],
  ["http.Server", "net/http: type Server struct"],
  ["http.Transport", "net/http: type Transport struct"],
  ["cgi", "import \"net/http/cgi\""],
  ["cgi.Request", "net/http/cgi: func Request() (*http.Request: error)"],
  ["cgi.RequestFromMap", "net/http/cgi: func RequestFromMap(map[string]string) (*http.Request: error)"],
  ["cgi.Serve", "net/http/cgi: func Serve(http.Handler) error"],
  ["cgi.Handler.ServeHTTP", "net/http/cgi: method (*Handler) ServeHTTP(http.ResponseWriter: *http.Request)"],
  ["cgi.Handler", "net/http/cgi: type Handler struct"],
  ["fcgi", "import \"net/http/fcgi\""],
  ["fcgi.Serve", "net/http/fcgi: func Serve(net.Listener: http.Handler) error"],
  ["httptest", "import \"net/http/httptest\""],
  ["httptest.DefaultRemoteAddr", "net/http/httptest: const DefaultRemoteAddr ideal-string"],
  ["httptest.NewRecorder", "net/http/httptest: func NewRecorder() *ResponseRecorder"],
  ["httptest.NewServer", "net/http/httptest: func NewServer(http.Handler) *Server"],
  ["httptest.NewTLSServer", "net/http/httptest: func NewTLSServer(http.Handler) *Server"],
  ["httptest.NewUnstartedServer", "net/http/httptest: func NewUnstartedServer(http.Handler) *Server"],
  ["httptest.ResponseRecorder.Flush", "net/http/httptest: method (*ResponseRecorder) Flush()"],
  ["httptest.ResponseRecorder.Header", "net/http/httptest: method (*ResponseRecorder) Header() http.Header"],
  ["httptest.ResponseRecorder.Write", "net/http/httptest: method (*ResponseRecorder) Write([]byte) (int: error)"],
  ["httptest.ResponseRecorder.WriteHeader", "net/http/httptest: method (*ResponseRecorder) WriteHeader(int)"],
  ["httptest.Server.Close", "net/http/httptest: method (*Server) Close()"],
  ["httptest.Server.CloseClientConnections", "net/http/httptest: method (*Server) CloseClientConnections()"],
  ["httptest.Server.Start", "net/http/httptest: method (*Server) Start()"],
  ["httptest.Server.StartTLS", "net/http/httptest: method (*Server) StartTLS()"],
  ["httptest.ResponseRecorder", "net/http/httptest: type ResponseRecorder struct"],
  ["httptest.Server", "net/http/httptest: type Server struct"],
  ["httputil", "import \"net/http/httputil\""],
  ["httputil.DumpRequest", "net/http/httputil: func DumpRequest(*http.Request: bool) ([]byte: error)"],
  ["httputil.DumpRequestOut", "net/http/httputil: func DumpRequestOut(*http.Request: bool) ([]byte: error)"],
  ["httputil.DumpResponse", "net/http/httputil: func DumpResponse(*http.Response: bool) ([]byte: error)"],
  ["httputil.NewChunkedReader", "net/http/httputil: func NewChunkedReader(io.Reader) io.Reader"],
  ["httputil.NewChunkedWriter", "net/http/httputil: func NewChunkedWriter(io.Writer) io.WriteCloser"],
  ["httputil.NewClientConn", "net/http/httputil: func NewClientConn(net.Conn: *bufio.Reader) *ClientConn"],
  ["httputil.NewProxyClientConn", "net/http/httputil: func NewProxyClientConn(net.Conn: *bufio.Reader) *ClientConn"],
  ["httputil.NewServerConn", "net/http/httputil: func NewServerConn(net.Conn: *bufio.Reader) *ServerConn"],
  ["httputil.NewSingleHostReverseProxy", "net/http/httputil: func NewSingleHostReverseProxy(*url.URL) *ReverseProxy"],
  ["httputil.ClientConn.Close", "net/http/httputil: method (*ClientConn) Close() error"],
  ["httputil.ClientConn.Do", "net/http/httputil: method (*ClientConn) Do(*http.Request) (*http.Response: error)"],
  ["httputil.ClientConn.Hijack", "net/http/httputil: method (*ClientConn) Hijack() (net.Conn: *bufio.Reader)"],
  ["httputil.ClientConn.Pending", "net/http/httputil: method (*ClientConn) Pending() int"],
  ["httputil.ClientConn.Read", "net/http/httputil: method (*ClientConn) Read(*http.Request) (*http.Response: error)"],
  ["httputil.ClientConn.Write", "net/http/httputil: method (*ClientConn) Write(*http.Request) error"],
  ["httputil.ReverseProxy.ServeHTTP", "net/http/httputil: method (*ReverseProxy) ServeHTTP(http.ResponseWriter: *http.Request)"],
  ["httputil.ServerConn.Close", "net/http/httputil: method (*ServerConn) Close() error"],
  ["httputil.ServerConn.Hijack", "net/http/httputil: method (*ServerConn) Hijack() (net.Conn: *bufio.Reader)"],
  ["httputil.ServerConn.Pending", "net/http/httputil: method (*ServerConn) Pending() int"],
  ["httputil.ServerConn.Read", "net/http/httputil: method (*ServerConn) Read() (*http.Request: error)"],
  ["httputil.ServerConn.Write", "net/http/httputil: method (*ServerConn) Write(*http.Request: *http.Response) error"],
  ["httputil.ClientConn", "net/http/httputil: type ClientConn struct"],
  ["httputil.ReverseProxy", "net/http/httputil: type ReverseProxy struct"],
  ["httputil.ServerConn", "net/http/httputil: type ServerConn struct"],
  ["pprof", "import \"runtime/pprof\""],
  ["pprof.Cmdline", "net/http/pprof: func Cmdline(http.ResponseWriter: *http.Request)"],
  ["pprof.Handler", "net/http/pprof: func Handler(string) http.Handler"],
  ["pprof.Index", "net/http/pprof: func Index(http.ResponseWriter: *http.Request)"],
  ["pprof.Profile", "runtime/pprof: type Profile struct"],
  ["pprof.Symbol", "net/http/pprof: func Symbol(http.ResponseWriter: *http.Request)"],
  ["mail", "import \"net/mail\""],
  ["mail.ReadMessage", "net/mail: func ReadMessage(io.Reader) (*Message: error)"],
  ["mail.Address.String", "net/mail: method (*Address) String() string"],
  ["mail.Header.AddressList", "net/mail: method (Header) AddressList(string) ([]*Address: error)"],
  ["mail.Header.Date", "net/mail: method (Header) Date() (time.Time: error)"],
  ["mail.Header.Get", "net/mail: method (Header) Get(string) string"],
  ["mail.Address", "net/mail: type Address struct"],
  ["mail.Header map[string][]string", "net/mail: type Header map[string][]string"],
  ["mail.Message", "net/mail: type Message struct"],
  ["rpc", "import \"net/rpc\""],
  ["rpc.DefaultDebugPath", "net/rpc: const DefaultDebugPath ideal-string"],
  ["rpc.DefaultRPCPath", "net/rpc: const DefaultRPCPath ideal-string"],
  ["rpc.Accept", "net/rpc: func Accept(net.Listener)"],
  ["rpc.Dial", "net/rpc: func Dial(string) (*Client: error)"],
  ["rpc.DialHTTP", "net/rpc: func DialHTTP(string) (*Client: error)"],
  ["rpc.DialHTTPPath", "net/rpc: func DialHTTPPath(string) (*Client: error)"],
  ["rpc.HandleHTTP", "net/rpc: func HandleHTTP()"],
  ["rpc.NewClient", "net/rpc: func NewClient(io.ReadWriteCloser) *Client"],
  ["rpc.NewClientWithCodec", "net/rpc: func NewClientWithCodec(ClientCodec) *Client"],
  ["rpc.NewServer", "net/rpc: func NewServer() *Server"],
  ["rpc.Register", "net/rpc: func Register(interface{}) error"],
  ["rpc.RegisterName", "net/rpc: func RegisterName(string: interface{}) error"],
  ["rpc.ServeCodec", "net/rpc: func ServeCodec(ServerCodec)"],
  ["rpc.ServeConn", "net/rpc: func ServeConn(io.ReadWriteCloser)"],
  ["rpc.ServeRequest", "net/rpc: func ServeRequest(ServerCodec) error"],
  ["rpc.Client.Call", "net/rpc: method (*Client) Call(string: interface{}: interface{}) error"],
  ["rpc.Client.Close", "net/rpc: method (*Client) Close() error"],
  ["rpc.Client.Go", "net/rpc: method (*Client) Go(string: interface{}: interface{}: chan *Call) *Call"],
  ["rpc.Server.Accept", "net/rpc: method (*Server) Accept(net.Listener)"],
  ["rpc.Server.HandleHTTP", "net/rpc: method (*Server) HandleHTTP(string)"],
  ["rpc.Server.Register", "net/rpc: method (*Server) Register(interface{}) error"],
  ["rpc.Server.RegisterName", "net/rpc: method (*Server) RegisterName(string: interface{}) error"],
  ["rpc.Server.ServeCodec", "net/rpc: method (*Server) ServeCodec(ServerCodec)"],
  ["rpc.Server.ServeConn", "net/rpc: method (*Server) ServeConn(io.ReadWriteCloser)"],
  ["rpc.Server.ServeHTTP", "net/rpc: method (*Server) ServeHTTP(http.ResponseWriter: *http.Request)"],
  ["rpc.Server.ServeRequest", "net/rpc: method (*Server) ServeRequest(ServerCodec) error"],
  ["rpc.ServerError.Error", "net/rpc: method (ServerError) Error() string"],
  ["rpc.Call", "net/rpc: type Call struct"],
  ["rpc.Client", "net/rpc: type Client struct"],
  ["rpc.ClientCodec", "net/rpc: type ClientCodec interface { Close: ReadResponseBody: ReadResponseHeader: WriteRequest }"],
  ["rpc.Request", "net/rpc: type Request struct"],
  ["rpc.Response", "net/rpc: type Response struct"],
  ["rpc.Server", "net/rpc: type Server struct"],
  ["rpc.ServerCodec", "net/rpc: type ServerCodec interface { Close: ReadRequestBody: ReadRequestHeader: WriteResponse }"],
  ["rpc.ServerError", "net/rpc: type ServerError string"],
  ["jsonrpc", "import \"net/rpc/jsonrpc\""],
  ["jsonrpc.Dial", "net/rpc/jsonrpc: func Dial(string) (*rpc.Client: error)"],
  ["jsonrpc.NewClient", "net/rpc/jsonrpc: func NewClient(io.ReadWriteCloser) *rpc.Client"],
  ["jsonrpc.NewClientCodec", "net/rpc/jsonrpc: func NewClientCodec(io.ReadWriteCloser) rpc.ClientCodec"],
  ["jsonrpc.NewServerCodec", "net/rpc/jsonrpc: func NewServerCodec(io.ReadWriteCloser) rpc.ServerCodec"],
  ["jsonrpc.ServeConn", "net/rpc/jsonrpc: func ServeConn(io.ReadWriteCloser)"],
  ["smtp", "import \"net/smtp\""],
  ["smtp.CRAMMD5Auth", "net/smtp: func CRAMMD5Auth(string) Auth"],
  ["smtp.Dial", "net/smtp: func Dial(string) (*Client: error)"],
  ["smtp.NewClient", "net/smtp: func NewClient(net.Conn: string) (*Client: error)"],
  ["smtp.PlainAuth", "net/smtp: func PlainAuth(string) Auth"],
  ["smtp.SendMail", "net/smtp: func SendMail(string: Auth: string: []string: []byte) error"],
  ["smtp.Client.Auth", "net/smtp: method (*Client) Auth(Auth) error"],
  ["smtp.Client.Data", "net/smtp: method (*Client) Data() (io.WriteCloser: error)"],
  ["smtp.Client.Extension", "net/smtp: method (*Client) Extension(string) (bool: string)"],
  ["smtp.Client.Mail", "net/smtp: method (*Client) Mail(string) error"],
  ["smtp.Client.Quit", "net/smtp: method (*Client) Quit() error"],
  ["smtp.Client.Rcpt", "net/smtp: method (*Client) Rcpt(string) error"],
  ["smtp.Client.Reset", "net/smtp: method (*Client) Reset() error"],
  ["smtp.Client.StartTLS", "net/smtp: method (*Client) StartTLS(*tls.Config) error"],
  ["smtp.Client.Verify", "net/smtp: method (*Client) Verify(string) error"],
  ["smtp.Auth", "net/smtp: type Auth interface { Next: Start }"],
  ["smtp.Client", "net/smtp: type Client struct"],
  ["smtp.ServerInfo", "net/smtp: type ServerInfo struct"],
  ["textproto", "import \"net/textproto\""],
  ["textproto.CanonicalMIMEHeaderKey", "net/textproto: func CanonicalMIMEHeaderKey(string) string"],
  ["textproto.Dial", "net/textproto: func Dial(string) (*Conn: error)"],
  ["textproto.NewConn", "net/textproto: func NewConn(io.ReadWriteCloser) *Conn"],
  ["textproto.NewReader", "net/textproto: func NewReader(*bufio.Reader) *Reader"],
  ["textproto.NewWriter", "net/textproto: func NewWriter(*bufio.Writer) *Writer"],
  ["textproto.Conn.Close", "net/textproto: method (*Conn) Close() error"],
  ["textproto.Conn.Cmd", "net/textproto: method (*Conn) Cmd(string: ...interface{}) (uint: error)"],
  ["textproto.Conn.DotReader", "net/textproto: method (*Conn) DotReader() io.Reader"],
  ["textproto.Conn.DotWriter", "net/textproto: method (*Conn) DotWriter() io.WriteCloser"],
  ["textproto.Conn.EndRequest", "net/textproto: method (*Conn) EndRequest(uint)"],
  ["textproto.Conn.EndResponse", "net/textproto: method (*Conn) EndResponse(uint)"],
  ["textproto.Conn.Next", "net/textproto: method (*Conn) Next() uint"],
  ["textproto.Conn.PrintfLine", "net/textproto: method (*Conn) PrintfLine(string: ...interface{}) error"],
  ["textproto.Conn.ReadCodeLine", "net/textproto: method (*Conn) ReadCodeLine(int) (int: string: error)"],
  ["textproto.Conn.ReadContinuedLine", "net/textproto: method (*Conn) ReadContinuedLine() (string: error)"],
  ["textproto.Conn.ReadContinuedLineBytes", "net/textproto: method (*Conn) ReadContinuedLineBytes() ([]byte: error)"],
  ["textproto.Conn.ReadDotBytes", "net/textproto: method (*Conn) ReadDotBytes() ([]byte: error)"],
  ["textproto.Conn.ReadDotLines", "net/textproto: method (*Conn) ReadDotLines() ([]string: error)"],
  ["textproto.Conn.ReadLine", "net/textproto: method (*Conn) ReadLine() (string: error)"],
  ["textproto.Conn.ReadLineBytes", "net/textproto: method (*Conn) ReadLineBytes() ([]byte: error)"],
  ["textproto.Conn.ReadMIMEHeader", "net/textproto: method (*Conn) ReadMIMEHeader() (MIMEHeader: error)"],
  ["textproto.Conn.ReadResponse", "net/textproto: method (*Conn) ReadResponse(int) (int: string: error)"],
  ["textproto.Conn.StartRequest", "net/textproto: method (*Conn) StartRequest(uint)"],
  ["textproto.Conn.StartResponse", "net/textproto: method (*Conn) StartResponse(uint)"],
  ["textproto.Error.Error", "net/textproto: method (*Error) Error() string"],
  ["textproto.Pipeline.EndRequest", "net/textproto: method (*Pipeline) EndRequest(uint)"],
  ["textproto.Pipeline.EndResponse", "net/textproto: method (*Pipeline) EndResponse(uint)"],
  ["textproto.Pipeline.Next", "net/textproto: method (*Pipeline) Next() uint"],
  ["textproto.Pipeline.StartRequest", "net/textproto: method (*Pipeline) StartRequest(uint)"],
  ["textproto.Pipeline.StartResponse", "net/textproto: method (*Pipeline) StartResponse(uint)"],
  ["textproto.Reader.DotReader", "net/textproto: method (*Reader) DotReader() io.Reader"],
  ["textproto.Reader.ReadCodeLine", "net/textproto: method (*Reader) ReadCodeLine(int) (int: string: error)"],
  ["textproto.Reader.ReadContinuedLine", "net/textproto: method (*Reader) ReadContinuedLine() (string: error)"],
  ["textproto.Reader.ReadContinuedLineBytes", "net/textproto: method (*Reader) ReadContinuedLineBytes() ([]byte: error)"],
  ["textproto.Reader.ReadDotBytes", "net/textproto: method (*Reader) ReadDotBytes() ([]byte: error)"],
  ["textproto.Reader.ReadDotLines", "net/textproto: method (*Reader) ReadDotLines() ([]string: error)"],
  ["textproto.Reader.ReadLine", "net/textproto: method (*Reader) ReadLine() (string: error)"],
  ["textproto.Reader.ReadLineBytes", "net/textproto: method (*Reader) ReadLineBytes() ([]byte: error)"],
  ["textproto.Reader.ReadMIMEHeader", "net/textproto: method (*Reader) ReadMIMEHeader() (MIMEHeader: error)"],
  ["textproto.Reader.ReadResponse", "net/textproto: method (*Reader) ReadResponse(int) (int: string: error)"],
  ["textproto.Writer.DotWriter", "net/textproto: method (*Writer) DotWriter() io.WriteCloser"],
  ["textproto.Writer.PrintfLine", "net/textproto: method (*Writer) PrintfLine(string: ...interface{}) error"],
  ["textproto.MIMEHeader.Add", "net/textproto: method (MIMEHeader) Add(string)"],
  ["textproto.MIMEHeader.Del", "net/textproto: method (MIMEHeader) Del(string)"],
  ["textproto.MIMEHeader.Get", "net/textproto: method (MIMEHeader) Get(string) string"],
  ["textproto.MIMEHeader.Set", "net/textproto: method (MIMEHeader) Set(string)"],
  ["textproto.ProtocolError.Error", "net/textproto: method (ProtocolError) Error() string"],
  ["textproto.Conn", "net/textproto: type Conn struct"],
  ["textproto.Error", "net/textproto: type Error struct"],
  ["textproto.MIMEHeader map[string][]string", "net/textproto: type MIMEHeader map[string][]string"],
  ["textproto.Pipeline", "net/textproto: type Pipeline struct"],
  ["textproto.ProtocolError", "net/textproto: type ProtocolError string"],
  ["textproto.Reader", "net/textproto: type Reader struct"],
  ["textproto.Writer", "net/textproto: type Writer struct"],
  ["url", "import \"net/url\""],
  ["url.Parse", "net/url: func Parse(string) (*URL: error)"],
  ["url.ParseQuery", "net/url: func ParseQuery(string) (Values: error)"],
  ["url.ParseRequestURI", "net/url: func ParseRequestURI(string) (*URL: error)"],
  ["url.QueryEscape", "net/url: func QueryEscape(string) string"],
  ["url.QueryUnescape", "net/url: func QueryUnescape(string) (string: error)"],
  ["url.User", "net/url: func User(string) *Userinfo"],
  ["url.UserPassword", "net/url: func UserPassword(string) *Userinfo"],
  ["url.Error.Error", "net/url: method (*Error) Error() string"],
  ["url.URL.IsAbs", "net/url: method (*URL) IsAbs() bool"],
  ["url.URL.Parse", "net/url: method (*URL) Parse(string) (*URL: error)"],
  ["url.URL.Query", "net/url: method (*URL) Query() Values"],
  ["url.URL.RequestURI", "net/url: method (*URL) RequestURI() string"],
  ["url.URL.ResolveReference", "net/url: method (*URL) ResolveReference(*URL) *URL"],
  ["url.URL.String", "net/url: method (*URL) String() string"],
  ["url.Userinfo.Password", "net/url: method (*Userinfo) Password() (string: bool)"],
  ["url.Userinfo.String", "net/url: method (*Userinfo) String() string"],
  ["url.Userinfo.Username", "net/url: method (*Userinfo) Username() string"],
  ["url.EscapeError.Error", "net/url: method (EscapeError) Error() string"],
  ["url.Values.Add", "net/url: method (Values) Add(string)"],
  ["url.Values.Del", "net/url: method (Values) Del(string)"],
  ["url.Values.Encode", "net/url: method (Values) Encode() string"],
  ["url.Values.Get", "net/url: method (Values) Get(string) string"],
  ["url.Values.Set", "net/url: method (Values) Set(string)"],
  ["url.Error", "net/url: type Error struct"],
  ["url.EscapeError", "net/url: type EscapeError string"],
  ["url.URL", "net/url: type URL struct"],
  ["url.Userinfo", "net/url: type Userinfo struct"],
  ["url.Values map[string][]string", "net/url: type Values map[string][]string"],
  ["os", "import \"os\""],
  ["os.DevNull", "os: const DevNull ideal-string"],
  ["os.ModeAppend", "os: const ModeAppend FileMode"],
  ["os.ModeCharDevice", "os: const ModeCharDevice FileMode"],
  ["os.ModeDevice", "os: const ModeDevice FileMode"],
  ["os.ModeDir", "os: const ModeDir FileMode"],
  ["os.ModeExclusive", "os: const ModeExclusive FileMode"],
  ["os.ModeNamedPipe", "os: const ModeNamedPipe FileMode"],
  ["os.ModePerm", "os: const ModePerm FileMode"],
  ["os.ModeSetgid", "os: const ModeSetgid FileMode"],
  ["os.ModeSetuid", "os: const ModeSetuid FileMode"],
  ["os.ModeSocket", "os: const ModeSocket FileMode"],
  ["os.ModeSticky", "os: const ModeSticky FileMode"],
  ["os.ModeSymlink", "os: const ModeSymlink FileMode"],
  ["os.ModeTemporary", "os: const ModeTemporary FileMode"],
  ["os.ModeType", "os: const ModeType FileMode"],
  ["os.O_APPEND", "os: const O_APPEND int"],
  ["os.O_CREATE", "os: const O_CREATE int"],
  ["os.O_EXCL", "os: const O_EXCL int"],
  ["os.O_RDONLY", "os: const O_RDONLY int"],
  ["os.O_RDWR", "os: const O_RDWR int"],
  ["os.O_SYNC", "os: const O_SYNC int"],
  ["os.O_TRUNC", "os: const O_TRUNC int"],
  ["os.O_WRONLY", "os: const O_WRONLY int"],
  ["os.PathListSeparator", "os: const PathListSeparator ideal-char"],
  ["os.PathSeparator", "os: const PathSeparator ideal-char"],
  ["os.SEEK_CUR", "os: const SEEK_CUR int"],
  ["os.SEEK_END", "os: const SEEK_END int"],
  ["os.SEEK_SET", "os: const SEEK_SET int"],
  ["os.Chdir", "os: func Chdir(string) error"],
  ["os.Chmod", "os: func Chmod(string: FileMode) error"],
  ["os.Chown", "os: func Chown(string: int) error"],
  ["os.Chtimes", "os: func Chtimes(string: time.Time: time.Time) error"],
  ["os.Clearenv", "os: func Clearenv()"],
  ["os.Create", "os: func Create(string) (*File: error)"],
  ["os.Environ", "os: func Environ() []string"],
  ["os.Exit", "os: func Exit(int)"],
  ["os.Expand", "os: func Expand(string: func(string) string) string"],
  ["os.ExpandEnv", "os: func ExpandEnv(string) string"],
  ["os.FindProcess", "os: func FindProcess(int) (*Process: error)"],
  ["os.Getegid", "os: func Getegid() int"],
  ["os.Getenv", "os: func Getenv(string) string"],
  ["os.Geteuid", "os: func Geteuid() int"],
  ["os.Getgid", "os: func Getgid() int"],
  ["os.Getgroups", "os: func Getgroups() ([]int: error)"],
  ["os.Getpagesize", "os: func Getpagesize() int"],
  ["os.Getpid", "os: func Getpid() int"],
  ["os.Getppid", "os: func Getppid() int"],
  ["os.Getuid", "os: func Getuid() int"],
  ["os.Getwd", "os: func Getwd() (string: error)"],
  ["os.Hostname", "os: func Hostname() (string: error)"],
  ["os.IsExist", "os: func IsExist(error) bool"],
  ["os.IsNotExist", "os: func IsNotExist(error) bool"],
  ["os.IsPathSeparator", "os: func IsPathSeparator(uint8) bool"],
  ["os.IsPermission", "os: func IsPermission(error) bool"],
  ["os.Lchown", "os: func Lchown(string: int) error"],
  ["os.Link", "os: func Link(string) error"],
  ["os.Lstat", "os: func Lstat(string) (FileInfo: error)"],
  ["os.Mkdir", "os: func Mkdir(string: FileMode) error"],
  ["os.MkdirAll", "os: func MkdirAll(string: FileMode) error"],
  ["os.NewFile", "os: func NewFile(uintptr: string) *File"],
  ["os.NewSyscallError", "os: func NewSyscallError(string: error) error"],
  ["os.Open", "os: func Open(string) (*File: error)"],
  ["os.OpenFile", "os: func OpenFile(string: int: FileMode) (*File: error)"],
  ["os.Pipe", "os: func Pipe() (*File: *File: error)"],
  ["os.Readlink", "os: func Readlink(string) (string: error)"],
  ["os.Remove", "os: func Remove(string) error"],
  ["os.RemoveAll", "os: func RemoveAll(string) error"],
  ["os.Rename", "os: func Rename(string) error"],
  ["os.SameFile", "os: func SameFile(FileInfo) bool"],
  ["os.Setenv", "os: func Setenv(string) error"],
  ["os.StartProcess", "os: func StartProcess(string: []string: *ProcAttr) (*Process: error)"],
  ["os.Stat", "os: func Stat(string) (FileInfo: error)"],
  ["os.Symlink", "os: func Symlink(string) error"],
  ["os.TempDir", "os: func TempDir() string"],
  ["os.Truncate", "os: func Truncate(string: int64) error"],
  ["os.File.Chdir", "os: method (*File) Chdir() error"],
  ["os.File.Chmod", "os: method (*File) Chmod(FileMode) error"],
  ["os.File.Chown", "os: method (*File) Chown(int) error"],
  ["os.File.Close", "os: method (*File) Close() error"],
  ["os.File.Fd", "os: method (*File) Fd() uintptr"],
  ["os.File.Name", "os: method (*File) Name() string"],
  ["os.File.Read", "os: method (*File) Read([]byte) (int: error)"],
  ["os.File.ReadAt", "os: method (*File) ReadAt([]byte: int64) (int: error)"],
  ["os.File.Readdir", "os: method (*File) Readdir(int) ([]FileInfo: error)"],
  ["os.File.Readdirnames", "os: method (*File) Readdirnames(int) ([]string: error)"],
  ["os.File.Seek", "os: method (*File) Seek(int64: int) (int64: error)"],
  ["os.File.Stat", "os: method (*File) Stat() (FileInfo: error)"],
  ["os.File.Sync", "os: method (*File) Sync() error"],
  ["os.File.Truncate", "os: method (*File) Truncate(int64) error"],
  ["os.File.Write", "os: method (*File) Write([]byte) (int: error)"],
  ["os.File.WriteAt", "os: method (*File) WriteAt([]byte: int64) (int: error)"],
  ["os.File.WriteString", "os: method (*File) WriteString(string) (int: error)"],
  ["os.LinkError.Error", "os: method (*LinkError) Error() string"],
  ["os.PathError.Error", "os: method (*PathError) Error() string"],
  ["os.Process.Kill", "os: method (*Process) Kill() error"],
  ["os.Process.Release", "os: method (*Process) Release() error"],
  ["os.Process.Signal", "os: method (*Process) Signal(Signal) error"],
  ["os.Process.Wait", "os: method (*Process) Wait() (*ProcessState: error)"],
  ["os.ProcessState.Exited", "os: method (*ProcessState) Exited() bool"],
  ["os.ProcessState.Pid", "os: method (*ProcessState) Pid() int"],
  ["os.ProcessState.String", "os: method (*ProcessState) String() string"],
  ["os.ProcessState.Success", "os: method (*ProcessState) Success() bool"],
  ["os.ProcessState.Sys", "os: method (*ProcessState) Sys() interface{}"],
  ["os.ProcessState.SysUsage", "os: method (*ProcessState) SysUsage() interface{}"],
  ["os.ProcessState.SystemTime", "os: method (*ProcessState) SystemTime() time.Duration"],
  ["os.ProcessState.UserTime", "os: method (*ProcessState) UserTime() time.Duration"],
  ["os.SyscallError.Error", "os: method (*SyscallError) Error() string"],
  ["os.FileMode.IsDir", "os: method (FileMode) IsDir() bool"],
  ["os.FileMode.Perm", "os: method (FileMode) Perm() FileMode"],
  ["os.FileMode.String", "os: method (FileMode) String() string"],
  ["os.File", "os: type File struct"],
  ["os.FileInfo", "os: type FileInfo interface { IsDir: ModTime: Mode: Name: Size: Sys }"],
  ["os.FileMode", "os: type FileMode uint32"],
  ["os.LinkError", "os: type LinkError struct"],
  ["os.PathError", "os: type PathError struct"],
  ["os.ProcAttr", "os: type ProcAttr struct"],
  ["os.Process", "os: type Process struct"],
  ["os.ProcessState", "os: type ProcessState struct"],
  ["os.Signal", "os: type Signal interface { Signal: String }"],
  ["os.SyscallError", "os: type SyscallError struct"],
  ["exec", "import \"os/exec\""],
  ["exec.Command", "os/exec: func Command(string: ...string) *Cmd"],
  ["exec.LookPath", "os/exec: func LookPath(string) (string: error)"],
  ["exec.Cmd.CombinedOutput", "os/exec: method (*Cmd) CombinedOutput() ([]byte: error)"],
  ["exec.Cmd.Output", "os/exec: method (*Cmd) Output() ([]byte: error)"],
  ["exec.Cmd.Run", "os/exec: method (*Cmd) Run() error"],
  ["exec.Cmd.Start", "os/exec: method (*Cmd) Start() error"],
  ["exec.Cmd.StderrPipe", "os/exec: method (*Cmd) StderrPipe() (io.ReadCloser: error)"],
  ["exec.Cmd.StdinPipe", "os/exec: method (*Cmd) StdinPipe() (io.WriteCloser: error)"],
  ["exec.Cmd.StdoutPipe", "os/exec: method (*Cmd) StdoutPipe() (io.ReadCloser: error)"],
  ["exec.Cmd.Wait", "os/exec: method (*Cmd) Wait() error"],
  ["exec.Error.Error", "os/exec: method (*Error) Error() string"],
  ["exec.ExitError.Error", "os/exec: method (*ExitError) Error() string"],
  ["exec.Cmd", "os/exec: type Cmd struct"],
  ["exec.Error", "os/exec: type Error struct"],
  ["exec.ExitError", "os/exec: type ExitError struct"],
  ["signal", "import \"os/signal\""],
  ["signal.Notify", "os/signal: func Notify(chan<- os.Signal: ...os.Signal)"],
  ["user", "import \"os/user\""],
  ["user.Current", "os/user: func Current() (*User: error)"],
  ["user.Lookup", "os/user: func Lookup(string) (*User: error)"],
  ["user.LookupId", "os/user: func LookupId(string) (*User: error)"],
  ["user.UnknownUserError.Error", "os/user: method (UnknownUserError) Error() string"],
  ["user.UnknownUserIdError.Error", "os/user: method (UnknownUserIdError) Error() string"],
  ["user.UnknownUserError", "os/user: type UnknownUserError string"],
  ["user.UnknownUserIdError", "os/user: type UnknownUserIdError int"],
  ["user.User", "os/user: type User struct"],
  ["path", "import \"path\""],
  ["path.Base", "path: func Base(string) string"],
  ["path.Clean", "path: func Clean(string) string"],
  ["path.Dir", "path: func Dir(string) string"],
  ["path.Ext", "path: func Ext(string) string"],
  ["path.IsAbs", "path: func IsAbs(string) bool"],
  ["path.Join", "path: func Join(...string) string"],
  ["path.Match", "path: func Match(string) (bool: error)"],
  ["path.Split", "path: func Split(string) string"],
  ["filepath", "import \"path/filepath\""],
  ["filepath.ListSeparator", "path/filepath: const ListSeparator ideal-char"],
  ["filepath.Separator", "path/filepath: const Separator ideal-char"],
  ["filepath.Abs", "path/filepath: func Abs(string) (string: error)"],
  ["filepath.Base", "path/filepath: func Base(string) string"],
  ["filepath.Clean", "path/filepath: func Clean(string) string"],
  ["filepath.Dir", "path/filepath: func Dir(string) string"],
  ["filepath.EvalSymlinks", "path/filepath: func EvalSymlinks(string) (string: error)"],
  ["filepath.Ext", "path/filepath: func Ext(string) string"],
  ["filepath.FromSlash", "path/filepath: func FromSlash(string) string"],
  ["filepath.Glob", "path/filepath: func Glob(string) ([]string: error)"],
  ["filepath.HasPrefix", "path/filepath: func HasPrefix(string) bool"],
  ["filepath.IsAbs", "path/filepath: func IsAbs(string) bool"],
  ["filepath.Join", "path/filepath: func Join(...string) string"],
  ["filepath.Match", "path/filepath: func Match(string) (bool: error)"],
  ["filepath.Rel", "path/filepath: func Rel(string) (string: error)"],
  ["filepath.Split", "path/filepath: func Split(string) string"],
  ["filepath.SplitList", "path/filepath: func SplitList(string) []string"],
  ["filepath.ToSlash", "path/filepath: func ToSlash(string) string"],
  ["filepath.VolumeName", "path/filepath: func VolumeName(string) string"],
  ["filepath.Walk", "path/filepath: func Walk(string: WalkFunc) error"],
  ["filepath.WalkFunc func", "path/filepath: type WalkFunc func(path string: info os.FileInfo: err error) error"],
  ["reflect", "import \"reflect\""],
  ["reflect.Array", "reflect: const Array Kind"],
  ["reflect.Bool", "reflect: const Bool Kind"],
  ["reflect.BothDir", "reflect: const BothDir ChanDir"],
  ["reflect.Chan", "reflect: const Chan Kind"],
  ["reflect.Complex128", "reflect: const Complex128 Kind"],
  ["reflect.Complex64", "reflect: const Complex64 Kind"],
  ["reflect.Float32", "reflect: const Float32 Kind"],
  ["reflect.Float64", "reflect: const Float64 Kind"],
  ["reflect.Func", "reflect: const Func Kind"],
  ["reflect.Int", "reflect: const Int Kind"],
  ["reflect.Int16", "reflect: const Int16 Kind"],
  ["reflect.Int32", "reflect: const Int32 Kind"],
  ["reflect.Int64", "reflect: const Int64 Kind"],
  ["reflect.Int8", "reflect: const Int8 Kind"],
  ["reflect.Interface", "reflect: const Interface Kind"],
  ["reflect.Invalid", "reflect: const Invalid Kind"],
  ["reflect.Map", "reflect: const Map Kind"],
  ["reflect.Ptr", "reflect: const Ptr Kind"],
  ["reflect.RecvDir", "reflect: const RecvDir ChanDir"],
  ["reflect.SendDir", "reflect: const SendDir ChanDir"],
  ["reflect.Slice", "reflect: const Slice Kind"],
  ["reflect.String", "reflect: const String Kind"],
  ["reflect.Struct", "reflect: const Struct Kind"],
  ["reflect.Uint", "reflect: const Uint Kind"],
  ["reflect.Uint16", "reflect: const Uint16 Kind"],
  ["reflect.Uint32", "reflect: const Uint32 Kind"],
  ["reflect.Uint64", "reflect: const Uint64 Kind"],
  ["reflect.Uint8", "reflect: const Uint8 Kind"],
  ["reflect.Uintptr", "reflect: const Uintptr Kind"],
  ["reflect.UnsafePointer", "reflect: const UnsafePointer Kind"],
  ["reflect.Append", "reflect: func Append(Value: ...Value) Value"],
  ["reflect.AppendSlice", "reflect: func AppendSlice(Value) Value"],
  ["reflect.Copy", "reflect: func Copy(Value) int"],
  ["reflect.DeepEqual", "reflect: func DeepEqual(interface{}) bool"],
  ["reflect.Indirect", "reflect: func Indirect(Value) Value"],
  ["reflect.MakeChan", "reflect: func MakeChan(Type: int) Value"],
  ["reflect.MakeMap", "reflect: func MakeMap(Type) Value"],
  ["reflect.MakeSlice", "reflect: func MakeSlice(Type: int) Value"],
  ["reflect.New", "reflect: func New(Type) Value"],
  ["reflect.NewAt", "reflect: func NewAt(Type: unsafe.Pointer) Value"],
  ["reflect.PtrTo", "reflect: func PtrTo(Type) Type"],
  ["reflect.TypeOf", "reflect: func TypeOf(interface{}) Type"],
  ["reflect.ValueOf", "reflect: func ValueOf(interface{}) Value"],
  ["reflect.Zero", "reflect: func Zero(Type) Value"],
  ["reflect.ValueError.Error", "reflect: method (*ValueError) Error() string"],
  ["reflect.ChanDir.String", "reflect: method (ChanDir) String() string"],
  ["reflect.Kind.String", "reflect: method (Kind) String() string"],
  ["reflect.StructTag.Get", "reflect: method (StructTag) Get(string) string"],
  ["reflect.Value.Addr", "reflect: method (Value) Addr() Value"],
  ["reflect.Value.Bool", "reflect: method (Value) Bool() bool"],
  ["reflect.Value.Bytes", "reflect: method (Value) Bytes() []byte"],
  ["reflect.Value.Call", "reflect: method (Value) Call([]Value) []Value"],
  ["reflect.Value.CallSlice", "reflect: method (Value) CallSlice([]Value) []Value"],
  ["reflect.Value.CanAddr", "reflect: method (Value) CanAddr() bool"],
  ["reflect.Value.CanInterface", "reflect: method (Value) CanInterface() bool"],
  ["reflect.Value.CanSet", "reflect: method (Value) CanSet() bool"],
  ["reflect.Value.Cap", "reflect: method (Value) Cap() int"],
  ["reflect.Value.Close", "reflect: method (Value) Close()"],
  ["reflect.Value.Complex", "reflect: method (Value) Complex() complex128"],
  ["reflect.Value.Elem", "reflect: method (Value) Elem() Value"],
  ["reflect.Value.Field", "reflect: method (Value) Field(int) Value"],
  ["reflect.Value.FieldByIndex", "reflect: method (Value) FieldByIndex([]int) Value"],
  ["reflect.Value.FieldByName", "reflect: method (Value) FieldByName(string) Value"],
  ["reflect.Value.FieldByNameFunc", "reflect: method (Value) FieldByNameFunc(func(string) bool) Value"],
  ["reflect.Value.Float", "reflect: method (Value) Float() float64"],
  ["reflect.Value.Index", "reflect: method (Value) Index(int) Value"],
  ["reflect.Value.Int", "reflect: method (Value) Int() int64"],
  ["reflect.Value.Interface", "reflect: method (Value) Interface() interface{}"],
  ["reflect.Value.InterfaceData", "reflect: method (Value) InterfaceData() [2]uintptr"],
  ["reflect.Value.IsNil", "reflect: method (Value) IsNil() bool"],
  ["reflect.Value.IsValid", "reflect: method (Value) IsValid() bool"],
  ["reflect.Value.Kind", "reflect: method (Value) Kind() Kind"],
  ["reflect.Value.Len", "reflect: method (Value) Len() int"],
  ["reflect.Value.MapIndex", "reflect: method (Value) MapIndex(Value) Value"],
  ["reflect.Value.MapKeys", "reflect: method (Value) MapKeys() []Value"],
  ["reflect.Value.Method", "reflect: method (Value) Method(int) Value"],
  ["reflect.Value.MethodByName", "reflect: method (Value) MethodByName(string) Value"],
  ["reflect.Value.NumField", "reflect: method (Value) NumField() int"],
  ["reflect.Value.NumMethod", "reflect: method (Value) NumMethod() int"],
  ["reflect.Value.OverflowComplex", "reflect: method (Value) OverflowComplex(complex128) bool"],
  ["reflect.Value.OverflowFloat", "reflect: method (Value) OverflowFloat(float64) bool"],
  ["reflect.Value.OverflowInt", "reflect: method (Value) OverflowInt(int64) bool"],
  ["reflect.Value.OverflowUint", "reflect: method (Value) OverflowUint(uint64) bool"],
  ["reflect.Value.Pointer", "reflect: method (Value) Pointer() uintptr"],
  ["reflect.Value.Recv", "reflect: method (Value) Recv() (Value: bool)"],
  ["reflect.Value.Send", "reflect: method (Value) Send(Value)"],
  ["reflect.Value.Set", "reflect: method (Value) Set(Value)"],
  ["reflect.Value.SetBool", "reflect: method (Value) SetBool(bool)"],
  ["reflect.Value.SetBytes", "reflect: method (Value) SetBytes([]byte)"],
  ["reflect.Value.SetComplex", "reflect: method (Value) SetComplex(complex128)"],
  ["reflect.Value.SetFloat", "reflect: method (Value) SetFloat(float64)"],
  ["reflect.Value.SetInt", "reflect: method (Value) SetInt(int64)"],
  ["reflect.Value.SetLen", "reflect: method (Value) SetLen(int)"],
  ["reflect.Value.SetMapIndex", "reflect: method (Value) SetMapIndex(Value)"],
  ["reflect.Value.SetPointer", "reflect: method (Value) SetPointer(unsafe.Pointer)"],
  ["reflect.Value.SetString", "reflect: method (Value) SetString(string)"],
  ["reflect.Value.SetUint", "reflect: method (Value) SetUint(uint64)"],
  ["reflect.Value.Slice", "reflect: method (Value) Slice(int) Value"],
  ["reflect.Value.String", "reflect: method (Value) String() string"],
  ["reflect.Value.TryRecv", "reflect: method (Value) TryRecv() (Value: bool)"],
  ["reflect.Value.TrySend", "reflect: method (Value) TrySend(Value) bool"],
  ["reflect.Value.Type", "reflect: method (Value) Type() Type"],
  ["reflect.Value.Uint", "reflect: method (Value) Uint() uint64"],
  ["reflect.Value.UnsafeAddr", "reflect: method (Value) UnsafeAddr() uintptr"],
  ["reflect.ChanDir", "reflect: type ChanDir int"],
  ["reflect.Kind", "reflect: type Kind uint"],
  ["reflect.Method", "reflect: type Method struct"],
  ["reflect.SliceHeader", "reflect: type SliceHeader struct"],
  ["reflect.StringHeader", "reflect: type StringHeader struct"],
  ["reflect.StructField", "reflect: type StructField struct"],
  ["reflect.StructTag", "reflect: type StructTag string"],
  ["reflect.Type", "reflect: type Type interface { Align: AssignableTo: Bits: ChanDir: Elem: Field: FieldAlign: FieldByIndex: FieldByName: FieldByNameFunc: Implements: In: IsVariadic: Key: Kind: Len: Method: MethodByName: Name: NumField: NumIn: NumMethod: NumOut: Out: PkgPath: Size: String }"],
  ["reflect.Value", "reflect: type Value struct"],
  ["reflect.ValueError", "reflect: type ValueError struct"],
  ["regexp", "import \"regexp\""],
  ["regexp.Compile", "regexp: func Compile(string) (*Regexp: error)"],
  ["regexp.CompilePOSIX", "regexp: func CompilePOSIX(string) (*Regexp: error)"],
  ["regexp.Match", "regexp: func Match(string: []byte) (bool: error)"],
  ["regexp.MatchReader", "regexp: func MatchReader(string: io.RuneReader) (bool: error)"],
  ["regexp.MatchString", "regexp: func MatchString(string: string) (bool: error)"],
  ["regexp.MustCompile", "regexp: func MustCompile(string) *Regexp"],
  ["regexp.MustCompilePOSIX", "regexp: func MustCompilePOSIX(string) *Regexp"],
  ["regexp.QuoteMeta", "regexp: func QuoteMeta(string) string"],
  ["regexp.Regexp.Expand", "regexp: method (*Regexp) Expand([]byte: []byte: []byte: []int) []byte"],
  ["regexp.Regexp.ExpandString", "regexp: method (*Regexp) ExpandString([]byte: string: string: []int) []byte"],
  ["regexp.Regexp.Find", "regexp: method (*Regexp) Find([]byte) []byte"],
  ["regexp.Regexp.FindAll", "regexp: method (*Regexp) FindAll([]byte: int) [][]byte"],
  ["regexp.Regexp.FindAllIndex", "regexp: method (*Regexp) FindAllIndex([]byte: int) [][]int"],
  ["regexp.Regexp.FindAllString", "regexp: method (*Regexp) FindAllString(string: int) []string"],
  ["regexp.Regexp.FindAllStringIndex", "regexp: method (*Regexp) FindAllStringIndex(string: int) [][]int"],
  ["regexp.Regexp.FindAllStringSubmatch", "regexp: method (*Regexp) FindAllStringSubmatch(string: int) [][]string"],
  ["regexp.Regexp.FindAllStringSubmatchIndex", "regexp: method (*Regexp) FindAllStringSubmatchIndex(string: int) [][]int"],
  ["regexp.Regexp.FindAllSubmatch", "regexp: method (*Regexp) FindAllSubmatch([]byte: int) [][][]byte"],
  ["regexp.Regexp.FindAllSubmatchIndex", "regexp: method (*Regexp) FindAllSubmatchIndex([]byte: int) [][]int"],
  ["regexp.Regexp.FindIndex", "regexp: method (*Regexp) FindIndex([]byte) []int"],
  ["regexp.Regexp.FindReaderIndex", "regexp: method (*Regexp) FindReaderIndex(io.RuneReader) []int"],
  ["regexp.Regexp.FindReaderSubmatchIndex", "regexp: method (*Regexp) FindReaderSubmatchIndex(io.RuneReader) []int"],
  ["regexp.Regexp.FindString", "regexp: method (*Regexp) FindString(string) string"],
  ["regexp.Regexp.FindStringIndex", "regexp: method (*Regexp) FindStringIndex(string) []int"],
  ["regexp.Regexp.FindStringSubmatch", "regexp: method (*Regexp) FindStringSubmatch(string) []string"],
  ["regexp.Regexp.FindStringSubmatchIndex", "regexp: method (*Regexp) FindStringSubmatchIndex(string) []int"],
  ["regexp.Regexp.FindSubmatch", "regexp: method (*Regexp) FindSubmatch([]byte) [][]byte"],
  ["regexp.Regexp.FindSubmatchIndex", "regexp: method (*Regexp) FindSubmatchIndex([]byte) []int"],
  ["regexp.Regexp.LiteralPrefix", "regexp: method (*Regexp) LiteralPrefix() (string: bool)"],
  ["regexp.Regexp.Match", "regexp: method (*Regexp) Match([]byte) bool"],
  ["regexp.Regexp.MatchReader", "regexp: method (*Regexp) MatchReader(io.RuneReader) bool"],
  ["regexp.Regexp.MatchString", "regexp: method (*Regexp) MatchString(string) bool"],
  ["regexp.Regexp.NumSubexp", "regexp: method (*Regexp) NumSubexp() int"],
  ["regexp.Regexp.ReplaceAll", "regexp: method (*Regexp) ReplaceAll([]byte) []byte"],
  ["regexp.Regexp.ReplaceAllFunc", "regexp: method (*Regexp) ReplaceAllFunc([]byte: func([]byte) []byte) []byte"],
  ["regexp.Regexp.ReplaceAllLiteral", "regexp: method (*Regexp) ReplaceAllLiteral([]byte) []byte"],
  ["regexp.Regexp.ReplaceAllLiteralString", "regexp: method (*Regexp) ReplaceAllLiteralString(string) string"],
  ["regexp.Regexp.ReplaceAllString", "regexp: method (*Regexp) ReplaceAllString(string) string"],
  ["regexp.Regexp.ReplaceAllStringFunc", "regexp: method (*Regexp) ReplaceAllStringFunc(string: func(string) string) string"],
  ["regexp.Regexp.String", "regexp: method (*Regexp) String() string"],
  ["regexp.Regexp.SubexpNames", "regexp: method (*Regexp) SubexpNames() []string"],
  ["regexp.Regexp", "regexp: type Regexp struct"],
  ["syntax", "import \"regexp/syntax\""],
  ["syntax.ClassNL", "regexp/syntax: const ClassNL Flags"],
  ["syntax.DotNL", "regexp/syntax: const DotNL Flags"],
  ["syntax.EmptyBeginLine", "regexp/syntax: const EmptyBeginLine EmptyOp"],
  ["syntax.EmptyBeginText", "regexp/syntax: const EmptyBeginText EmptyOp"],
  ["syntax.EmptyEndLine", "regexp/syntax: const EmptyEndLine EmptyOp"],
  ["syntax.EmptyEndText", "regexp/syntax: const EmptyEndText EmptyOp"],
  ["syntax.EmptyNoWordBoundary", "regexp/syntax: const EmptyNoWordBoundary EmptyOp"],
  ["syntax.EmptyWordBoundary", "regexp/syntax: const EmptyWordBoundary EmptyOp"],
  ["syntax.ErrInternalError", "regexp/syntax: const ErrInternalError ErrorCode"],
  ["syntax.ErrInvalidCharClass", "regexp/syntax: const ErrInvalidCharClass ErrorCode"],
  ["syntax.ErrInvalidCharRange", "regexp/syntax: const ErrInvalidCharRange ErrorCode"],
  ["syntax.ErrInvalidEscape", "regexp/syntax: const ErrInvalidEscape ErrorCode"],
  ["syntax.ErrInvalidNamedCapture", "regexp/syntax: const ErrInvalidNamedCapture ErrorCode"],
  ["syntax.ErrInvalidPerlOp", "regexp/syntax: const ErrInvalidPerlOp ErrorCode"],
  ["syntax.ErrInvalidRepeatOp", "regexp/syntax: const ErrInvalidRepeatOp ErrorCode"],
  ["syntax.ErrInvalidRepeatSize", "regexp/syntax: const ErrInvalidRepeatSize ErrorCode"],
  ["syntax.ErrInvalidUTF8", "regexp/syntax: const ErrInvalidUTF8 ErrorCode"],
  ["syntax.ErrMissingBracket", "regexp/syntax: const ErrMissingBracket ErrorCode"],
  ["syntax.ErrMissingParen", "regexp/syntax: const ErrMissingParen ErrorCode"],
  ["syntax.ErrMissingRepeatArgument", "regexp/syntax: const ErrMissingRepeatArgument ErrorCode"],
  ["syntax.ErrTrailingBackslash", "regexp/syntax: const ErrTrailingBackslash ErrorCode"],
  ["syntax.FoldCase", "regexp/syntax: const FoldCase Flags"],
  ["syntax.InstAlt", "regexp/syntax: const InstAlt InstOp"],
  ["syntax.InstAltMatch", "regexp/syntax: const InstAltMatch InstOp"],
  ["syntax.InstCapture", "regexp/syntax: const InstCapture InstOp"],
  ["syntax.InstEmptyWidth", "regexp/syntax: const InstEmptyWidth InstOp"],
  ["syntax.InstFail", "regexp/syntax: const InstFail InstOp"],
  ["syntax.InstMatch", "regexp/syntax: const InstMatch InstOp"],
  ["syntax.InstNop", "regexp/syntax: const InstNop InstOp"],
  ["syntax.InstRune", "regexp/syntax: const InstRune InstOp"],
  ["syntax.InstRune1", "regexp/syntax: const InstRune1 InstOp"],
  ["syntax.InstRuneAny", "regexp/syntax: const InstRuneAny InstOp"],
  ["syntax.InstRuneAnyNotNL", "regexp/syntax: const InstRuneAnyNotNL InstOp"],
  ["syntax.Literal", "regexp/syntax: const Literal Flags"],
  ["syntax.MatchNL", "regexp/syntax: const MatchNL Flags"],
  ["syntax.NonGreedy", "regexp/syntax: const NonGreedy Flags"],
  ["syntax.OneLine", "regexp/syntax: const OneLine Flags"],
  ["syntax.OpAlternate", "regexp/syntax: const OpAlternate Op"],
  ["syntax.OpAnyChar", "regexp/syntax: const OpAnyChar Op"],
  ["syntax.OpAnyCharNotNL", "regexp/syntax: const OpAnyCharNotNL Op"],
  ["syntax.OpBeginLine", "regexp/syntax: const OpBeginLine Op"],
  ["syntax.OpBeginText", "regexp/syntax: const OpBeginText Op"],
  ["syntax.OpCapture", "regexp/syntax: const OpCapture Op"],
  ["syntax.OpCharClass", "regexp/syntax: const OpCharClass Op"],
  ["syntax.OpConcat", "regexp/syntax: const OpConcat Op"],
  ["syntax.OpEmptyMatch", "regexp/syntax: const OpEmptyMatch Op"],
  ["syntax.OpEndLine", "regexp/syntax: const OpEndLine Op"],
  ["syntax.OpEndText", "regexp/syntax: const OpEndText Op"],
  ["syntax.OpLiteral", "regexp/syntax: const OpLiteral Op"],
  ["syntax.OpNoMatch", "regexp/syntax: const OpNoMatch Op"],
  ["syntax.OpNoWordBoundary", "regexp/syntax: const OpNoWordBoundary Op"],
  ["syntax.OpPlus", "regexp/syntax: const OpPlus Op"],
  ["syntax.OpQuest", "regexp/syntax: const OpQuest Op"],
  ["syntax.OpRepeat", "regexp/syntax: const OpRepeat Op"],
  ["syntax.OpStar", "regexp/syntax: const OpStar Op"],
  ["syntax.OpWordBoundary", "regexp/syntax: const OpWordBoundary Op"],
  ["syntax.POSIX", "regexp/syntax: const POSIX Flags"],
  ["syntax.Perl", "regexp/syntax: const Perl Flags"],
  ["syntax.PerlX", "regexp/syntax: const PerlX Flags"],
  ["syntax.Simple", "regexp/syntax: const Simple Flags"],
  ["syntax.UnicodeGroups", "regexp/syntax: const UnicodeGroups Flags"],
  ["syntax.WasDollar", "regexp/syntax: const WasDollar Flags"],
  ["syntax.Compile", "regexp/syntax: func Compile(*Regexp) (*Prog: error)"],
  ["syntax.EmptyOpContext", "regexp/syntax: func EmptyOpContext(rune) EmptyOp"],
  ["syntax.IsWordChar", "regexp/syntax: func IsWordChar(rune) bool"],
  ["syntax.Parse", "regexp/syntax: func Parse(string: Flags) (*Regexp: error)"],
  ["syntax.Error.Error", "regexp/syntax: method (*Error) Error() string"],
  ["syntax.Inst.MatchEmptyWidth", "regexp/syntax: method (*Inst) MatchEmptyWidth(rune: rune) bool"],
  ["syntax.Inst.MatchRune", "regexp/syntax: method (*Inst) MatchRune(rune) bool"],
  ["syntax.Inst.String", "regexp/syntax: method (*Inst) String() string"],
  ["syntax.Prog.Prefix", "regexp/syntax: method (*Prog) Prefix() (string: bool)"],
  ["syntax.Prog.StartCond", "regexp/syntax: method (*Prog) StartCond() EmptyOp"],
  ["syntax.Prog.String", "regexp/syntax: method (*Prog) String() string"],
  ["syntax.Regexp.CapNames", "regexp/syntax: method (*Regexp) CapNames() []string"],
  ["syntax.Regexp.Equal", "regexp/syntax: method (*Regexp) Equal(*Regexp) bool"],
  ["syntax.Regexp.MaxCap", "regexp/syntax: method (*Regexp) MaxCap() int"],
  ["syntax.Regexp.Simplify", "regexp/syntax: method (*Regexp) Simplify() *Regexp"],
  ["syntax.Regexp.String", "regexp/syntax: method (*Regexp) String() string"],
  ["syntax.ErrorCode.String", "regexp/syntax: method (ErrorCode) String() string"],
  ["syntax.EmptyOp", "regexp/syntax: type EmptyOp uint8"],
  ["syntax.Error", "regexp/syntax: type Error struct"],
  ["syntax.ErrorCode", "regexp/syntax: type ErrorCode string"],
  ["syntax.Flags", "regexp/syntax: type Flags uint16"],
  ["syntax.Inst", "regexp/syntax: type Inst struct"],
  ["syntax.InstOp", "regexp/syntax: type InstOp uint8"],
  ["syntax.Op", "regexp/syntax: type Op uint8"],
  ["syntax.Prog", "regexp/syntax: type Prog struct"],
  ["syntax.Regexp", "regexp/syntax: type Regexp struct"],
  ["runtime", "import \"runtime\""],
  ["runtime.Compiler", "runtime: const Compiler ideal-string"],
  ["runtime.GOARCH", "runtime: const GOARCH string"],
  ["runtime.GOOS", "runtime: const GOOS string"],
  ["runtime.Breakpoint", "runtime: func Breakpoint()"],
  ["runtime.CPUProfile", "runtime: func CPUProfile() []byte"],
  ["runtime.Caller", "runtime: func Caller(int) (uintptr: string: int: bool)"],
  ["runtime.Callers", "runtime: func Callers(int: []uintptr) int"],
  ["runtime.FuncForPC", "runtime: func FuncForPC(uintptr) *Func"],
  ["runtime.GC", "runtime: func GC()"],
  ["runtime.GOMAXPROCS", "runtime: func GOMAXPROCS(int) int"],
  ["runtime.GOROOT", "runtime: func GOROOT() string"],
  ["runtime.Goexit", "runtime: func Goexit()"],
  ["runtime.GoroutineProfile", "runtime: func GoroutineProfile([]StackRecord) (int: bool)"],
  ["runtime.Gosched", "runtime: func Gosched()"],
  ["runtime.LockOSThread", "runtime: func LockOSThread()"],
  ["runtime.MemProfile", "runtime: func MemProfile([]MemProfileRecord: bool) (int: bool)"],
  ["runtime.NumCPU", "runtime: func NumCPU() int"],
  ["runtime.NumCgoCall", "runtime: func NumCgoCall() int64"],
  ["runtime.NumGoroutine", "runtime: func NumGoroutine() int"],
  ["runtime.ReadMemStats", "runtime: func ReadMemStats(*MemStats)"],
  ["runtime.SetCPUProfileRate", "runtime: func SetCPUProfileRate(int)"],
  ["runtime.SetFinalizer", "runtime: func SetFinalizer(interface{})"],
  ["runtime.Stack", "runtime: func Stack([]byte: bool) int"],
  ["runtime.ThreadCreateProfile", "runtime: func ThreadCreateProfile([]StackRecord) (int: bool)"],
  ["runtime.UnlockOSThread", "runtime: func UnlockOSThread()"],
  ["runtime.Version", "runtime: func Version() string"],
  ["runtime.Func.Entry", "runtime: method (*Func) Entry() uintptr"],
  ["runtime.Func.FileLine", "runtime: method (*Func) FileLine(uintptr) (string: int)"],
  ["runtime.Func.Name", "runtime: method (*Func) Name() string"],
  ["runtime.MemProfileRecord.InUseBytes", "runtime: method (*MemProfileRecord) InUseBytes() int64"],
  ["runtime.MemProfileRecord.InUseObjects", "runtime: method (*MemProfileRecord) InUseObjects() int64"],
  ["runtime.MemProfileRecord.Stack", "runtime: method (*MemProfileRecord) Stack() []uintptr"],
  ["runtime.StackRecord.Stack", "runtime: method (*StackRecord) Stack() []uintptr"],
  ["runtime.TypeAssertionError.Error", "runtime: method (*TypeAssertionError) Error() string"],
  ["runtime.TypeAssertionError.RuntimeError", "runtime: method (*TypeAssertionError) RuntimeError()"],
  ["runtime.Error", "runtime: type Error interface { Error: RuntimeError }"],
  ["runtime.Func", "runtime: type Func struct"],
  ["runtime.MemProfileRecord", "runtime: type MemProfileRecord struct"],
  ["runtime.MemStats", "runtime: type MemStats struct"],
  ["runtime.StackRecord", "runtime: type StackRecord struct"],
  ["runtime.TypeAssertionError", "runtime: type TypeAssertionError struct"],
  ["pprof.Lookup", "runtime/pprof: func Lookup(string) *Profile"],
  ["pprof.NewProfile", "runtime/pprof: func NewProfile(string) *Profile"],
  ["pprof.Profiles", "runtime/pprof: func Profiles() []*Profile"],
  ["pprof.StartCPUProfile", "runtime/pprof: func StartCPUProfile(io.Writer) error"],
  ["pprof.StopCPUProfile", "runtime/pprof: func StopCPUProfile()"],
  ["pprof.WriteHeapProfile", "runtime/pprof: func WriteHeapProfile(io.Writer) error"],
  ["pprof.Profile.Add", "runtime/pprof: method (*Profile) Add(interface{}: int)"],
  ["pprof.Profile.Count", "runtime/pprof: method (*Profile) Count() int"],
  ["pprof.Profile.Name", "runtime/pprof: method (*Profile) Name() string"],
  ["pprof.Profile.Remove", "runtime/pprof: method (*Profile) Remove(interface{})"],
  ["pprof.Profile.WriteTo", "runtime/pprof: method (*Profile) WriteTo(io.Writer: int) error"],
  ["sort", "import \"sort\""],
  ["sort.Float64s", "sort: func Float64s([]float64)"],
  ["sort.Float64sAreSorted", "sort: func Float64sAreSorted([]float64) bool"],
  ["sort.Ints", "sort: func Ints([]int)"],
  ["sort.IntsAreSorted", "sort: func IntsAreSorted([]int) bool"],
  ["sort.IsSorted", "sort: func IsSorted(Interface) bool"],
  ["sort.Search", "sort: func Search(int: func(int) bool) int"],
  ["sort.SearchFloat64s", "sort: func SearchFloat64s([]float64: float64) int"],
  ["sort.SearchInts", "sort: func SearchInts([]int: int) int"],
  ["sort.SearchStrings", "sort: func SearchStrings([]string: string) int"],
  ["sort.Sort", "sort: func Sort(Interface)"],
  ["sort.Strings", "sort: func Strings([]string)"],
  ["sort.StringsAreSorted", "sort: func StringsAreSorted([]string) bool"],
  ["sort.Float64Slice.Len", "sort: method (Float64Slice) Len() int"],
  ["sort.Float64Slice.Less", "sort: method (Float64Slice) Less(int) bool"],
  ["sort.Float64Slice.Search", "sort: method (Float64Slice) Search(float64) int"],
  ["sort.Float64Slice.Sort", "sort: method (Float64Slice) Sort()"],
  ["sort.Float64Slice.Swap", "sort: method (Float64Slice) Swap(int)"],
  ["sort.IntSlice.Len", "sort: method (IntSlice) Len() int"],
  ["sort.IntSlice.Less", "sort: method (IntSlice) Less(int) bool"],
  ["sort.IntSlice.Search", "sort: method (IntSlice) Search(int) int"],
  ["sort.IntSlice.Sort", "sort: method (IntSlice) Sort()"],
  ["sort.IntSlice.Swap", "sort: method (IntSlice) Swap(int)"],
  ["sort.StringSlice.Len", "sort: method (StringSlice) Len() int"],
  ["sort.StringSlice.Less", "sort: method (StringSlice) Less(int) bool"],
  ["sort.StringSlice.Search", "sort: method (StringSlice) Search(string) int"],
  ["sort.StringSlice.Sort", "sort: method (StringSlice) Sort()"],
  ["sort.StringSlice.Swap", "sort: method (StringSlice) Swap(int)"],
  ["sort.Float64Slice []float64", "sort: type Float64Slice []float64"],
  ["sort.IntSlice []int", "sort: type IntSlice []int"],
  ["sort.Interface", "sort: type Interface interface { Len: Less: Swap }"],
  ["sort.StringSlice []string", "sort: type StringSlice []string"],
  ["strconv", "import \"strconv\""],
  ["strconv.IntSize", "strconv: const IntSize ideal-int"],
  ["strconv.AppendBool", "strconv: func AppendBool([]byte: bool) []byte"],
  ["strconv.AppendFloat", "strconv: func AppendFloat([]byte: float64: byte: int: int) []byte"],
  ["strconv.AppendInt", "strconv: func AppendInt([]byte: int64: int) []byte"],
  ["strconv.AppendQuote", "strconv: func AppendQuote([]byte: string) []byte"],
  ["strconv.AppendQuoteRune", "strconv: func AppendQuoteRune([]byte: rune) []byte"],
  ["strconv.AppendQuoteRuneToASCII", "strconv: func AppendQuoteRuneToASCII([]byte: rune) []byte"],
  ["strconv.AppendQuoteToASCII", "strconv: func AppendQuoteToASCII([]byte: string) []byte"],
  ["strconv.AppendUint", "strconv: func AppendUint([]byte: uint64: int) []byte"],
  ["strconv.Atoi", "strconv: func Atoi(string) (int: error)"],
  ["strconv.CanBackquote", "strconv: func CanBackquote(string) bool"],
  ["strconv.FormatBool", "strconv: func FormatBool(bool) string"],
  ["strconv.FormatFloat", "strconv: func FormatFloat(float64: byte: int) string"],
  ["strconv.FormatInt", "strconv: func FormatInt(int64: int) string"],
  ["strconv.FormatUint", "strconv: func FormatUint(uint64: int) string"],
  ["strconv.IsPrint", "strconv: func IsPrint(rune) bool"],
  ["strconv.Itoa", "strconv: func Itoa(int) string"],
  ["strconv.ParseBool", "strconv: func ParseBool(string) (bool: error)"],
  ["strconv.ParseFloat", "strconv: func ParseFloat(string: int) (float64: error)"],
  ["strconv.ParseInt", "strconv: func ParseInt(string: int: int) (int64: error)"],
  ["strconv.ParseUint", "strconv: func ParseUint(string: int: int) (uint64: error)"],
  ["strconv.Quote", "strconv: func Quote(string) string"],
  ["strconv.QuoteRune", "strconv: func QuoteRune(rune) string"],
  ["strconv.QuoteRuneToASCII", "strconv: func QuoteRuneToASCII(rune) string"],
  ["strconv.QuoteToASCII", "strconv: func QuoteToASCII(string) string"],
  ["strconv.Unquote", "strconv: func Unquote(string) (string: error)"],
  ["strconv.UnquoteChar", "strconv: func UnquoteChar(string: byte) (rune: bool: string: error)"],
  ["strconv.NumError.Error", "strconv: method (*NumError) Error() string"],
  ["strconv.NumError", "strconv: type NumError struct"],
  ["strings", "import \"strings\""],
  ["strings.Contains", "strings: func Contains(string) bool"],
  ["strings.ContainsAny", "strings: func ContainsAny(string) bool"],
  ["strings.ContainsRune", "strings: func ContainsRune(string: rune) bool"],
  ["strings.Count", "strings: func Count(string) int"],
  ["strings.EqualFold", "strings: func EqualFold(string) bool"],
  ["strings.Fields", "strings: func Fields(string) []string"],
  ["strings.FieldsFunc", "strings: func FieldsFunc(string: func(rune) bool) []string"],
  ["strings.HasPrefix", "strings: func HasPrefix(string) bool"],
  ["strings.HasSuffix", "strings: func HasSuffix(string) bool"],
  ["strings.Index", "strings: func Index(string) int"],
  ["strings.IndexAny", "strings: func IndexAny(string) int"],
  ["strings.IndexFunc", "strings: func IndexFunc(string: func(rune) bool) int"],
  ["strings.IndexRune", "strings: func IndexRune(string: rune) int"],
  ["strings.Join", "strings: func Join([]string: string) string"],
  ["strings.LastIndex", "strings: func LastIndex(string) int"],
  ["strings.LastIndexAny", "strings: func LastIndexAny(string) int"],
  ["strings.LastIndexFunc", "strings: func LastIndexFunc(string: func(rune) bool) int"],
  ["strings.Map", "strings: func Map(func(rune) rune: string) string"],
  ["strings.NewReader", "strings: func NewReader(string) *Reader"],
  ["strings.NewReplacer", "strings: func NewReplacer(...string) *Replacer"],
  ["strings.Repeat", "strings: func Repeat(string: int) string"],
  ["strings.Replace", "strings: func Replace(string: int) string"],
  ["strings.Split", "strings: func Split(string) []string"],
  ["strings.SplitAfter", "strings: func SplitAfter(string) []string"],
  ["strings.SplitAfterN", "strings: func SplitAfterN(string: int) []string"],
  ["strings.SplitN", "strings: func SplitN(string: int) []string"],
  ["strings.Title", "strings: func Title(string) string"],
  ["strings.ToLower", "strings: func ToLower(string) string"],
  ["strings.ToLowerSpecial", "strings: func ToLowerSpecial(unicode.SpecialCase: string) string"],
  ["strings.ToTitle", "strings: func ToTitle(string) string"],
  ["strings.ToTitleSpecial", "strings: func ToTitleSpecial(unicode.SpecialCase: string) string"],
  ["strings.ToUpper", "strings: func ToUpper(string) string"],
  ["strings.ToUpperSpecial", "strings: func ToUpperSpecial(unicode.SpecialCase: string) string"],
  ["strings.Trim", "strings: func Trim(string: string) string"],
  ["strings.TrimFunc", "strings: func TrimFunc(string: func(rune) bool) string"],
  ["strings.TrimLeft", "strings: func TrimLeft(string: string) string"],
  ["strings.TrimLeftFunc", "strings: func TrimLeftFunc(string: func(rune) bool) string"],
  ["strings.TrimRight", "strings: func TrimRight(string: string) string"],
  ["strings.TrimRightFunc", "strings: func TrimRightFunc(string: func(rune) bool) string"],
  ["strings.TrimSpace", "strings: func TrimSpace(string) string"],
  ["strings.Reader.Len", "strings: method (*Reader) Len() int"],
  ["strings.Reader.Read", "strings: method (*Reader) Read([]byte) (int: error)"],
  ["strings.Reader.ReadAt", "strings: method (*Reader) ReadAt([]byte: int64) (int: error)"],
  ["strings.Reader.ReadByte", "strings: method (*Reader) ReadByte() (byte: error)"],
  ["strings.Reader.ReadRune", "strings: method (*Reader) ReadRune() (rune: int: error)"],
  ["strings.Reader.Seek", "strings: method (*Reader) Seek(int64: int) (int64: error)"],
  ["strings.Reader.UnreadByte", "strings: method (*Reader) UnreadByte() error"],
  ["strings.Reader.UnreadRune", "strings: method (*Reader) UnreadRune() error"],
  ["strings.Replacer.Replace", "strings: method (*Replacer) Replace(string) string"],
  ["strings.Replacer.WriteString", "strings: method (*Replacer) WriteString(io.Writer: string) (int: error)"],
  ["strings.Reader", "strings: type Reader struct"],
  ["strings.Replacer", "strings: type Replacer struct"],
  ["sync", "import \"sync\""],
  ["sync.NewCond", "sync: func NewCond(Locker) *Cond"],
  ["sync.Cond.Broadcast", "sync: method (*Cond) Broadcast()"],
  ["sync.Cond.Signal", "sync: method (*Cond) Signal()"],
  ["sync.Cond.Wait", "sync: method (*Cond) Wait()"],
  ["sync.Mutex.Lock", "sync: method (*Mutex) Lock()"],
  ["sync.Mutex.Unlock", "sync: method (*Mutex) Unlock()"],
  ["sync.Once.Do", "sync: method (*Once) Do(func())"],
  ["sync.RWMutex.Lock", "sync: method (*RWMutex) Lock()"],
  ["sync.RWMutex.RLock", "sync: method (*RWMutex) RLock()"],
  ["sync.RWMutex.RLocker", "sync: method (*RWMutex) RLocker() Locker"],
  ["sync.RWMutex.RUnlock", "sync: method (*RWMutex) RUnlock()"],
  ["sync.RWMutex.Unlock", "sync: method (*RWMutex) Unlock()"],
  ["sync.WaitGroup.Add", "sync: method (*WaitGroup) Add(int)"],
  ["sync.WaitGroup.Done", "sync: method (*WaitGroup) Done()"],
  ["sync.WaitGroup.Wait", "sync: method (*WaitGroup) Wait()"],
  ["sync.Cond", "sync: type Cond struct"],
  ["sync.Locker", "sync: type Locker interface { Lock: Unlock }"],
  ["sync.Mutex", "sync: type Mutex struct"],
  ["sync.Once", "sync: type Once struct"],
  ["sync.RWMutex", "sync: type RWMutex struct"],
  ["sync.WaitGroup", "sync: type WaitGroup struct"],
  ["atomic", "import \"sync/atomic\""],
  ["atomic.AddInt32", "sync/atomic: func AddInt32(*int32: int32) int32"],
  ["atomic.AddInt64", "sync/atomic: func AddInt64(*int64: int64) int64"],
  ["atomic.AddUint32", "sync/atomic: func AddUint32(*uint32: uint32) uint32"],
  ["atomic.AddUint64", "sync/atomic: func AddUint64(*uint64: uint64) uint64"],
  ["atomic.AddUintptr", "sync/atomic: func AddUintptr(*uintptr: uintptr) uintptr"],
  ["atomic.CompareAndSwapInt32", "sync/atomic: func CompareAndSwapInt32(*int32: int32) bool"],
  ["atomic.CompareAndSwapInt64", "sync/atomic: func CompareAndSwapInt64(*int64: int64) bool"],
  ["atomic.CompareAndSwapPointer", "sync/atomic: func CompareAndSwapPointer(*unsafe.Pointer: unsafe.Pointer) bool"],
  ["atomic.CompareAndSwapUint32", "sync/atomic: func CompareAndSwapUint32(*uint32: uint32) bool"],
  ["atomic.CompareAndSwapUint64", "sync/atomic: func CompareAndSwapUint64(*uint64: uint64) bool"],
  ["atomic.CompareAndSwapUintptr", "sync/atomic: func CompareAndSwapUintptr(*uintptr: uintptr) bool"],
  ["atomic.LoadInt32", "sync/atomic: func LoadInt32(*int32) int32"],
  ["atomic.LoadInt64", "sync/atomic: func LoadInt64(*int64) int64"],
  ["atomic.LoadPointer", "sync/atomic: func LoadPointer(*unsafe.Pointer) unsafe.Pointer"],
  ["atomic.LoadUint32", "sync/atomic: func LoadUint32(*uint32) uint32"],
  ["atomic.LoadUint64", "sync/atomic: func LoadUint64(*uint64) uint64"],
  ["atomic.LoadUintptr", "sync/atomic: func LoadUintptr(*uintptr) uintptr"],
  ["atomic.StoreInt32", "sync/atomic: func StoreInt32(*int32: int32)"],
  ["atomic.StoreInt64", "sync/atomic: func StoreInt64(*int64: int64)"],
  ["atomic.StorePointer", "sync/atomic: func StorePointer(*unsafe.Pointer: unsafe.Pointer)"],
  ["atomic.StoreUint32", "sync/atomic: func StoreUint32(*uint32: uint32)"],
  ["atomic.StoreUint64", "sync/atomic: func StoreUint64(*uint64: uint64)"],
  ["atomic.StoreUintptr", "sync/atomic: func StoreUintptr(*uintptr: uintptr)"],
  ["testing", "import \"testing\""],
  ["testing.Benchmark", "testing: func Benchmark(func(*B)) BenchmarkResult"],
  ["testing.Main", "testing: func Main(func(string) (bool: error): []InternalTest: []InternalBenchmark: []InternalExample)"],
  ["testing.RunBenchmarks", "testing: func RunBenchmarks(func(string) (bool: error): []InternalBenchmark)"],
  ["testing.RunExamples", "testing: func RunExamples(func(string) (bool: error): []InternalExample) bool"],
  ["testing.RunTests", "testing: func RunTests(func(string) (bool: error): []InternalTest) bool"],
  ["testing.Short", "testing: func Short() bool"],
  ["testing.B.Error", "testing: method (*B) Error(...interface{})"],
  ["testing.B.Errorf", "testing: method (*B) Errorf(string: ...interface{})"],
  ["testing.B.Fail", "testing: method (*B) Fail()"],
  ["testing.B.FailNow", "testing: method (*B) FailNow()"],
  ["testing.B.Failed", "testing: method (*B) Failed() bool"],
  ["testing.B.Fatal", "testing: method (*B) Fatal(...interface{})"],
  ["testing.B.Fatalf", "testing: method (*B) Fatalf(string: ...interface{})"],
  ["testing.B.Log", "testing: method (*B) Log(...interface{})"],
  ["testing.B.Logf", "testing: method (*B) Logf(string: ...interface{})"],
  ["testing.B.ResetTimer", "testing: method (*B) ResetTimer()"],
  ["testing.B.SetBytes", "testing: method (*B) SetBytes(int64)"],
  ["testing.B.StartTimer", "testing: method (*B) StartTimer()"],
  ["testing.B.StopTimer", "testing: method (*B) StopTimer()"],
  ["testing.T.Error", "testing: method (*T) Error(...interface{})"],
  ["testing.T.Errorf", "testing: method (*T) Errorf(string: ...interface{})"],
  ["testing.T.Fail", "testing: method (*T) Fail()"],
  ["testing.T.FailNow", "testing: method (*T) FailNow()"],
  ["testing.T.Failed", "testing: method (*T) Failed() bool"],
  ["testing.T.Fatal", "testing: method (*T) Fatal(...interface{})"],
  ["testing.T.Fatalf", "testing: method (*T) Fatalf(string: ...interface{})"],
  ["testing.T.Log", "testing: method (*T) Log(...interface{})"],
  ["testing.T.Logf", "testing: method (*T) Logf(string: ...interface{})"],
  ["testing.T.Parallel", "testing: method (*T) Parallel()"],
  ["testing.BenchmarkResult.NsPerOp", "testing: method (BenchmarkResult) NsPerOp() int64"],
  ["testing.BenchmarkResult.String", "testing: method (BenchmarkResult) String() string"],
  ["testing.B", "testing: type B struct"],
  ["testing.BenchmarkResult", "testing: type BenchmarkResult struct"],
  ["testing.InternalBenchmark", "testing: type InternalBenchmark struct"],
  ["testing.InternalExample", "testing: type InternalExample struct"],
  ["testing.InternalTest", "testing: type InternalTest struct"],
  ["testing.T", "testing: type T struct"],
  ["iotest", "import \"testing/iotest\""],
  ["iotest.DataErrReader", "testing/iotest: func DataErrReader(io.Reader) io.Reader"],
  ["iotest.HalfReader", "testing/iotest: func HalfReader(io.Reader) io.Reader"],
  ["iotest.NewReadLogger", "testing/iotest: func NewReadLogger(string: io.Reader) io.Reader"],
  ["iotest.NewWriteLogger", "testing/iotest: func NewWriteLogger(string: io.Writer) io.Writer"],
  ["iotest.OneByteReader", "testing/iotest: func OneByteReader(io.Reader) io.Reader"],
  ["iotest.TimeoutReader", "testing/iotest: func TimeoutReader(io.Reader) io.Reader"],
  ["iotest.TruncateWriter", "testing/iotest: func TruncateWriter(io.Writer: int64) io.Writer"],
  ["quick", "import \"testing/quick\""],
  ["quick.Check", "testing/quick: func Check(interface{}: *Config) error"],
  ["quick.CheckEqual", "testing/quick: func CheckEqual(interface{}: *Config) error"],
  ["quick.Value", "testing/quick: func Value(reflect.Type: *rand.Rand) (reflect.Value: bool)"],
  ["quick.CheckEqualError.Error", "testing/quick: method (*CheckEqualError) Error() string"],
  ["quick.CheckError.Error", "testing/quick: method (*CheckError) Error() string"],
  ["quick.SetupError.Error", "testing/quick: method (SetupError) Error() string"],
  ["quick.CheckEqualError", "testing/quick: type CheckEqualError struct"],
  ["quick.CheckError", "testing/quick: type CheckError struct"],
  ["quick.Config", "testing/quick: type Config struct"],
  ["quick.Generator", "testing/quick: type Generator interface { Generate }"],
  ["quick.SetupError", "testing/quick: type SetupError string"],
  ["scanner.Char", "text/scanner: const Char ideal-int"],
  ["scanner.Comment", "text/scanner: const Comment ideal-int"],
  ["scanner.EOF", "text/scanner: const EOF ideal-int"],
  ["scanner.Float", "text/scanner: const Float ideal-int"],
  ["scanner.GoTokens", "text/scanner: const GoTokens ideal-int"],
  ["scanner.GoWhitespace", "text/scanner: const GoWhitespace ideal-int"],
  ["scanner.Ident", "text/scanner: const Ident ideal-int"],
  ["scanner.Int", "text/scanner: const Int ideal-int"],
  ["scanner.RawString", "text/scanner: const RawString ideal-int"],
  ["scanner.ScanChars", "text/scanner: const ScanChars ideal-int"],
  ["scanner.ScanFloats", "text/scanner: const ScanFloats ideal-int"],
  ["scanner.ScanIdents", "text/scanner: const ScanIdents ideal-int"],
  ["scanner.ScanInts", "text/scanner: const ScanInts ideal-int"],
  ["scanner.ScanRawStrings", "text/scanner: const ScanRawStrings ideal-int"],
  ["scanner.ScanStrings", "text/scanner: const ScanStrings ideal-int"],
  ["scanner.SkipComments", "text/scanner: const SkipComments ideal-int"],
  ["scanner.String", "text/scanner: const String ideal-int"],
  ["scanner.TokenString", "text/scanner: func TokenString(rune) string"],
  ["scanner.Position.IsValid", "text/scanner: method (*Position) IsValid() bool"],
  ["scanner.Scanner.IsValid", "text/scanner: method (*Scanner) IsValid() bool"],
  ["scanner.Scanner.Next", "text/scanner: method (*Scanner) Next() rune"],
  ["scanner.Scanner.Peek", "text/scanner: method (*Scanner) Peek() rune"],
  ["scanner.Scanner.Pos", "text/scanner: method (*Scanner) Pos() Position"],
  ["scanner.Scanner.TokenText", "text/scanner: method (*Scanner) TokenText() string"],
  ["scanner.Position.String", "text/scanner: method (Position) String() string"],
  ["scanner.Scanner.String", "text/scanner: method (Scanner) String() string"],
  ["scanner.Position", "text/scanner: type Position struct"],
  ["tabwriter", "import \"text/tabwriter\""],
  ["tabwriter.AlignRight", "text/tabwriter: const AlignRight uint"],
  ["tabwriter.Debug", "text/tabwriter: const Debug uint"],
  ["tabwriter.DiscardEmptyColumns", "text/tabwriter: const DiscardEmptyColumns uint"],
  ["tabwriter.Escape", "text/tabwriter: const Escape ideal-char"],
  ["tabwriter.FilterHTML", "text/tabwriter: const FilterHTML uint"],
  ["tabwriter.StripEscape", "text/tabwriter: const StripEscape uint"],
  ["tabwriter.TabIndent", "text/tabwriter: const TabIndent uint"],
  ["tabwriter.NewWriter", "text/tabwriter: func NewWriter(io.Writer: int: byte: uint) *Writer"],
  ["tabwriter.Writer.Flush", "text/tabwriter: method (*Writer) Flush() error"],
  ["tabwriter.Writer.Init", "text/tabwriter: method (*Writer) Init(io.Writer: int: byte: uint) *Writer"],
  ["tabwriter.Writer.Write", "text/tabwriter: method (*Writer) Write([]byte) (int: error)"],
  ["tabwriter.Writer", "text/tabwriter: type Writer struct"],
  ["parse", "import \"text/template/parse\""],
  ["parse.NodeAction", "text/template/parse: const NodeAction NodeType"],
  ["parse.NodeBool", "text/template/parse: const NodeBool NodeType"],
  ["parse.NodeCommand", "text/template/parse: const NodeCommand NodeType"],
  ["parse.NodeDot", "text/template/parse: const NodeDot NodeType"],
  ["parse.NodeField", "text/template/parse: const NodeField NodeType"],
  ["parse.NodeIdentifier", "text/template/parse: const NodeIdentifier NodeType"],
  ["parse.NodeIf", "text/template/parse: const NodeIf NodeType"],
  ["parse.NodeList", "text/template/parse: const NodeList NodeType"],
  ["parse.NodeNumber", "text/template/parse: const NodeNumber NodeType"],
  ["parse.NodePipe", "text/template/parse: const NodePipe NodeType"],
  ["parse.NodeRange", "text/template/parse: const NodeRange NodeType"],
  ["parse.NodeString", "text/template/parse: const NodeString NodeType"],
  ["parse.NodeTemplate", "text/template/parse: const NodeTemplate NodeType"],
  ["parse.NodeText", "text/template/parse: const NodeText NodeType"],
  ["parse.NodeVariable", "text/template/parse: const NodeVariable NodeType"],
  ["parse.NodeWith", "text/template/parse: const NodeWith NodeType"],
  ["parse.IsEmptyTree", "text/template/parse: func IsEmptyTree(Node) bool"],
  ["parse.New", "text/template/parse: func New(string: ...map[string]interface{}) *Tree"],
  ["parse.NewIdentifier", "text/template/parse: func NewIdentifier(string) *IdentifierNode"],
  ["parse.Parse", "text/template/parse: func Parse(string: ...map[string]interface{}) (map[string]*Tree: error)"],
  ["parse.ActionNode.Copy", "text/template/parse: method (*ActionNode) Copy() Node"],
  ["parse.ActionNode.String", "text/template/parse: method (*ActionNode) String() string"],
  ["parse.BoolNode.Copy", "text/template/parse: method (*BoolNode) Copy() Node"],
  ["parse.BoolNode.String", "text/template/parse: method (*BoolNode) String() string"],
  ["parse.BranchNode.String", "text/template/parse: method (*BranchNode) String() string"],
  ["parse.CommandNode.Copy", "text/template/parse: method (*CommandNode) Copy() Node"],
  ["parse.CommandNode.String", "text/template/parse: method (*CommandNode) String() string"],
  ["parse.DotNode.Copy", "text/template/parse: method (*DotNode) Copy() Node"],
  ["parse.DotNode.String", "text/template/parse: method (*DotNode) String() string"],
  ["parse.DotNode.Type", "text/template/parse: method (*DotNode) Type() NodeType"],
  ["parse.FieldNode.Copy", "text/template/parse: method (*FieldNode) Copy() Node"],
  ["parse.FieldNode.String", "text/template/parse: method (*FieldNode) String() string"],
  ["parse.IdentifierNode.Copy", "text/template/parse: method (*IdentifierNode) Copy() Node"],
  ["parse.IdentifierNode.String", "text/template/parse: method (*IdentifierNode) String() string"],
  ["parse.IfNode.Copy", "text/template/parse: method (*IfNode) Copy() Node"],
  ["parse.IfNode.String", "text/template/parse: method (*IfNode) String() string"],
  ["parse.ListNode.Copy", "text/template/parse: method (*ListNode) Copy() Node"],
  ["parse.ListNode.CopyList", "text/template/parse: method (*ListNode) CopyList() *ListNode"],
  ["parse.ListNode.String", "text/template/parse: method (*ListNode) String() string"],
  ["parse.NumberNode.Copy", "text/template/parse: method (*NumberNode) Copy() Node"],
  ["parse.NumberNode.String", "text/template/parse: method (*NumberNode) String() string"],
  ["parse.PipeNode.Copy", "text/template/parse: method (*PipeNode) Copy() Node"],
  ["parse.PipeNode.CopyPipe", "text/template/parse: method (*PipeNode) CopyPipe() *PipeNode"],
  ["parse.PipeNode.String", "text/template/parse: method (*PipeNode) String() string"],
  ["parse.RangeNode.Copy", "text/template/parse: method (*RangeNode) Copy() Node"],
  ["parse.RangeNode.String", "text/template/parse: method (*RangeNode) String() string"],
  ["parse.StringNode.Copy", "text/template/parse: method (*StringNode) Copy() Node"],
  ["parse.StringNode.String", "text/template/parse: method (*StringNode) String() string"],
  ["parse.TemplateNode.Copy", "text/template/parse: method (*TemplateNode) Copy() Node"],
  ["parse.TemplateNode.String", "text/template/parse: method (*TemplateNode) String() string"],
  ["parse.TextNode.Copy", "text/template/parse: method (*TextNode) Copy() Node"],
  ["parse.TextNode.String", "text/template/parse: method (*TextNode) String() string"],
  ["parse.Tree.Parse", "text/template/parse: method (*Tree) Parse(string: map[string]*Tree: ...map[string]interface{}) (*Tree: error)"],
  ["parse.VariableNode.Copy", "text/template/parse: method (*VariableNode) Copy() Node"],
  ["parse.VariableNode.String", "text/template/parse: method (*VariableNode) String() string"],
  ["parse.WithNode.Copy", "text/template/parse: method (*WithNode) Copy() Node"],
  ["parse.WithNode.String", "text/template/parse: method (*WithNode) String() string"],
  ["parse.ActionNode.Type", "text/template/parse: method (ActionNode) Type() NodeType"],
  ["parse.BoolNode.Type", "text/template/parse: method (BoolNode) Type() NodeType"],
  ["parse.BranchNode.Type", "text/template/parse: method (BranchNode) Type() NodeType"],
  ["parse.CommandNode.Type", "text/template/parse: method (CommandNode) Type() NodeType"],
  ["parse.FieldNode.Type", "text/template/parse: method (FieldNode) Type() NodeType"],
  ["parse.IdentifierNode.Type", "text/template/parse: method (IdentifierNode) Type() NodeType"],
  ["parse.IfNode.Type", "text/template/parse: method (IfNode) Type() NodeType"],
  ["parse.ListNode.Type", "text/template/parse: method (ListNode) Type() NodeType"],
  ["parse.NodeType.Type", "text/template/parse: method (NodeType) Type() NodeType"],
  ["parse.NumberNode.Type", "text/template/parse: method (NumberNode) Type() NodeType"],
  ["parse.PipeNode.Type", "text/template/parse: method (PipeNode) Type() NodeType"],
  ["parse.RangeNode.Type", "text/template/parse: method (RangeNode) Type() NodeType"],
  ["parse.StringNode.Type", "text/template/parse: method (StringNode) Type() NodeType"],
  ["parse.TemplateNode.Type", "text/template/parse: method (TemplateNode) Type() NodeType"],
  ["parse.TextNode.Type", "text/template/parse: method (TextNode) Type() NodeType"],
  ["parse.VariableNode.Type", "text/template/parse: method (VariableNode) Type() NodeType"],
  ["parse.WithNode.Type", "text/template/parse: method (WithNode) Type() NodeType"],
  ["parse.ActionNode", "text/template/parse: type ActionNode struct"],
  ["parse.BoolNode", "text/template/parse: type BoolNode struct"],
  ["parse.BranchNode", "text/template/parse: type BranchNode struct"],
  ["parse.CommandNode", "text/template/parse: type CommandNode struct"],
  ["parse.DotNode", "text/template/parse: type DotNode bool"],
  ["parse.FieldNode", "text/template/parse: type FieldNode struct"],
  ["parse.IdentifierNode", "text/template/parse: type IdentifierNode struct"],
  ["parse.IfNode", "text/template/parse: type IfNode struct"],
  ["parse.ListNode", "text/template/parse: type ListNode struct"],
  ["parse.Node", "text/template/parse: type Node interface { Copy: String: Type }"],
  ["parse.NodeType", "text/template/parse: type NodeType int"],
  ["parse.NumberNode", "text/template/parse: type NumberNode struct"],
  ["parse.PipeNode", "text/template/parse: type PipeNode struct"],
  ["parse.RangeNode", "text/template/parse: type RangeNode struct"],
  ["parse.StringNode", "text/template/parse: type StringNode struct"],
  ["parse.TemplateNode", "text/template/parse: type TemplateNode struct"],
  ["parse.TextNode", "text/template/parse: type TextNode struct"],
  ["parse.Tree", "text/template/parse: type Tree struct"],
  ["parse.VariableNode", "text/template/parse: type VariableNode struct"],
  ["parse.WithNode", "text/template/parse: type WithNode struct"],
  ["time", "import \"time\""],
  ["time.ANSIC", "time: const ANSIC ideal-string"],
  ["time.April", "time: const April Month"],
  ["time.August", "time: const August Month"],
  ["time.December", "time: const December Month"],
  ["time.February", "time: const February Month"],
  ["time.Friday", "time: const Friday Weekday"],
  ["time.Hour", "time: const Hour Duration"],
  ["time.January", "time: const January Month"],
  ["time.July", "time: const July Month"],
  ["time.June", "time: const June Month"],
  ["time.Kitchen", "time: const Kitchen ideal-string"],
  ["time.March", "time: const March Month"],
  ["time.May", "time: const May Month"],
  ["time.Microsecond", "time: const Microsecond Duration"],
  ["time.Millisecond", "time: const Millisecond Duration"],
  ["time.Minute", "time: const Minute Duration"],
  ["time.Monday", "time: const Monday Weekday"],
  ["time.Nanosecond", "time: const Nanosecond Duration"],
  ["time.November", "time: const November Month"],
  ["time.October", "time: const October Month"],
  ["time.RFC1123", "time: const RFC1123 ideal-string"],
  ["time.RFC1123Z", "time: const RFC1123Z ideal-string"],
  ["time.RFC3339", "time: const RFC3339 ideal-string"],
  ["time.RFC3339Nano", "time: const RFC3339Nano ideal-string"],
  ["time.RFC822", "time: const RFC822 ideal-string"],
  ["time.RFC822Z", "time: const RFC822Z ideal-string"],
  ["time.RFC850", "time: const RFC850 ideal-string"],
  ["time.RubyDate", "time: const RubyDate ideal-string"],
  ["time.Saturday", "time: const Saturday Weekday"],
  ["time.Second", "time: const Second Duration"],
  ["time.September", "time: const September Month"],
  ["time.Stamp", "time: const Stamp ideal-string"],
  ["time.StampMicro", "time: const StampMicro ideal-string"],
  ["time.StampMilli", "time: const StampMilli ideal-string"],
  ["time.StampNano", "time: const StampNano ideal-string"],
  ["time.Sunday", "time: const Sunday Weekday"],
  ["time.Thursday", "time: const Thursday Weekday"],
  ["time.Tuesday", "time: const Tuesday Weekday"],
  ["time.UnixDate", "time: const UnixDate ideal-string"],
  ["time.Wednesday", "time: const Wednesday Weekday"],
  ["time.After", "time: func After(Duration) <-chan Time"],
  ["time.AfterFunc", "time: func AfterFunc(Duration: func()) *Timer"],
  ["time.Date", "time: func Date(int: Month: int: *Location) Time"],
  ["time.FixedZone", "time: func FixedZone(string: int) *Location"],
  ["time.LoadLocation", "time: func LoadLocation(string) (*Location: error)"],
  ["time.NewTicker", "time: func NewTicker(Duration) *Ticker"],
  ["time.NewTimer", "time: func NewTimer(Duration) *Timer"],
  ["time.Now", "time: func Now() Time"],
  ["time.Parse", "time: func Parse(string) (Time: error)"],
  ["time.ParseDuration", "time: func ParseDuration(string) (Duration: error)"],
  ["time.Since", "time: func Since(Time) Duration"],
  ["time.Sleep", "time: func Sleep(Duration)"],
  ["time.Tick", "time: func Tick(Duration) <-chan Time"],
  ["time.Unix", "time: func Unix(int64: int64) Time"],
  ["time.Location.String", "time: method (*Location) String() string"],
  ["time.ParseError.Error", "time: method (*ParseError) Error() string"],
  ["time.Ticker.Stop", "time: method (*Ticker) Stop()"],
  ["time.Time.GobDecode", "time: method (*Time) GobDecode([]byte) error"],
  ["time.Time.UnmarshalJSON", "time: method (*Time) UnmarshalJSON([]byte) error"],
  ["time.Timer.Stop", "time: method (*Timer) Stop() bool"],
  ["time.Duration.Hours", "time: method (Duration) Hours() float64"],
  ["time.Duration.Minutes", "time: method (Duration) Minutes() float64"],
  ["time.Duration.Nanoseconds", "time: method (Duration) Nanoseconds() int64"],
  ["time.Duration.Seconds", "time: method (Duration) Seconds() float64"],
  ["time.Duration.String", "time: method (Duration) String() string"],
  ["time.Month.String", "time: method (Month) String() string"],
  ["time.Time.Add", "time: method (Time) Add(Duration) Time"],
  ["time.Time.AddDate", "time: method (Time) AddDate(int: int: int) Time"],
  ["time.Time.After", "time: method (Time) After(Time) bool"],
  ["time.Time.Before", "time: method (Time) Before(Time) bool"],
  ["time.Time.Clock", "time: method (Time) Clock() int"],
  ["time.Time.Date", "time: method (Time) Date() (int: Month: int)"],
  ["time.Time.Day", "time: method (Time) Day() int"],
  ["time.Time.Equal", "time: method (Time) Equal(Time) bool"],
  ["time.Time.Format", "time: method (Time) Format(string) string"],
  ["time.Time.GobEncode", "time: method (Time) GobEncode() ([]byte: error)"],
  ["time.Time.Hour", "time: method (Time) Hour() int"],
  ["time.Time.ISOWeek", "time: method (Time) ISOWeek() int"],
  ["time.Time.In", "time: method (Time) In(*Location) Time"],
  ["time.Time.IsZero", "time: method (Time) IsZero() bool"],
  ["time.Time.Local", "time: method (Time) Local() Time"],
  ["time.Time.Location", "time: method (Time) Location() *Location"],
  ["time.Time.MarshalJSON", "time: method (Time) MarshalJSON() ([]byte: error)"],
  ["time.Time.Minute", "time: method (Time) Minute() int"],
  ["time.Time.Month", "time: method (Time) Month() Month"],
  ["time.Time.Nanosecond", "time: method (Time) Nanosecond() int"],
  ["time.Time.Second", "time: method (Time) Second() int"],
  ["time.Time.String", "time: method (Time) String() string"],
  ["time.Time.Sub", "time: method (Time) Sub(Time) Duration"],
  ["time.Time.UTC", "time: method (Time) UTC() Time"],
  ["time.Time.Unix", "time: method (Time) Unix() int64"],
  ["time.Time.UnixNano", "time: method (Time) UnixNano() int64"],
  ["time.Time.Weekday", "time: method (Time) Weekday() Weekday"],
  ["time.Time.Year", "time: method (Time) Year() int"],
  ["time.Time.Zone", "time: method (Time) Zone() (string: int)"],
  ["time.Weekday.String", "time: method (Weekday) String() string"],
  ["time.Duration", "time: type Duration int64"],
  ["time.Location", "time: type Location struct"],
  ["time.Month", "time: type Month int"],
  ["time.ParseError", "time: type ParseError struct"],
  ["time.Ticker", "time: type Ticker struct"],
  ["time.Time", "time: type Time struct"],
  ["time.Timer", "time: type Timer struct"],
  ["time.Weekday", "time: type Weekday int"],
  ["unicode", "import \"unicode\""],
  ["unicode.LowerCase", "unicode: const LowerCase ideal-int"],
  ["unicode.MaxASCII", "unicode: const MaxASCII ideal-char"],
  ["unicode.MaxCase", "unicode: const MaxCase ideal-int"],
  ["unicode.MaxLatin1", "unicode: const MaxLatin1 ideal-char"],
  ["unicode.MaxRune", "unicode: const MaxRune ideal-char"],
  ["unicode.ReplacementChar", "unicode: const ReplacementChar ideal-char"],
  ["unicode.TitleCase", "unicode: const TitleCase ideal-int"],
  ["unicode.UpperCase", "unicode: const UpperCase ideal-int"],
  ["unicode.UpperLower", "unicode: const UpperLower ideal-int"],
  ["unicode.Version", "unicode: const Version ideal-string"],
  ["unicode.Is", "unicode: func Is(*RangeTable: rune) bool"],
  ["unicode.IsControl", "unicode: func IsControl(rune) bool"],
  ["unicode.IsDigit", "unicode: func IsDigit(rune) bool"],
  ["unicode.IsGraphic", "unicode: func IsGraphic(rune) bool"],
  ["unicode.IsLetter", "unicode: func IsLetter(rune) bool"],
  ["unicode.IsLower", "unicode: func IsLower(rune) bool"],
  ["unicode.IsMark", "unicode: func IsMark(rune) bool"],
  ["unicode.IsNumber", "unicode: func IsNumber(rune) bool"],
  ["unicode.IsOneOf", "unicode: func IsOneOf([]*RangeTable: rune) bool"],
  ["unicode.IsPrint", "unicode: func IsPrint(rune) bool"],
  ["unicode.IsPunct", "unicode: func IsPunct(rune) bool"],
  ["unicode.IsSpace", "unicode: func IsSpace(rune) bool"],
  ["unicode.IsSymbol", "unicode: func IsSymbol(rune) bool"],
  ["unicode.IsTitle", "unicode: func IsTitle(rune) bool"],
  ["unicode.IsUpper", "unicode: func IsUpper(rune) bool"],
  ["unicode.SimpleFold", "unicode: func SimpleFold(rune) rune"],
  ["unicode.To", "unicode: func To(int: rune) rune"],
  ["unicode.ToLower", "unicode: func ToLower(rune) rune"],
  ["unicode.ToTitle", "unicode: func ToTitle(rune) rune"],
  ["unicode.ToUpper", "unicode: func ToUpper(rune) rune"],
  ["unicode.SpecialCase.ToLower", "unicode: method (SpecialCase) ToLower(rune) rune"],
  ["unicode.SpecialCase.ToTitle", "unicode: method (SpecialCase) ToTitle(rune) rune"],
  ["unicode.SpecialCase.ToUpper", "unicode: method (SpecialCase) ToUpper(rune) rune"],
  ["unicode.CaseRange", "unicode: type CaseRange struct"],
  ["unicode.Range16", "unicode: type Range16 struct"],
  ["unicode.Range32", "unicode: type Range32 struct"],
  ["unicode.RangeTable", "unicode: type RangeTable struct"],
  ["unicode.SpecialCase []CaseRange", "unicode: type SpecialCase []CaseRange"],
  ["utf16", "import \"unicode/utf16\""],
  ["utf16.Decode", "unicode/utf16: func Decode([]uint16) []rune"],
  ["utf16.DecodeRune", "unicode/utf16: func DecodeRune(rune) rune"],
  ["utf16.Encode", "unicode/utf16: func Encode([]rune) []uint16"],
  ["utf16.EncodeRune", "unicode/utf16: func EncodeRune(rune) rune"],
  ["utf16.IsSurrogate", "unicode/utf16: func IsSurrogate(rune) bool"],
  ["utf8", "import \"unicode/utf8\""],
  ["utf8.MaxRune", "unicode/utf8: const MaxRune ideal-char"],
  ["utf8.RuneError", "unicode/utf8: const RuneError ideal-char"],
  ["utf8.RuneSelf", "unicode/utf8: const RuneSelf ideal-int"],
  ["utf8.UTFMax", "unicode/utf8: const UTFMax ideal-int"],
  ["utf8.DecodeLastRune", "unicode/utf8: func DecodeLastRune([]byte) (rune: int)"],
  ["utf8.DecodeLastRuneInString", "unicode/utf8: func DecodeLastRuneInString(string) (rune: int)"],
  ["utf8.DecodeRune", "unicode/utf8: func DecodeRune([]byte) (rune: int)"],
  ["utf8.DecodeRuneInString", "unicode/utf8: func DecodeRuneInString(string) (rune: int)"],
  ["utf8.EncodeRune", "unicode/utf8: func EncodeRune([]byte: rune) int"],
  ["utf8.FullRune", "unicode/utf8: func FullRune([]byte) bool"],
  ["utf8.FullRuneInString", "unicode/utf8: func FullRuneInString(string) bool"],
  ["utf8.RuneCount", "unicode/utf8: func RuneCount([]byte) int"],
  ["utf8.RuneCountInString", "unicode/utf8: func RuneCountInString(string) int"],
  ["utf8.RuneLen", "unicode/utf8: func RuneLen(rune) int"],
  ["utf8.RuneStart", "unicode/utf8: func RuneStart(byte) bool"],
  ["utf8.Valid", "unicode/utf8: func Valid([]byte) bool"],
  ["utf8.ValidString", "unicode/utf8: func ValidString(string) bool"],
  ["unsafe", "import \"unsafe\""],
  ["unsafe.Alignof", "unsafe: func Alignof(ArbitraryType) uintptr"],
  ["unsafe.Offsetof", "unsafe: func Offsetof(ArbitraryType) uintptr"],
  ["unsafe.Sizeof", "unsafe: func Sizeof(ArbitraryType) uintptr"],
  ["unsafe.ArbitraryType", "unsafe: type ArbitraryType int"],
  ["unsafe.Pointer *ArbitraryType", "unsafe: type Pointer *ArbitraryType"]
]
#=================== generated by update.rb

query = ARGV[0]
query = /#{query.gsub("*", ".*?")}/i if query.include?("*")
matched_apis = apis.find_all{|api| api[0].index query}.sort do |a, b|
  index = a[0].index(query) <=> b[0].index(query)
  index != 0 ? index : (a[0] <=> b[0])
end[0...20]

items = ""
matched_apis.each do |api|
  items << <<-XML
  <item uid="" arg="#{api[0]}">
    <title>#{api[0]}</title>
    <subtitle>#{api[1]}</subtitle>
    <icon type="">./icon.png</icon>
  </item>
  XML
end

puts <<-XML
<items>
  #{items}
</items>
XML
